
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v4: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/labstack/echo/v4/bind.go (93.3%)</option>
				
				<option value="file1">github.com/labstack/echo/v4/binder.go (100.0%)</option>
				
				<option value="file2">github.com/labstack/echo/v4/context.go (94.2%)</option>
				
				<option value="file3">github.com/labstack/echo/v4/context_fs.go (90.0%)</option>
				
				<option value="file4">github.com/labstack/echo/v4/echo.go (97.4%)</option>
				
				<option value="file5">github.com/labstack/echo/v4/echo_fs.go (95.0%)</option>
				
				<option value="file6">github.com/labstack/echo/v4/group.go (100.0%)</option>
				
				<option value="file7">github.com/labstack/echo/v4/group_fs.go (100.0%)</option>
				
				<option value="file8">github.com/labstack/echo/v4/ip.go (100.0%)</option>
				
				<option value="file9">github.com/labstack/echo/v4/json.go (100.0%)</option>
				
				<option value="file10">github.com/labstack/echo/v4/middleware/basic_auth.go (78.8%)</option>
				
				<option value="file11">github.com/labstack/echo/v4/middleware/body_dump.go (100.0%)</option>
				
				<option value="file12">github.com/labstack/echo/v4/middleware/body_limit.go (96.9%)</option>
				
				<option value="file13">github.com/labstack/echo/v4/middleware/compress.go (92.6%)</option>
				
				<option value="file14">github.com/labstack/echo/v4/middleware/context_timeout.go (100.0%)</option>
				
				<option value="file15">github.com/labstack/echo/v4/middleware/cors.go (97.9%)</option>
				
				<option value="file16">github.com/labstack/echo/v4/middleware/csrf.go (94.6%)</option>
				
				<option value="file17">github.com/labstack/echo/v4/middleware/decompress.go (96.4%)</option>
				
				<option value="file18">github.com/labstack/echo/v4/middleware/extractor.go (97.7%)</option>
				
				<option value="file19">github.com/labstack/echo/v4/middleware/key_auth.go (96.5%)</option>
				
				<option value="file20">github.com/labstack/echo/v4/middleware/logger.go (90.7%)</option>
				
				<option value="file21">github.com/labstack/echo/v4/middleware/method_override.go (90.5%)</option>
				
				<option value="file22">github.com/labstack/echo/v4/middleware/middleware.go (97.4%)</option>
				
				<option value="file23">github.com/labstack/echo/v4/middleware/proxy.go (78.5%)</option>
				
				<option value="file24">github.com/labstack/echo/v4/middleware/rate_limiter.go (98.3%)</option>
				
				<option value="file25">github.com/labstack/echo/v4/middleware/recover.go (91.7%)</option>
				
				<option value="file26">github.com/labstack/echo/v4/middleware/redirect.go (100.0%)</option>
				
				<option value="file27">github.com/labstack/echo/v4/middleware/request_id.go (90.5%)</option>
				
				<option value="file28">github.com/labstack/echo/v4/middleware/request_logger.go (98.9%)</option>
				
				<option value="file29">github.com/labstack/echo/v4/middleware/rewrite.go (83.3%)</option>
				
				<option value="file30">github.com/labstack/echo/v4/middleware/secure.go (96.6%)</option>
				
				<option value="file31">github.com/labstack/echo/v4/middleware/slash.go (95.7%)</option>
				
				<option value="file32">github.com/labstack/echo/v4/middleware/static.go (80.0%)</option>
				
				<option value="file33">github.com/labstack/echo/v4/middleware/static_windows.go (100.0%)</option>
				
				<option value="file34">github.com/labstack/echo/v4/middleware/timeout.go (98.0%)</option>
				
				<option value="file35">github.com/labstack/echo/v4/middleware/util.go (93.6%)</option>
				
				<option value="file36">github.com/labstack/echo/v4/renderer.go (100.0%)</option>
				
				<option value="file37">github.com/labstack/echo/v4/response.go (90.6%)</option>
				
				<option value="file38">github.com/labstack/echo/v4/router.go (98.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "encoding"
        "encoding/xml"
        "errors"
        "fmt"
        "mime/multipart"
        "net/http"
        "reflect"
        "strconv"
        "strings"
)

// Binder is the interface that wraps the Bind method.
type Binder interface {
        Bind(i interface{}, c Context) error
}

// DefaultBinder is the default implementation of the Binder interface.
type DefaultBinder struct{}

// BindUnmarshaler is the interface used to wrap the UnmarshalParam method.
// Types that don't implement this, but do implement encoding.TextUnmarshaler
// will use that interface instead.
type BindUnmarshaler interface {
        // UnmarshalParam decodes and assigns a value from an form or query param.
        UnmarshalParam(param string) error
}

// bindMultipleUnmarshaler is used by binder to unmarshal multiple values from request at once to
// type implementing this interface. For example request could have multiple query fields `?a=1&amp;a=2&amp;b=test` in that case
// for `a` following slice `["1", "2"] will be passed to unmarshaller.
type bindMultipleUnmarshaler interface {
        UnmarshalParams(params []string) error
}

// BindPathParams binds path params to bindable object
func (b *DefaultBinder) BindPathParams(c Context, i interface{}) error <span class="cov8" title="1">{
        names := c.ParamNames()
        values := c.ParamValues()
        params := map[string][]string{}
        for i, name := range names </span><span class="cov8" title="1">{
                params[name] = []string{values[i]}
        }</span>
        <span class="cov8" title="1">if err := b.bindData(i, params, "param", nil); err != nil </span><span class="cov0" title="0">{
                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BindQueryParams binds query params to bindable object
func (b *DefaultBinder) BindQueryParams(c Context, i interface{}) error <span class="cov8" title="1">{
        if err := b.bindData(i, c.QueryParams(), "query", nil); err != nil </span><span class="cov8" title="1">{
                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BindBody binds request body contents to bindable object
// NB: then binding forms take note that this implementation uses standard library form parsing
// which parses form data from BOTH URL and BODY if content type is not MIMEMultipartForm
// See non-MIMEMultipartForm: https://golang.org/pkg/net/http/#Request.ParseForm
// See MIMEMultipartForm: https://golang.org/pkg/net/http/#Request.ParseMultipartForm
func (b *DefaultBinder) BindBody(c Context, i interface{}) (err error) <span class="cov8" title="1">{
        req := c.Request()
        if req.ContentLength == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // mediatype is found like `mime.ParseMediaType()` does it
        <span class="cov8" title="1">base, _, _ := strings.Cut(req.Header.Get(HeaderContentType), ";")
        mediatype := strings.TrimSpace(base)

        switch mediatype </span>{
        case MIMEApplicationJSON:<span class="cov8" title="1">
                if err = c.Echo().JSONSerializer.Deserialize(c, i); err != nil </span><span class="cov8" title="1">{
                        switch err.(type) </span>{
                        case *HTTPError:<span class="cov8" title="1">
                                return err</span>
                        default:<span class="cov8" title="1">
                                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)</span>
                        }
                }
        case MIMEApplicationXML, MIMETextXML:<span class="cov8" title="1">
                if err = xml.NewDecoder(req.Body).Decode(i); err != nil </span><span class="cov8" title="1">{
                        if ute, ok := err.(*xml.UnsupportedTypeError); ok </span><span class="cov0" title="0">{
                                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unsupported type error: type=%v, error=%v", ute.Type, ute.Error())).SetInternal(err)
                        }</span> else<span class="cov8" title="1"> if se, ok := err.(*xml.SyntaxError); ok </span><span class="cov8" title="1">{
                                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Syntax error: line=%v, error=%v", se.Line, se.Error())).SetInternal(err)
                        }</span>
                        <span class="cov8" title="1">return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)</span>
                }
        case MIMEApplicationForm:<span class="cov8" title="1">
                params, err := c.FormParams()
                if err != nil </span><span class="cov0" title="0">{
                        return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
                }</span>
                <span class="cov8" title="1">if err = b.bindData(i, params, "form", nil); err != nil </span><span class="cov8" title="1">{
                        return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
                }</span>
        case MIMEMultipartForm:<span class="cov8" title="1">
                params, err := c.MultipartForm()
                if err != nil </span><span class="cov0" title="0">{
                        return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
                }</span>
                <span class="cov8" title="1">if err = b.bindData(i, params.Value, "form", params.File); err != nil </span><span class="cov8" title="1">{
                        return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
                }</span>
        default:<span class="cov8" title="1">
                return ErrUnsupportedMediaType</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// BindHeaders binds HTTP headers to a bindable object
func (b *DefaultBinder) BindHeaders(c Context, i interface{}) error <span class="cov8" title="1">{
        if err := b.bindData(i, c.Request().Header, "header", nil); err != nil </span><span class="cov8" title="1">{
                return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Bind implements the `Binder#Bind` function.
// Binding is done in following order: 1) path params; 2) query params; 3) request body. Each step COULD override previous
// step binded values. For single source binding use their own methods BindBody, BindQueryParams, BindPathParams.
func (b *DefaultBinder) Bind(i interface{}, c Context) (err error) <span class="cov8" title="1">{
        if err := b.BindPathParams(c, i); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Only bind query parameters for GET/DELETE/HEAD to avoid unexpected behavior with destination struct binding from body.
        // For example a request URL `&amp;id=1&amp;lang=en` with body `{"id":100,"lang":"de"}` would lead to precedence issues.
        // The HTTP method check restores pre-v4.1.11 behavior to avoid these problems (see issue #1670)
        <span class="cov8" title="1">method := c.Request().Method
        if method == http.MethodGet || method == http.MethodDelete || method == http.MethodHead </span><span class="cov8" title="1">{
                if err = b.BindQueryParams(c, i); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return b.BindBody(c, i)</span>
}

// bindData will bind data ONLY fields in destination struct that have EXPLICIT tag
func (b *DefaultBinder) bindData(destination interface{}, data map[string][]string, tag string, dataFiles map[string][]*multipart.FileHeader) error <span class="cov8" title="1">{
        if destination == nil || (len(data) == 0 &amp;&amp; len(dataFiles) == 0) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">hasFiles := len(dataFiles) &gt; 0
        typ := reflect.TypeOf(destination).Elem()
        val := reflect.ValueOf(destination).Elem()

        // Support binding to limited Map destinations:
        // - map[string][]string,
        // - map[string]string &lt;-- (binds first value from data slice)
        // - map[string]interface{}
        // You are better off binding to struct but there are user who want this map feature. Source of data for these cases are:
        // params,query,header,form as these sources produce string values, most of the time slice of strings, actually.
        if typ.Kind() == reflect.Map &amp;&amp; typ.Key().Kind() == reflect.String </span><span class="cov8" title="1">{
                k := typ.Elem().Kind()
                isElemInterface := k == reflect.Interface
                isElemString := k == reflect.String
                isElemSliceOfStrings := k == reflect.Slice &amp;&amp; typ.Elem().Elem().Kind() == reflect.String
                if !(isElemSliceOfStrings || isElemString || isElemInterface) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if val.IsNil() </span><span class="cov8" title="1">{
                        val.Set(reflect.MakeMap(typ))
                }</span>
                <span class="cov8" title="1">for k, v := range data </span><span class="cov8" title="1">{
                        if isElemString </span><span class="cov8" title="1">{
                                val.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))
                        }</span> else<span class="cov8" title="1"> if isElemInterface </span><span class="cov8" title="1">{
                                // To maintain backward compatibility, we always bind to the first string value
                                // and not the slice of strings when dealing with map[string]interface{}{}
                                val.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))
                        }</span> else<span class="cov8" title="1"> {
                                val.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v))
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        // !struct
        <span class="cov8" title="1">if typ.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                if tag == "param" || tag == "query" || tag == "header" </span><span class="cov8" title="1">{
                        // incompatible type, data is probably to be found in the body
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.New("binding element must be a struct")</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; typ.NumField(); i++ </span><span class="cov8" title="1">{ // iterate over all destination fields
                typeField := typ.Field(i)
                structField := val.Field(i)
                if typeField.Anonymous </span><span class="cov8" title="1">{
                        if structField.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                structField = structField.Elem()
                        }</span>
                }
                <span class="cov8" title="1">if !structField.CanSet() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">structFieldKind := structField.Kind()
                inputFieldName := typeField.Tag.Get(tag)
                if typeField.Anonymous &amp;&amp; structFieldKind == reflect.Struct &amp;&amp; inputFieldName != "" </span><span class="cov8" title="1">{
                        // if anonymous struct with query/param/form tags, report an error
                        return errors.New("query/param/form tags are not allowed with anonymous struct field")
                }</span>

                <span class="cov8" title="1">if inputFieldName == "" </span><span class="cov8" title="1">{
                        // If tag is nil, we inspect if the field is a not BindUnmarshaler struct and try to bind data into it (might contain fields with tags).
                        // structs that implement BindUnmarshaler are bound only when they have explicit tag
                        if _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok &amp;&amp; structFieldKind == reflect.Struct </span><span class="cov8" title="1">{
                                if err := b.bindData(structField.Addr().Interface(), data, tag, dataFiles); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        // does not have explicit tag and is not an ordinary struct - so move to next field
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if hasFiles </span><span class="cov8" title="1">{
                        if ok, err := isFieldMultipartFile(structField.Type()); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span> else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                                if ok := setMultipartFileHeaderTypes(structField, inputFieldName, dataFiles); ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                        }
                }

                <span class="cov8" title="1">inputValue, exists := data[inputFieldName]
                if !exists </span><span class="cov8" title="1">{
                        // Go json.Unmarshal supports case-insensitive binding.  However the
                        // url params are bound case-sensitive which is inconsistent.  To
                        // fix this we must check all of the map values in a
                        // case-insensitive search.
                        for k, v := range data </span><span class="cov8" title="1">{
                                if strings.EqualFold(k, inputFieldName) </span><span class="cov8" title="1">{
                                        inputValue = v
                                        exists = true
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        continue</span>
                }

                // NOTE: algorithm here is not particularly sophisticated. It probably does not work with absurd types like `**[]*int`
                // but it is smart enough to handle niche cases like `*int`,`*[]string`,`[]*int` .

                // try unmarshalling first, in case we're dealing with an alias to an array type
                <span class="cov8" title="1">if ok, err := unmarshalInputsToField(typeField.Type.Kind(), inputValue, structField); ok </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if ok, err := unmarshalInputToField(typeField.Type.Kind(), inputValue[0], structField); ok </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // we could be dealing with pointer to slice `*[]string` so dereference it. There are weird OpenAPI generators
                // that could create struct fields like that.
                <span class="cov8" title="1">if structFieldKind == reflect.Pointer </span><span class="cov8" title="1">{
                        structFieldKind = structField.Elem().Kind()
                        structField = structField.Elem()
                }</span>

                <span class="cov8" title="1">if structFieldKind == reflect.Slice </span><span class="cov8" title="1">{
                        sliceOf := structField.Type().Elem().Kind()
                        numElems := len(inputValue)
                        slice := reflect.MakeSlice(structField.Type(), numElems, numElems)
                        for j := 0; j &lt; numElems; j++ </span><span class="cov8" title="1">{
                                if err := setWithProperType(sliceOf, inputValue[j], slice.Index(j)); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">structField.Set(slice)
                        continue</span>
                }

                <span class="cov8" title="1">if err := setWithProperType(structFieldKind, inputValue[0], structField); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func setWithProperType(valueKind reflect.Kind, val string, structField reflect.Value) error <span class="cov8" title="1">{
        // But also call it here, in case we're dealing with an array of BindUnmarshalers
        if ok, err := unmarshalInputToField(valueKind, val, structField); ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">switch valueKind </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                return setWithProperType(structField.Elem().Kind(), val, structField.Elem())</span>
        case reflect.Int:<span class="cov8" title="1">
                return setIntField(val, 0, structField)</span>
        case reflect.Int8:<span class="cov8" title="1">
                return setIntField(val, 8, structField)</span>
        case reflect.Int16:<span class="cov8" title="1">
                return setIntField(val, 16, structField)</span>
        case reflect.Int32:<span class="cov8" title="1">
                return setIntField(val, 32, structField)</span>
        case reflect.Int64:<span class="cov8" title="1">
                return setIntField(val, 64, structField)</span>
        case reflect.Uint:<span class="cov8" title="1">
                return setUintField(val, 0, structField)</span>
        case reflect.Uint8:<span class="cov8" title="1">
                return setUintField(val, 8, structField)</span>
        case reflect.Uint16:<span class="cov8" title="1">
                return setUintField(val, 16, structField)</span>
        case reflect.Uint32:<span class="cov8" title="1">
                return setUintField(val, 32, structField)</span>
        case reflect.Uint64:<span class="cov8" title="1">
                return setUintField(val, 64, structField)</span>
        case reflect.Bool:<span class="cov8" title="1">
                return setBoolField(val, structField)</span>
        case reflect.Float32:<span class="cov8" title="1">
                return setFloatField(val, 32, structField)</span>
        case reflect.Float64:<span class="cov8" title="1">
                return setFloatField(val, 64, structField)</span>
        case reflect.String:<span class="cov8" title="1">
                structField.SetString(val)</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func unmarshalInputsToField(valueKind reflect.Kind, values []string, field reflect.Value) (bool, error) <span class="cov8" title="1">{
        if valueKind == reflect.Ptr </span><span class="cov8" title="1">{
                if field.IsNil() </span><span class="cov8" title="1">{
                        field.Set(reflect.New(field.Type().Elem()))
                }</span>
                <span class="cov8" title="1">field = field.Elem()</span>
        }

        <span class="cov8" title="1">fieldIValue := field.Addr().Interface()
        unmarshaler, ok := fieldIValue.(bindMultipleUnmarshaler)
        if !ok </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, unmarshaler.UnmarshalParams(values)</span>
}

func unmarshalInputToField(valueKind reflect.Kind, val string, field reflect.Value) (bool, error) <span class="cov8" title="1">{
        if valueKind == reflect.Ptr </span><span class="cov8" title="1">{
                if field.IsNil() </span><span class="cov8" title="1">{
                        field.Set(reflect.New(field.Type().Elem()))
                }</span>
                <span class="cov8" title="1">field = field.Elem()</span>
        }

        <span class="cov8" title="1">fieldIValue := field.Addr().Interface()
        switch unmarshaler := fieldIValue.(type) </span>{
        case BindUnmarshaler:<span class="cov8" title="1">
                return true, unmarshaler.UnmarshalParam(val)</span>
        case encoding.TextUnmarshaler:<span class="cov8" title="1">
                return true, unmarshaler.UnmarshalText([]byte(val))</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

func setIntField(value string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                value = "0"
        }</span>
        <span class="cov8" title="1">intVal, err := strconv.ParseInt(value, 10, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetInt(intVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setUintField(value string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                value = "0"
        }</span>
        <span class="cov8" title="1">uintVal, err := strconv.ParseUint(value, 10, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetUint(uintVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setBoolField(value string, field reflect.Value) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                value = "false"
        }</span>
        <span class="cov8" title="1">boolVal, err := strconv.ParseBool(value)
        if err == nil </span><span class="cov8" title="1">{
                field.SetBool(boolVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func setFloatField(value string, bitSize int, field reflect.Value) error <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                value = "0.0"
        }</span>
        <span class="cov8" title="1">floatVal, err := strconv.ParseFloat(value, bitSize)
        if err == nil </span><span class="cov8" title="1">{
                field.SetFloat(floatVal)
        }</span>
        <span class="cov8" title="1">return err</span>
}

var (
        // NOT supported by bind as you can NOT check easily empty struct being actual file or not
        multipartFileHeaderType = reflect.TypeOf(multipart.FileHeader{})
        // supported by bind as you can check by nil value if file existed or not
        multipartFileHeaderPointerType      = reflect.TypeOf(&amp;multipart.FileHeader{})
        multipartFileHeaderSliceType        = reflect.TypeOf([]multipart.FileHeader(nil))
        multipartFileHeaderPointerSliceType = reflect.TypeOf([]*multipart.FileHeader(nil))
)

func isFieldMultipartFile(field reflect.Type) (bool, error) <span class="cov8" title="1">{
        switch field </span>{
        case multipartFileHeaderPointerType,
                multipartFileHeaderSliceType,
                multipartFileHeaderPointerSliceType:<span class="cov8" title="1">
                return true, nil</span>
        case multipartFileHeaderType:<span class="cov8" title="1">
                return true, errors.New("binding to multipart.FileHeader struct is not supported, use pointer to struct")</span>
        default:<span class="cov0" title="0">
                return false, nil</span>
        }
}

func setMultipartFileHeaderTypes(structField reflect.Value, inputFieldName string, files map[string][]*multipart.FileHeader) bool <span class="cov8" title="1">{
        fileHeaders := files[inputFieldName]
        if len(fileHeaders) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">result := true
        switch structField.Type() </span>{
        case multipartFileHeaderPointerSliceType:<span class="cov8" title="1">
                structField.Set(reflect.ValueOf(fileHeaders))</span>
        case multipartFileHeaderSliceType:<span class="cov8" title="1">
                headers := make([]multipart.FileHeader, len(fileHeaders))
                for i, fileHeader := range fileHeaders </span><span class="cov8" title="1">{
                        headers[i] = *fileHeader
                }</span>
                <span class="cov8" title="1">structField.Set(reflect.ValueOf(headers))</span>
        case multipartFileHeaderPointerType:<span class="cov8" title="1">
                structField.Set(reflect.ValueOf(fileHeaders[0]))</span>
        default:<span class="cov0" title="0">
                result = false</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "encoding"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"
)

/**
        Following functions provide handful of methods for binding to Go native types from request query or path parameters.
    * QueryParamsBinder(c) - binds query parameters (source URL)
    * PathParamsBinder(c) - binds path parameters (source URL)
    * FormFieldBinder(c) - binds form fields (source URL + body)

        Example:
  ```go
  var length int64
  err := echo.QueryParamsBinder(c).Int64("length", &amp;length).BindError()
  ```

        For every supported type there are following methods:
                * &lt;Type&gt;("param", &amp;destination) - if parameter value exists then binds it to given destination of that type i.e Int64(...).
                * Must&lt;Type&gt;("param", &amp;destination) - parameter value is required to exist, binds it to given destination of that type i.e MustInt64(...).
                * &lt;Type&gt;s("param", &amp;destination) - (for slices) if parameter values exists then binds it to given destination of that type i.e Int64s(...).
                * Must&lt;Type&gt;s("param", &amp;destination) - (for slices) parameter value is required to exist, binds it to given destination of that type i.e MustInt64s(...).

  for some slice types `BindWithDelimiter("param", &amp;dest, ",")` supports splitting parameter values before type conversion is done
  i.e. URL `/api/search?id=1,2,3&amp;id=1` can be bind to `[]int64{1,2,3,1}`

        `FailFast` flags binder to stop binding after first bind error during binder call chain. Enabled by default.
  `BindError()` returns first bind error from binder and resets errors in binder. Useful along with `FailFast()` method
                to do binding and returns on first problem
  `BindErrors()` returns all bind errors from binder and resets errors in binder.

        Types that are supported:
                * bool
                * float32
                * float64
                * int
                * int8
                * int16
                * int32
                * int64
                * uint
                * uint8/byte (does not support `bytes()`. Use BindUnmarshaler/CustomFunc to convert value from base64 etc to []byte{})
                * uint16
                * uint32
                * uint64
                * string
                * time
                * duration
                * BindUnmarshaler() interface
                * TextUnmarshaler() interface
                * JSONUnmarshaler() interface
                * UnixTime() - converts unix time (integer) to time.Time
                * UnixTimeMilli() - converts unix time with millisecond precision (integer) to time.Time
                * UnixTimeNano() - converts unix time with nanosecond precision (integer) to time.Time
                * CustomFunc() - callback function for your custom conversion logic. Signature `func(values []string) []error`
*/

// BindingError represents an error that occurred while binding request data.
type BindingError struct {
        // Field is the field name where value binding failed
        Field string `json:"field"`
        *HTTPError
        // Values of parameter that failed to bind.
        Values []string `json:"-"`
}

// NewBindingError creates new instance of binding error
func NewBindingError(sourceParam string, values []string, message interface{}, internalError error) error <span class="cov8" title="1">{
        return &amp;BindingError{
                Field:  sourceParam,
                Values: values,
                HTTPError: &amp;HTTPError{
                        Code:     http.StatusBadRequest,
                        Message:  message,
                        Internal: internalError,
                },
        }
}</span>

// Error returns error message
func (be *BindingError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s, field=%s", be.HTTPError.Error(), be.Field)
}</span>

// ValueBinder provides utility methods for binding query or path parameter to various Go built-in types
type ValueBinder struct {
        // ValueFunc is used to get single parameter (first) value from request
        ValueFunc func(sourceParam string) string
        // ValuesFunc is used to get all values for parameter from request. i.e. `/api/search?ids=1&amp;ids=2`
        ValuesFunc func(sourceParam string) []string
        // ErrorFunc is used to create errors. Allows you to use your own error type, that for example marshals to your specific json response
        ErrorFunc func(sourceParam string, values []string, message interface{}, internalError error) error
        errors    []error
        // failFast is flag for binding methods to return without attempting to bind when previous binding already failed
        failFast bool
}

// QueryParamsBinder creates query parameter value binder
func QueryParamsBinder(c Context) *ValueBinder <span class="cov8" title="1">{
        return &amp;ValueBinder{
                failFast:  true,
                ValueFunc: c.QueryParam,
                ValuesFunc: func(sourceParam string) []string </span><span class="cov8" title="1">{
                        values, ok := c.QueryParams()[sourceParam]
                        if !ok </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return values</span>
                },
                ErrorFunc: NewBindingError,
        }
}

// PathParamsBinder creates path parameter value binder
func PathParamsBinder(c Context) *ValueBinder <span class="cov8" title="1">{
        return &amp;ValueBinder{
                failFast:  true,
                ValueFunc: c.Param,
                ValuesFunc: func(sourceParam string) []string </span><span class="cov8" title="1">{
                        // path parameter should not have multiple values so getting values does not make sense but lets not error out here
                        value := c.Param(sourceParam)
                        if value == "" </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return []string{value}</span>
                },
                ErrorFunc: NewBindingError,
        }
}

// FormFieldBinder creates form field value binder
// For all requests, FormFieldBinder parses the raw query from the URL and uses query params as form fields
//
// For POST, PUT, and PATCH requests, it also reads the request body, parses it
// as a form and uses query params as form fields. Request body parameters take precedence over URL query
// string values in r.Form.
//
// NB: when binding forms take note that this implementation uses standard library form parsing
// which parses form data from BOTH URL and BODY if content type is not MIMEMultipartForm
// See https://golang.org/pkg/net/http/#Request.ParseForm
func FormFieldBinder(c Context) *ValueBinder <span class="cov8" title="1">{
        vb := &amp;ValueBinder{
                failFast: true,
                ValueFunc: func(sourceParam string) string </span><span class="cov8" title="1">{
                        return c.Request().FormValue(sourceParam)
                }</span>,
                ErrorFunc: NewBindingError,
        }
        <span class="cov8" title="1">vb.ValuesFunc = func(sourceParam string) []string </span><span class="cov8" title="1">{
                if c.Request().Form == nil </span><span class="cov8" title="1">{
                        // this is same as `Request().FormValue()` does internally
                        _ = c.Request().ParseMultipartForm(32 &lt;&lt; 20)
                }</span>
                <span class="cov8" title="1">values, ok := c.Request().Form[sourceParam]
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return values</span>
        }

        <span class="cov8" title="1">return vb</span>
}

// FailFast set internal flag to indicate if binding methods will return early (without binding) when previous bind failed
// NB: call this method before any other binding methods as it modifies binding methods behaviour
func (b *ValueBinder) FailFast(value bool) *ValueBinder <span class="cov8" title="1">{
        b.failFast = value
        return b
}</span>

func (b *ValueBinder) setError(err error) <span class="cov8" title="1">{
        if b.errors == nil </span><span class="cov8" title="1">{
                b.errors = []error{err}
                return
        }</span>
        <span class="cov8" title="1">b.errors = append(b.errors, err)</span>
}

// BindError returns first seen bind error and resets/empties binder errors for further calls
func (b *ValueBinder) BindError() error <span class="cov8" title="1">{
        if b.errors == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err := b.errors[0]
        b.errors = nil // reset errors so next chain will start from zero
        return err</span>
}

// BindErrors returns all bind errors and resets/empties binder errors for further calls
func (b *ValueBinder) BindErrors() []error <span class="cov8" title="1">{
        if b.errors == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">errors := b.errors
        b.errors = nil // reset errors so next chain will start from zero
        return errors</span>
}

// CustomFunc binds parameter values with Func. Func is called only when parameter values exist.
func (b *ValueBinder) CustomFunc(sourceParam string, customFunc func(values []string) []error) *ValueBinder <span class="cov8" title="1">{
        return b.customFunc(sourceParam, customFunc, false)
}</span>

// MustCustomFunc requires parameter values to exist to bind with Func. Returns error when value does not exist.
func (b *ValueBinder) MustCustomFunc(sourceParam string, customFunc func(values []string) []error) *ValueBinder <span class="cov8" title="1">{
        return b.customFunc(sourceParam, customFunc, true)
}</span>

func (b *ValueBinder) customFunc(sourceParam string, customFunc func(values []string) []error, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">if errs := customFunc(values); errs != nil </span><span class="cov8" title="1">{
                b.errors = append(b.errors, errs...)
        }</span>
        <span class="cov8" title="1">return b</span>
}

// String binds parameter to string variable
func (b *ValueBinder) String(sourceParam string, dest *string) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">*dest = value
        return b</span>
}

// MustString requires parameter value to exist to bind to string variable. Returns error when value does not exist
func (b *ValueBinder) MustString(sourceParam string, dest *string) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "required field value is empty", nil))
                return b
        }</span>
        <span class="cov8" title="1">*dest = value
        return b</span>
}

// Strings binds parameter values to slice of string
func (b *ValueBinder) Strings(sourceParam string, dest *[]string) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValuesFunc(sourceParam)
        if value == nil </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">*dest = value
        return b</span>
}

// MustStrings requires parameter values to exist to bind to slice of string variables. Returns error when value does not exist
func (b *ValueBinder) MustStrings(sourceParam string, dest *[]string) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValuesFunc(sourceParam)
        if value == nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                return b
        }</span>
        <span class="cov8" title="1">*dest = value
        return b</span>
}

// BindUnmarshaler binds parameter to destination implementing BindUnmarshaler interface
func (b *ValueBinder) BindUnmarshaler(sourceParam string, dest BindUnmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">tmp := b.ValueFunc(sourceParam)
        if tmp == "" </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalParam(tmp); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "failed to bind field value to BindUnmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// MustBindUnmarshaler requires parameter value to exist to bind to destination implementing BindUnmarshaler interface.
// Returns error when value does not exist
func (b *ValueBinder) MustBindUnmarshaler(sourceParam string, dest BindUnmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "required field value is empty", nil))
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalParam(value); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to BindUnmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// JSONUnmarshaler binds parameter to destination implementing json.Unmarshaler interface
func (b *ValueBinder) JSONUnmarshaler(sourceParam string, dest json.Unmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">tmp := b.ValueFunc(sourceParam)
        if tmp == "" </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalJSON([]byte(tmp)); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "failed to bind field value to json.Unmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// MustJSONUnmarshaler requires parameter value to exist to bind to destination implementing json.Unmarshaler interface.
// Returns error when value does not exist
func (b *ValueBinder) MustJSONUnmarshaler(sourceParam string, dest json.Unmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">tmp := b.ValueFunc(sourceParam)
        if tmp == "" </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "required field value is empty", nil))
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalJSON([]byte(tmp)); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "failed to bind field value to json.Unmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// TextUnmarshaler binds parameter to destination implementing encoding.TextUnmarshaler interface
func (b *ValueBinder) TextUnmarshaler(sourceParam string, dest encoding.TextUnmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">tmp := b.ValueFunc(sourceParam)
        if tmp == "" </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalText([]byte(tmp)); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "failed to bind field value to encoding.TextUnmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// MustTextUnmarshaler requires parameter value to exist to bind to destination implementing encoding.TextUnmarshaler interface.
// Returns error when value does not exist
func (b *ValueBinder) MustTextUnmarshaler(sourceParam string, dest encoding.TextUnmarshaler) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">tmp := b.ValueFunc(sourceParam)
        if tmp == "" </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "required field value is empty", nil))
                return b
        }</span>

        <span class="cov8" title="1">if err := dest.UnmarshalText([]byte(tmp)); err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{tmp}, "failed to bind field value to encoding.TextUnmarshaler interface", err))
        }</span>
        <span class="cov8" title="1">return b</span>
}

// BindWithDelimiter binds parameter to destination by suitable conversion function.
// Delimiter is used before conversion to split parameter value to separate values
func (b *ValueBinder) BindWithDelimiter(sourceParam string, dest interface{}, delimiter string) *ValueBinder <span class="cov8" title="1">{
        return b.bindWithDelimiter(sourceParam, dest, delimiter, false)
}</span>

// MustBindWithDelimiter requires parameter value to exist to bind destination by suitable conversion function.
// Delimiter is used before conversion to split parameter value to separate values
func (b *ValueBinder) MustBindWithDelimiter(sourceParam string, dest interface{}, delimiter string) *ValueBinder <span class="cov8" title="1">{
        return b.bindWithDelimiter(sourceParam, dest, delimiter, true)
}</span>

func (b *ValueBinder) bindWithDelimiter(sourceParam string, dest interface{}, delimiter string, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">tmpValues := make([]string, 0, len(values))
        for _, v := range values </span><span class="cov8" title="1">{
                tmpValues = append(tmpValues, strings.Split(v, delimiter)...)
        }</span>

        <span class="cov8" title="1">switch d := dest.(type) </span>{
        case *[]string:<span class="cov8" title="1">
                *d = tmpValues
                return b</span>
        case *[]bool:<span class="cov8" title="1">
                return b.bools(sourceParam, tmpValues, d)</span>
        case *[]int64, *[]int32, *[]int16, *[]int8, *[]int:<span class="cov8" title="1">
                return b.ints(sourceParam, tmpValues, d)</span>
        case *[]uint64, *[]uint32, *[]uint16, *[]uint8, *[]uint:<span class="cov8" title="1"> // *[]byte is same as *[]uint8
                return b.uints(sourceParam, tmpValues, d)</span>
        case *[]float64, *[]float32:<span class="cov8" title="1">
                return b.floats(sourceParam, tmpValues, d)</span>
        case *[]time.Duration:<span class="cov8" title="1">
                return b.durations(sourceParam, tmpValues, d)</span>
        default:<span class="cov8" title="1">
                // support only cases when destination is slice
                // does not support time.Time as it needs argument (layout) for parsing or BindUnmarshaler
                b.setError(b.ErrorFunc(sourceParam, []string{}, "unsupported bind type", nil))
                return b</span>
        }
}

// Int64 binds parameter to int64 variable
func (b *ValueBinder) Int64(sourceParam string, dest *int64) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 64, false)
}</span>

// MustInt64 requires parameter value to exist to bind to int64 variable. Returns error when value does not exist
func (b *ValueBinder) MustInt64(sourceParam string, dest *int64) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 64, true)
}</span>

// Int32 binds parameter to int32 variable
func (b *ValueBinder) Int32(sourceParam string, dest *int32) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 32, false)
}</span>

// MustInt32 requires parameter value to exist to bind to int32 variable. Returns error when value does not exist
func (b *ValueBinder) MustInt32(sourceParam string, dest *int32) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 32, true)
}</span>

// Int16 binds parameter to int16 variable
func (b *ValueBinder) Int16(sourceParam string, dest *int16) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 16, false)
}</span>

// MustInt16 requires parameter value to exist to bind to int16 variable. Returns error when value does not exist
func (b *ValueBinder) MustInt16(sourceParam string, dest *int16) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 16, true)
}</span>

// Int8 binds parameter to int8 variable
func (b *ValueBinder) Int8(sourceParam string, dest *int8) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 8, false)
}</span>

// MustInt8 requires parameter value to exist to bind to int8 variable. Returns error when value does not exist
func (b *ValueBinder) MustInt8(sourceParam string, dest *int8) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 8, true)
}</span>

// Int binds parameter to int variable
func (b *ValueBinder) Int(sourceParam string, dest *int) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 0, false)
}</span>

// MustInt requires parameter value to exist to bind to int variable. Returns error when value does not exist
func (b *ValueBinder) MustInt(sourceParam string, dest *int) *ValueBinder <span class="cov8" title="1">{
        return b.intValue(sourceParam, dest, 0, true)
}</span>

func (b *ValueBinder) intValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">return b.int(sourceParam, value, dest, bitSize)</span>
}

func (b *ValueBinder) int(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder <span class="cov8" title="1">{
        n, err := strconv.ParseInt(value, 10, bitSize)
        if err != nil </span><span class="cov8" title="1">{
                if bitSize == 0 </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to int", err))
                }</span> else<span class="cov8" title="1"> {
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf("failed to bind field value to int%v", bitSize), err))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">switch d := dest.(type) </span>{
        case *int64:<span class="cov8" title="1">
                *d = n</span>
        case *int32:<span class="cov8" title="1">
                *d = int32(n)</span>
        case *int16:<span class="cov8" title="1">
                *d = int16(n)</span>
        case *int8:<span class="cov8" title="1">
                *d = int8(n)</span>
        case *int:<span class="cov8" title="1">
                *d = int(n)</span>
        }
        <span class="cov8" title="1">return b</span>
}

func (b *ValueBinder) intsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, values, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.ints(sourceParam, values, dest)</span>
}

func (b *ValueBinder) ints(sourceParam string, values []string, dest interface{}) *ValueBinder <span class="cov8" title="1">{
        switch d := dest.(type) </span>{
        case *[]int64:<span class="cov8" title="1">
                tmp := make([]int64, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.int(sourceParam, v, &amp;tmp[i], 64)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]int32:<span class="cov8" title="1">
                tmp := make([]int32, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.int(sourceParam, v, &amp;tmp[i], 32)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]int16:<span class="cov8" title="1">
                tmp := make([]int16, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.int(sourceParam, v, &amp;tmp[i], 16)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]int8:<span class="cov8" title="1">
                tmp := make([]int8, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.int(sourceParam, v, &amp;tmp[i], 8)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]int:<span class="cov8" title="1">
                tmp := make([]int, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.int(sourceParam, v, &amp;tmp[i], 0)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

// Int64s binds parameter to slice of int64
func (b *ValueBinder) Int64s(sourceParam string, dest *[]int64) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, false)
}</span>

// MustInt64s requires parameter value to exist to bind to int64 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustInt64s(sourceParam string, dest *[]int64) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, true)
}</span>

// Int32s binds parameter to slice of int32
func (b *ValueBinder) Int32s(sourceParam string, dest *[]int32) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, false)
}</span>

// MustInt32s requires parameter value to exist to bind to int32 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustInt32s(sourceParam string, dest *[]int32) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, true)
}</span>

// Int16s binds parameter to slice of int16
func (b *ValueBinder) Int16s(sourceParam string, dest *[]int16) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, false)
}</span>

// MustInt16s requires parameter value to exist to bind to int16 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustInt16s(sourceParam string, dest *[]int16) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, true)
}</span>

// Int8s binds parameter to slice of int8
func (b *ValueBinder) Int8s(sourceParam string, dest *[]int8) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, false)
}</span>

// MustInt8s requires parameter value to exist to bind to int8 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustInt8s(sourceParam string, dest *[]int8) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, true)
}</span>

// Ints binds parameter to slice of int
func (b *ValueBinder) Ints(sourceParam string, dest *[]int) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, false)
}</span>

// MustInts requires parameter value to exist to bind to int slice variable. Returns error when value does not exist
func (b *ValueBinder) MustInts(sourceParam string, dest *[]int) *ValueBinder <span class="cov8" title="1">{
        return b.intsValue(sourceParam, dest, true)
}</span>

// Uint64 binds parameter to uint64 variable
func (b *ValueBinder) Uint64(sourceParam string, dest *uint64) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 64, false)
}</span>

// MustUint64 requires parameter value to exist to bind to uint64 variable. Returns error when value does not exist
func (b *ValueBinder) MustUint64(sourceParam string, dest *uint64) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 64, true)
}</span>

// Uint32 binds parameter to uint32 variable
func (b *ValueBinder) Uint32(sourceParam string, dest *uint32) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 32, false)
}</span>

// MustUint32 requires parameter value to exist to bind to uint32 variable. Returns error when value does not exist
func (b *ValueBinder) MustUint32(sourceParam string, dest *uint32) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 32, true)
}</span>

// Uint16 binds parameter to uint16 variable
func (b *ValueBinder) Uint16(sourceParam string, dest *uint16) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 16, false)
}</span>

// MustUint16 requires parameter value to exist to bind to uint16 variable. Returns error when value does not exist
func (b *ValueBinder) MustUint16(sourceParam string, dest *uint16) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 16, true)
}</span>

// Uint8 binds parameter to uint8 variable
func (b *ValueBinder) Uint8(sourceParam string, dest *uint8) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 8, false)
}</span>

// MustUint8 requires parameter value to exist to bind to uint8 variable. Returns error when value does not exist
func (b *ValueBinder) MustUint8(sourceParam string, dest *uint8) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 8, true)
}</span>

// Byte binds parameter to byte variable
func (b *ValueBinder) Byte(sourceParam string, dest *byte) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 8, false)
}</span>

// MustByte requires parameter value to exist to bind to byte variable. Returns error when value does not exist
func (b *ValueBinder) MustByte(sourceParam string, dest *byte) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 8, true)
}</span>

// Uint binds parameter to uint variable
func (b *ValueBinder) Uint(sourceParam string, dest *uint) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 0, false)
}</span>

// MustUint requires parameter value to exist to bind to uint variable. Returns error when value does not exist
func (b *ValueBinder) MustUint(sourceParam string, dest *uint) *ValueBinder <span class="cov8" title="1">{
        return b.uintValue(sourceParam, dest, 0, true)
}</span>

func (b *ValueBinder) uintValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">return b.uint(sourceParam, value, dest, bitSize)</span>
}

func (b *ValueBinder) uint(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder <span class="cov8" title="1">{
        n, err := strconv.ParseUint(value, 10, bitSize)
        if err != nil </span><span class="cov8" title="1">{
                if bitSize == 0 </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to uint", err))
                }</span> else<span class="cov8" title="1"> {
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf("failed to bind field value to uint%v", bitSize), err))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">switch d := dest.(type) </span>{
        case *uint64:<span class="cov8" title="1">
                *d = n</span>
        case *uint32:<span class="cov8" title="1">
                *d = uint32(n)</span>
        case *uint16:<span class="cov8" title="1">
                *d = uint16(n)</span>
        case *uint8:<span class="cov8" title="1"> // byte is alias to uint8
                *d = uint8(n)</span>
        case *uint:<span class="cov8" title="1">
                *d = uint(n)</span>
        }
        <span class="cov8" title="1">return b</span>
}

func (b *ValueBinder) uintsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, values, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.uints(sourceParam, values, dest)</span>
}

func (b *ValueBinder) uints(sourceParam string, values []string, dest interface{}) *ValueBinder <span class="cov8" title="1">{
        switch d := dest.(type) </span>{
        case *[]uint64:<span class="cov8" title="1">
                tmp := make([]uint64, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.uint(sourceParam, v, &amp;tmp[i], 64)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]uint32:<span class="cov8" title="1">
                tmp := make([]uint32, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.uint(sourceParam, v, &amp;tmp[i], 32)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]uint16:<span class="cov8" title="1">
                tmp := make([]uint16, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.uint(sourceParam, v, &amp;tmp[i], 16)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]uint8:<span class="cov8" title="1"> // byte is alias to uint8
                tmp := make([]uint8, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.uint(sourceParam, v, &amp;tmp[i], 8)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]uint:<span class="cov8" title="1">
                tmp := make([]uint, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.uint(sourceParam, v, &amp;tmp[i], 0)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

// Uint64s binds parameter to slice of uint64
func (b *ValueBinder) Uint64s(sourceParam string, dest *[]uint64) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, false)
}</span>

// MustUint64s requires parameter value to exist to bind to uint64 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustUint64s(sourceParam string, dest *[]uint64) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, true)
}</span>

// Uint32s binds parameter to slice of uint32
func (b *ValueBinder) Uint32s(sourceParam string, dest *[]uint32) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, false)
}</span>

// MustUint32s requires parameter value to exist to bind to uint32 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustUint32s(sourceParam string, dest *[]uint32) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, true)
}</span>

// Uint16s binds parameter to slice of uint16
func (b *ValueBinder) Uint16s(sourceParam string, dest *[]uint16) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, false)
}</span>

// MustUint16s requires parameter value to exist to bind to uint16 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustUint16s(sourceParam string, dest *[]uint16) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, true)
}</span>

// Uint8s binds parameter to slice of uint8
func (b *ValueBinder) Uint8s(sourceParam string, dest *[]uint8) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, false)
}</span>

// MustUint8s requires parameter value to exist to bind to uint8 slice variable. Returns error when value does not exist
func (b *ValueBinder) MustUint8s(sourceParam string, dest *[]uint8) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, true)
}</span>

// Uints binds parameter to slice of uint
func (b *ValueBinder) Uints(sourceParam string, dest *[]uint) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, false)
}</span>

// MustUints requires parameter value to exist to bind to uint slice variable. Returns error when value does not exist
func (b *ValueBinder) MustUints(sourceParam string, dest *[]uint) *ValueBinder <span class="cov8" title="1">{
        return b.uintsValue(sourceParam, dest, true)
}</span>

// Bool binds parameter to bool variable
func (b *ValueBinder) Bool(sourceParam string, dest *bool) *ValueBinder <span class="cov8" title="1">{
        return b.boolValue(sourceParam, dest, false)
}</span>

// MustBool requires parameter value to exist to bind to bool variable. Returns error when value does not exist
func (b *ValueBinder) MustBool(sourceParam string, dest *bool) *ValueBinder <span class="cov8" title="1">{
        return b.boolValue(sourceParam, dest, true)
}</span>

func (b *ValueBinder) boolValue(sourceParam string, dest *bool, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.bool(sourceParam, value, dest)</span>
}

func (b *ValueBinder) bool(sourceParam string, value string, dest *bool) *ValueBinder <span class="cov8" title="1">{
        n, err := strconv.ParseBool(value)
        if err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to bool", err))
                return b
        }</span>

        <span class="cov8" title="1">*dest = n
        return b</span>
}

func (b *ValueBinder) boolsValue(sourceParam string, dest *[]bool, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.bools(sourceParam, values, dest)</span>
}

func (b *ValueBinder) bools(sourceParam string, values []string, dest *[]bool) *ValueBinder <span class="cov8" title="1">{
        tmp := make([]bool, len(values))
        for i, v := range values </span><span class="cov8" title="1">{
                b.bool(sourceParam, v, &amp;tmp[i])
                if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                *dest = tmp
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Bools binds parameter values to slice of bool variables
func (b *ValueBinder) Bools(sourceParam string, dest *[]bool) *ValueBinder <span class="cov8" title="1">{
        return b.boolsValue(sourceParam, dest, false)
}</span>

// MustBools requires parameter values to exist to bind to slice of bool variables. Returns error when values does not exist
func (b *ValueBinder) MustBools(sourceParam string, dest *[]bool) *ValueBinder <span class="cov8" title="1">{
        return b.boolsValue(sourceParam, dest, true)
}</span>

// Float64 binds parameter to float64 variable
func (b *ValueBinder) Float64(sourceParam string, dest *float64) *ValueBinder <span class="cov8" title="1">{
        return b.floatValue(sourceParam, dest, 64, false)
}</span>

// MustFloat64 requires parameter value to exist to bind to float64 variable. Returns error when value does not exist
func (b *ValueBinder) MustFloat64(sourceParam string, dest *float64) *ValueBinder <span class="cov8" title="1">{
        return b.floatValue(sourceParam, dest, 64, true)
}</span>

// Float32 binds parameter to float32 variable
func (b *ValueBinder) Float32(sourceParam string, dest *float32) *ValueBinder <span class="cov8" title="1">{
        return b.floatValue(sourceParam, dest, 32, false)
}</span>

// MustFloat32 requires parameter value to exist to bind to float32 variable. Returns error when value does not exist
func (b *ValueBinder) MustFloat32(sourceParam string, dest *float32) *ValueBinder <span class="cov8" title="1">{
        return b.floatValue(sourceParam, dest, 32, true)
}</span>

func (b *ValueBinder) floatValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">return b.float(sourceParam, value, dest, bitSize)</span>
}

func (b *ValueBinder) float(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder <span class="cov8" title="1">{
        n, err := strconv.ParseFloat(value, bitSize)
        if err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf("failed to bind field value to float%v", bitSize), err))
                return b
        }</span>

        <span class="cov8" title="1">switch d := dest.(type) </span>{
        case *float64:<span class="cov8" title="1">
                *d = n</span>
        case *float32:<span class="cov8" title="1">
                *d = float32(n)</span>
        }
        <span class="cov8" title="1">return b</span>
}

func (b *ValueBinder) floatsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.floats(sourceParam, values, dest)</span>
}

func (b *ValueBinder) floats(sourceParam string, values []string, dest interface{}) *ValueBinder <span class="cov8" title="1">{
        switch d := dest.(type) </span>{
        case *[]float64:<span class="cov8" title="1">
                tmp := make([]float64, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.float(sourceParam, v, &amp;tmp[i], 64)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        case *[]float32:<span class="cov8" title="1">
                tmp := make([]float32, len(values))
                for i, v := range values </span><span class="cov8" title="1">{
                        b.float(sourceParam, v, &amp;tmp[i], 32)
                        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                                return b
                        }</span>
                }
                <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                        *d = tmp
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

// Float64s binds parameter values to slice of float64 variables
func (b *ValueBinder) Float64s(sourceParam string, dest *[]float64) *ValueBinder <span class="cov8" title="1">{
        return b.floatsValue(sourceParam, dest, false)
}</span>

// MustFloat64s requires parameter values to exist to bind to slice of float64 variables. Returns error when values does not exist
func (b *ValueBinder) MustFloat64s(sourceParam string, dest *[]float64) *ValueBinder <span class="cov8" title="1">{
        return b.floatsValue(sourceParam, dest, true)
}</span>

// Float32s binds parameter values to slice of float32 variables
func (b *ValueBinder) Float32s(sourceParam string, dest *[]float32) *ValueBinder <span class="cov8" title="1">{
        return b.floatsValue(sourceParam, dest, false)
}</span>

// MustFloat32s requires parameter values to exist to bind to slice of float32 variables. Returns error when values does not exist
func (b *ValueBinder) MustFloat32s(sourceParam string, dest *[]float32) *ValueBinder <span class="cov8" title="1">{
        return b.floatsValue(sourceParam, dest, true)
}</span>

// Time binds parameter to time.Time variable
func (b *ValueBinder) Time(sourceParam string, dest *time.Time, layout string) *ValueBinder <span class="cov8" title="1">{
        return b.time(sourceParam, dest, layout, false)
}</span>

// MustTime requires parameter value to exist to bind to time.Time variable. Returns error when value does not exist
func (b *ValueBinder) MustTime(sourceParam string, dest *time.Time, layout string) *ValueBinder <span class="cov8" title="1">{
        return b.time(sourceParam, dest, layout, true)
}</span>

func (b *ValueBinder) time(sourceParam string, dest *time.Time, layout string, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">t, err := time.Parse(layout, value)
        if err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to Time", err))
                return b
        }</span>
        <span class="cov8" title="1">*dest = t
        return b</span>
}

// Times binds parameter values to slice of time.Time variables
func (b *ValueBinder) Times(sourceParam string, dest *[]time.Time, layout string) *ValueBinder <span class="cov8" title="1">{
        return b.times(sourceParam, dest, layout, false)
}</span>

// MustTimes requires parameter values to exist to bind to slice of time.Time variables. Returns error when values does not exist
func (b *ValueBinder) MustTimes(sourceParam string, dest *[]time.Time, layout string) *ValueBinder <span class="cov8" title="1">{
        return b.times(sourceParam, dest, layout, true)
}</span>

func (b *ValueBinder) times(sourceParam string, dest *[]time.Time, layout string, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">tmp := make([]time.Time, len(values))
        for i, v := range values </span><span class="cov8" title="1">{
                t, err := time.Parse(layout, v)
                if err != nil </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{v}, "failed to bind field value to Time", err))
                        if b.failFast </span><span class="cov8" title="1">{
                                return b
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">tmp[i] = t</span>
        }
        <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                *dest = tmp
        }</span>
        <span class="cov8" title="1">return b</span>
}

// Duration binds parameter to time.Duration variable
func (b *ValueBinder) Duration(sourceParam string, dest *time.Duration) *ValueBinder <span class="cov8" title="1">{
        return b.duration(sourceParam, dest, false)
}</span>

// MustDuration requires parameter value to exist to bind to time.Duration variable. Returns error when value does not exist
func (b *ValueBinder) MustDuration(sourceParam string, dest *time.Duration) *ValueBinder <span class="cov8" title="1">{
        return b.duration(sourceParam, dest, true)
}</span>

func (b *ValueBinder) duration(sourceParam string, dest *time.Duration, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">t, err := time.ParseDuration(value)
        if err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to Duration", err))
                return b
        }</span>
        <span class="cov8" title="1">*dest = t
        return b</span>
}

// Durations binds parameter values to slice of time.Duration variables
func (b *ValueBinder) Durations(sourceParam string, dest *[]time.Duration) *ValueBinder <span class="cov8" title="1">{
        return b.durationsValue(sourceParam, dest, false)
}</span>

// MustDurations requires parameter values to exist to bind to slice of time.Duration variables. Returns error when values does not exist
func (b *ValueBinder) MustDurations(sourceParam string, dest *[]time.Duration) *ValueBinder <span class="cov8" title="1">{
        return b.durationsValue(sourceParam, dest, true)
}</span>

func (b *ValueBinder) durationsValue(sourceParam string, dest *[]time.Duration, valueMustExist bool) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">values := b.ValuesFunc(sourceParam)
        if len(values) == 0 </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">return b.durations(sourceParam, values, dest)</span>
}

func (b *ValueBinder) durations(sourceParam string, values []string, dest *[]time.Duration) *ValueBinder <span class="cov8" title="1">{
        tmp := make([]time.Duration, len(values))
        for i, v := range values </span><span class="cov8" title="1">{
                t, err := time.ParseDuration(v)
                if err != nil </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{v}, "failed to bind field value to Duration", err))
                        if b.failFast </span><span class="cov8" title="1">{
                                return b
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">tmp[i] = t</span>
        }
        <span class="cov8" title="1">if b.errors == nil </span><span class="cov8" title="1">{
                *dest = tmp
        }</span>
        <span class="cov8" title="1">return b</span>
}

// UnixTime binds parameter to time.Time variable (in local Time corresponding to the given Unix time).
//
// Example: 1609180603 bind to 2020-12-28T18:36:43.000000000+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
func (b *ValueBinder) UnixTime(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, false, time.Second)
}</span>

// MustUnixTime requires parameter value to exist to bind to time.Duration variable (in local time corresponding
// to the given Unix time). Returns error when value does not exist.
//
// Example: 1609180603 bind to 2020-12-28T18:36:43.000000000+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
func (b *ValueBinder) MustUnixTime(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, true, time.Second)
}</span>

// UnixTimeMilli binds parameter to time.Time variable (in local time corresponding to the given Unix time in millisecond precision).
//
// Example: 1647184410140 bind to 2022-03-13T15:13:30.140000000+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
func (b *ValueBinder) UnixTimeMilli(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, false, time.Millisecond)
}</span>

// MustUnixTimeMilli requires parameter value to exist to bind to time.Duration variable  (in local time corresponding
// to the given Unix time in millisecond precision). Returns error when value does not exist.
//
// Example: 1647184410140 bind to 2022-03-13T15:13:30.140000000+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
func (b *ValueBinder) MustUnixTimeMilli(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, true, time.Millisecond)
}</span>

// UnixTimeNano binds parameter to time.Time variable (in local time corresponding to the given Unix time in nanosecond precision).
//
// Example: 1609180603123456789 binds to 2020-12-28T18:36:43.123456789+00:00
// Example:          1000000000 binds to 1970-01-01T00:00:01.000000000+00:00
// Example:           999999999 binds to 1970-01-01T00:00:00.999999999+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
//   - Javascript's Number type only has about 53 bits of precision (Number.MAX_SAFE_INTEGER = 9007199254740991). Compare it to 1609180603123456789 in example.
func (b *ValueBinder) UnixTimeNano(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, false, time.Nanosecond)
}</span>

// MustUnixTimeNano requires parameter value to exist to bind to time.Duration variable  (in local Time corresponding
// to the given Unix time value in nano second precision). Returns error when value does not exist.
//
// Example: 1609180603123456789 binds to 2020-12-28T18:36:43.123456789+00:00
// Example:          1000000000 binds to 1970-01-01T00:00:01.000000000+00:00
// Example:           999999999 binds to 1970-01-01T00:00:00.999999999+00:00
//
// Note:
//   - time.Time{} (param is empty) and time.Unix(0,0) (param = "0") are not equal
//   - Javascript's Number type only has about 53 bits of precision (Number.MAX_SAFE_INTEGER = 9007199254740991). Compare it to 1609180603123456789 in example.
func (b *ValueBinder) MustUnixTimeNano(sourceParam string, dest *time.Time) *ValueBinder <span class="cov8" title="1">{
        return b.unixTime(sourceParam, dest, true, time.Nanosecond)
}</span>

func (b *ValueBinder) unixTime(sourceParam string, dest *time.Time, valueMustExist bool, precision time.Duration) *ValueBinder <span class="cov8" title="1">{
        if b.failFast &amp;&amp; b.errors != nil </span><span class="cov8" title="1">{
                return b
        }</span>

        <span class="cov8" title="1">value := b.ValueFunc(sourceParam)
        if value == "" </span><span class="cov8" title="1">{
                if valueMustExist </span><span class="cov8" title="1">{
                        b.setError(b.ErrorFunc(sourceParam, []string{value}, "required field value is empty", nil))
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">n, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                b.setError(b.ErrorFunc(sourceParam, []string{value}, "failed to bind field value to Time", err))
                return b
        }</span>

        <span class="cov8" title="1">switch precision </span>{
        case time.Second:<span class="cov8" title="1">
                *dest = time.Unix(n, 0)</span>
        case time.Millisecond:<span class="cov8" title="1">
                *dest = time.UnixMilli(n)</span>
        case time.Nanosecond:<span class="cov8" title="1">
                *dest = time.Unix(0, n)</span>
        }
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "bytes"
        "encoding/xml"
        "fmt"
        "io"
        "mime/multipart"
        "net"
        "net/http"
        "net/url"
        "strings"
        "sync"
)

// Context represents the context of the current HTTP request. It holds request and
// response objects, path, path parameters, data and registered handler.
type Context interface {
        // Request returns `*http.Request`.
        Request() *http.Request

        // SetRequest sets `*http.Request`.
        SetRequest(r *http.Request)

        // SetResponse sets `*Response`.
        SetResponse(r *Response)

        // Response returns `*Response`.
        Response() *Response

        // IsTLS returns true if HTTP connection is TLS otherwise false.
        IsTLS() bool

        // IsWebSocket returns true if HTTP connection is WebSocket otherwise false.
        IsWebSocket() bool

        // Scheme returns the HTTP protocol scheme, `http` or `https`.
        Scheme() string

        // RealIP returns the client's network address based on `X-Forwarded-For`
        // or `X-Real-IP` request header.
        // The behavior can be configured using `Echo#IPExtractor`.
        RealIP() string

        // Path returns the registered path for the handler.
        Path() string

        // SetPath sets the registered path for the handler.
        SetPath(p string)

        // Param returns path parameter by name.
        Param(name string) string

        // ParamNames returns path parameter names.
        ParamNames() []string

        // SetParamNames sets path parameter names.
        SetParamNames(names ...string)

        // ParamValues returns path parameter values.
        ParamValues() []string

        // SetParamValues sets path parameter values.
        SetParamValues(values ...string)

        // QueryParam returns the query param for the provided name.
        QueryParam(name string) string

        // QueryParams returns the query parameters as `url.Values`.
        QueryParams() url.Values

        // QueryString returns the URL query string.
        QueryString() string

        // FormValue returns the form field value for the provided name.
        FormValue(name string) string

        // FormParams returns the form parameters as `url.Values`.
        FormParams() (url.Values, error)

        // FormFile returns the multipart form file for the provided name.
        FormFile(name string) (*multipart.FileHeader, error)

        // MultipartForm returns the multipart form.
        MultipartForm() (*multipart.Form, error)

        // Cookie returns the named cookie provided in the request.
        Cookie(name string) (*http.Cookie, error)

        // SetCookie adds a `Set-Cookie` header in HTTP response.
        SetCookie(cookie *http.Cookie)

        // Cookies returns the HTTP cookies sent with the request.
        Cookies() []*http.Cookie

        // Get retrieves data from the context.
        Get(key string) interface{}

        // Set saves data in the context.
        Set(key string, val interface{})

        // Bind binds path params, query params and the request body into provided type `i`. The default binder
        // binds body based on Content-Type header.
        Bind(i interface{}) error

        // Validate validates provided `i`. It is usually called after `Context#Bind()`.
        // Validator must be registered using `Echo#Validator`.
        Validate(i interface{}) error

        // Render renders a template with data and sends a text/html response with status
        // code. Renderer must be registered using `Echo.Renderer`.
        Render(code int, name string, data interface{}) error

        // HTML sends an HTTP response with status code.
        HTML(code int, html string) error

        // HTMLBlob sends an HTTP blob response with status code.
        HTMLBlob(code int, b []byte) error

        // String sends a string response with status code.
        String(code int, s string) error

        // JSON sends a JSON response with status code.
        JSON(code int, i interface{}) error

        // JSONPretty sends a pretty-print JSON with status code.
        JSONPretty(code int, i interface{}, indent string) error

        // JSONBlob sends a JSON blob response with status code.
        JSONBlob(code int, b []byte) error

        // JSONP sends a JSONP response with status code. It uses `callback` to construct
        // the JSONP payload.
        JSONP(code int, callback string, i interface{}) error

        // JSONPBlob sends a JSONP blob response with status code. It uses `callback`
        // to construct the JSONP payload.
        JSONPBlob(code int, callback string, b []byte) error

        // XML sends an XML response with status code.
        XML(code int, i interface{}) error

        // XMLPretty sends a pretty-print XML with status code.
        XMLPretty(code int, i interface{}, indent string) error

        // XMLBlob sends an XML blob response with status code.
        XMLBlob(code int, b []byte) error

        // Blob sends a blob response with status code and content type.
        Blob(code int, contentType string, b []byte) error

        // Stream sends a streaming response with status code and content type.
        Stream(code int, contentType string, r io.Reader) error

        // File sends a response with the content of the file.
        File(file string) error

        // Attachment sends a response as attachment, prompting client to save the
        // file.
        Attachment(file string, name string) error

        // Inline sends a response as inline, opening the file in the browser.
        Inline(file string, name string) error

        // NoContent sends a response with no body and a status code.
        NoContent(code int) error

        // Redirect redirects the request to a provided URL with status code.
        Redirect(code int, url string) error

        // Error invokes the registered global HTTP error handler. Generally used by middleware.
        // A side-effect of calling global error handler is that now Response has been committed (sent to the client) and
        // middlewares up in chain can not change Response status code or Response body anymore.
        //
        // Avoid using this method in handlers as no middleware will be able to effectively handle errors after that.
        Error(err error)

        // Handler returns the matched handler by router.
        Handler() HandlerFunc

        // SetHandler sets the matched handler by router.
        SetHandler(h HandlerFunc)

        // Logger returns the `Logger` instance.
        Logger() Logger

        // SetLogger Set the logger
        SetLogger(l Logger)

        // Echo returns the `Echo` instance.
        Echo() *Echo

        // Reset resets the context after request completes. It must be called along
        // with `Echo#AcquireContext()` and `Echo#ReleaseContext()`.
        // See `Echo#ServeHTTP()`
        Reset(r *http.Request, w http.ResponseWriter)
}

type context struct {
        logger   Logger
        request  *http.Request
        response *Response
        query    url.Values
        echo     *Echo

        store Map
        lock  sync.RWMutex

        // following fields are set by Router
        handler HandlerFunc

        // path is route path that Router matched. It is empty string where there is no route match.
        // Route registered with RouteNotFound is considered as a match and path therefore is not empty.
        path string

        // Usually echo.Echo is sizing pvalues but there could be user created middlewares that decide to
        // overwrite parameter by calling SetParamNames + SetParamValues.
        // When echo.Echo allocated that slice it length/capacity is tied to echo.Echo.maxParam value.
        //
        // It is important that pvalues size is always equal or bigger to pnames length.
        pvalues []string

        // pnames length is tied to param count for the matched route
        pnames []string
}

const (
        // ContextKeyHeaderAllow is set by Router for getting value for `Allow` header in later stages of handler call chain.
        // Allow header is mandatory for status 405 (method not found) and useful for OPTIONS method requests.
        // It is added to context only when Router does not find matching method handler for request.
        ContextKeyHeaderAllow = "echo_header_allow"
)

const (
        defaultMemory = 32 &lt;&lt; 20 // 32 MB
        indexPage     = "index.html"
        defaultIndent = "  "
)

func (c *context) writeContentType(value string) <span class="cov8" title="1">{
        header := c.Response().Header()
        if header.Get(HeaderContentType) == "" </span><span class="cov8" title="1">{
                header.Set(HeaderContentType, value)
        }</span>
}

func (c *context) Request() *http.Request <span class="cov8" title="1">{
        return c.request
}</span>

func (c *context) SetRequest(r *http.Request) <span class="cov8" title="1">{
        c.request = r
}</span>

func (c *context) Response() *Response <span class="cov8" title="1">{
        return c.response
}</span>

func (c *context) SetResponse(r *Response) <span class="cov8" title="1">{
        c.response = r
}</span>

func (c *context) IsTLS() bool <span class="cov8" title="1">{
        return c.request.TLS != nil
}</span>

func (c *context) IsWebSocket() bool <span class="cov8" title="1">{
        upgrade := c.request.Header.Get(HeaderUpgrade)
        return strings.EqualFold(upgrade, "websocket")
}</span>

func (c *context) Scheme() string <span class="cov8" title="1">{
        // Can't use `r.Request.URL.Scheme`
        // See: https://groups.google.com/forum/#!topic/golang-nuts/pMUkBlQBDF0
        if c.IsTLS() </span><span class="cov8" title="1">{
                return "https"
        }</span>
        <span class="cov8" title="1">if scheme := c.request.Header.Get(HeaderXForwardedProto); scheme != "" </span><span class="cov8" title="1">{
                return scheme
        }</span>
        <span class="cov8" title="1">if scheme := c.request.Header.Get(HeaderXForwardedProtocol); scheme != "" </span><span class="cov8" title="1">{
                return scheme
        }</span>
        <span class="cov8" title="1">if ssl := c.request.Header.Get(HeaderXForwardedSsl); ssl == "on" </span><span class="cov8" title="1">{
                return "https"
        }</span>
        <span class="cov8" title="1">if scheme := c.request.Header.Get(HeaderXUrlScheme); scheme != "" </span><span class="cov8" title="1">{
                return scheme
        }</span>
        <span class="cov8" title="1">return "http"</span>
}

func (c *context) RealIP() string <span class="cov8" title="1">{
        if c.echo != nil &amp;&amp; c.echo.IPExtractor != nil </span><span class="cov0" title="0">{
                return c.echo.IPExtractor(c.request)
        }</span>
        // Fall back to legacy behavior
        <span class="cov8" title="1">if ip := c.request.Header.Get(HeaderXForwardedFor); ip != "" </span><span class="cov8" title="1">{
                i := strings.IndexAny(ip, ",")
                if i &gt; 0 </span><span class="cov8" title="1">{
                        xffip := strings.TrimSpace(ip[:i])
                        xffip = strings.TrimPrefix(xffip, "[")
                        xffip = strings.TrimSuffix(xffip, "]")
                        return xffip
                }</span>
                <span class="cov8" title="1">return ip</span>
        }
        <span class="cov8" title="1">if ip := c.request.Header.Get(HeaderXRealIP); ip != "" </span><span class="cov8" title="1">{
                ip = strings.TrimPrefix(ip, "[")
                ip = strings.TrimSuffix(ip, "]")
                return ip
        }</span>
        <span class="cov8" title="1">ra, _, _ := net.SplitHostPort(c.request.RemoteAddr)
        return ra</span>
}

func (c *context) Path() string <span class="cov8" title="1">{
        return c.path
}</span>

func (c *context) SetPath(p string) <span class="cov8" title="1">{
        c.path = p
}</span>

func (c *context) Param(name string) string <span class="cov8" title="1">{
        for i, n := range c.pnames </span><span class="cov8" title="1">{
                if i &lt; len(c.pvalues) </span><span class="cov8" title="1">{
                        if n == name </span><span class="cov8" title="1">{
                                return c.pvalues[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func (c *context) ParamNames() []string <span class="cov8" title="1">{
        return c.pnames
}</span>

func (c *context) SetParamNames(names ...string) <span class="cov8" title="1">{
        c.pnames = names

        l := len(names)
        if len(c.pvalues) &lt; l </span><span class="cov8" title="1">{
                // Keeping the old pvalues just for backward compatibility, but it sounds that doesn't make sense to keep them,
                // probably those values will be overridden in a Context#SetParamValues
                newPvalues := make([]string, l)
                copy(newPvalues, c.pvalues)
                c.pvalues = newPvalues
        }</span>
}

func (c *context) ParamValues() []string <span class="cov8" title="1">{
        return c.pvalues[:len(c.pnames)]
}</span>

func (c *context) SetParamValues(values ...string) <span class="cov8" title="1">{
        // NOTE: Don't just set c.pvalues = values, because it has to have length c.echo.maxParam (or bigger) at all times
        // It will brake the Router#Find code
        limit := len(values)
        if limit &gt; len(c.pvalues) </span><span class="cov8" title="1">{
                c.pvalues = make([]string, limit)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                c.pvalues[i] = values[i]
        }</span>
}

func (c *context) QueryParam(name string) string <span class="cov8" title="1">{
        if c.query == nil </span><span class="cov8" title="1">{
                c.query = c.request.URL.Query()
        }</span>
        <span class="cov8" title="1">return c.query.Get(name)</span>
}

func (c *context) QueryParams() url.Values <span class="cov8" title="1">{
        if c.query == nil </span><span class="cov8" title="1">{
                c.query = c.request.URL.Query()
        }</span>
        <span class="cov8" title="1">return c.query</span>
}

func (c *context) QueryString() string <span class="cov8" title="1">{
        return c.request.URL.RawQuery
}</span>

func (c *context) FormValue(name string) string <span class="cov8" title="1">{
        return c.request.FormValue(name)
}</span>

func (c *context) FormParams() (url.Values, error) <span class="cov8" title="1">{
        if strings.HasPrefix(c.request.Header.Get(HeaderContentType), MIMEMultipartForm) </span><span class="cov8" title="1">{
                if err := c.request.ParseMultipartForm(defaultMemory); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := c.request.ParseForm(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return c.request.Form, nil</span>
}

func (c *context) FormFile(name string) (*multipart.FileHeader, error) <span class="cov8" title="1">{
        f, fh, err := c.request.FormFile(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">f.Close()
        return fh, nil</span>
}

func (c *context) MultipartForm() (*multipart.Form, error) <span class="cov8" title="1">{
        err := c.request.ParseMultipartForm(defaultMemory)
        return c.request.MultipartForm, err
}</span>

func (c *context) Cookie(name string) (*http.Cookie, error) <span class="cov8" title="1">{
        return c.request.Cookie(name)
}</span>

func (c *context) SetCookie(cookie *http.Cookie) <span class="cov8" title="1">{
        http.SetCookie(c.Response(), cookie)
}</span>

func (c *context) Cookies() []*http.Cookie <span class="cov8" title="1">{
        return c.request.Cookies()
}</span>

func (c *context) Get(key string) interface{} <span class="cov8" title="1">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        return c.store[key]
}</span>

func (c *context) Set(key string, val interface{}) <span class="cov8" title="1">{
        c.lock.Lock()
        defer c.lock.Unlock()

        if c.store == nil </span><span class="cov8" title="1">{
                c.store = make(Map)
        }</span>
        <span class="cov8" title="1">c.store[key] = val</span>
}

func (c *context) Bind(i interface{}) error <span class="cov8" title="1">{
        return c.echo.Binder.Bind(i, c)
}</span>

func (c *context) Validate(i interface{}) error <span class="cov8" title="1">{
        if c.echo.Validator == nil </span><span class="cov8" title="1">{
                return ErrValidatorNotRegistered
        }</span>
        <span class="cov8" title="1">return c.echo.Validator.Validate(i)</span>
}

func (c *context) Render(code int, name string, data interface{}) (err error) <span class="cov8" title="1">{
        if c.echo.Renderer == nil </span><span class="cov8" title="1">{
                return ErrRendererNotRegistered
        }</span>
        <span class="cov8" title="1">buf := new(bytes.Buffer)
        if err = c.echo.Renderer.Render(buf, name, data, c); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return c.HTMLBlob(code, buf.Bytes())</span>
}

func (c *context) HTML(code int, html string) (err error) <span class="cov8" title="1">{
        return c.HTMLBlob(code, []byte(html))
}</span>

func (c *context) HTMLBlob(code int, b []byte) (err error) <span class="cov8" title="1">{
        return c.Blob(code, MIMETextHTMLCharsetUTF8, b)
}</span>

func (c *context) String(code int, s string) (err error) <span class="cov8" title="1">{
        return c.Blob(code, MIMETextPlainCharsetUTF8, []byte(s))
}</span>

func (c *context) jsonPBlob(code int, callback string, i interface{}) (err error) <span class="cov8" title="1">{
        indent := ""
        if _, pretty := c.QueryParams()["pretty"]; c.echo.Debug || pretty </span><span class="cov0" title="0">{
                indent = defaultIndent
        }</span>
        <span class="cov8" title="1">c.writeContentType(MIMEApplicationJavaScriptCharsetUTF8)
        c.response.WriteHeader(code)
        if _, err = c.response.Write([]byte(callback + "(")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = c.echo.JSONSerializer.Serialize(c, i, indent); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = c.response.Write([]byte(");")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (c *context) json(code int, i interface{}, indent string) error <span class="cov8" title="1">{
        c.writeContentType(MIMEApplicationJSON)
        c.response.Status = code
        return c.echo.JSONSerializer.Serialize(c, i, indent)
}</span>

func (c *context) JSON(code int, i interface{}) (err error) <span class="cov8" title="1">{
        indent := ""
        if _, pretty := c.QueryParams()["pretty"]; c.echo.Debug || pretty </span><span class="cov8" title="1">{
                indent = defaultIndent
        }</span>
        <span class="cov8" title="1">return c.json(code, i, indent)</span>
}

func (c *context) JSONPretty(code int, i interface{}, indent string) (err error) <span class="cov8" title="1">{
        return c.json(code, i, indent)
}</span>

func (c *context) JSONBlob(code int, b []byte) (err error) <span class="cov8" title="1">{
        return c.Blob(code, MIMEApplicationJSON, b)
}</span>

func (c *context) JSONP(code int, callback string, i interface{}) (err error) <span class="cov8" title="1">{
        return c.jsonPBlob(code, callback, i)
}</span>

func (c *context) JSONPBlob(code int, callback string, b []byte) (err error) <span class="cov8" title="1">{
        c.writeContentType(MIMEApplicationJavaScriptCharsetUTF8)
        c.response.WriteHeader(code)
        if _, err = c.response.Write([]byte(callback + "(")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = c.response.Write(b); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = c.response.Write([]byte(");"))
        return</span>
}

func (c *context) xml(code int, i interface{}, indent string) (err error) <span class="cov8" title="1">{
        c.writeContentType(MIMEApplicationXMLCharsetUTF8)
        c.response.WriteHeader(code)
        enc := xml.NewEncoder(c.response)
        if indent != "" </span><span class="cov8" title="1">{
                enc.Indent("", indent)
        }</span>
        <span class="cov8" title="1">if _, err = c.response.Write([]byte(xml.Header)); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return enc.Encode(i)</span>
}

func (c *context) XML(code int, i interface{}) (err error) <span class="cov8" title="1">{
        indent := ""
        if _, pretty := c.QueryParams()["pretty"]; c.echo.Debug || pretty </span><span class="cov8" title="1">{
                indent = defaultIndent
        }</span>
        <span class="cov8" title="1">return c.xml(code, i, indent)</span>
}

func (c *context) XMLPretty(code int, i interface{}, indent string) (err error) <span class="cov8" title="1">{
        return c.xml(code, i, indent)
}</span>

func (c *context) XMLBlob(code int, b []byte) (err error) <span class="cov8" title="1">{
        c.writeContentType(MIMEApplicationXMLCharsetUTF8)
        c.response.WriteHeader(code)
        if _, err = c.response.Write([]byte(xml.Header)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, err = c.response.Write(b)
        return</span>
}

func (c *context) Blob(code int, contentType string, b []byte) (err error) <span class="cov8" title="1">{
        c.writeContentType(contentType)
        c.response.WriteHeader(code)
        _, err = c.response.Write(b)
        return
}</span>

func (c *context) Stream(code int, contentType string, r io.Reader) (err error) <span class="cov8" title="1">{
        c.writeContentType(contentType)
        c.response.WriteHeader(code)
        _, err = io.Copy(c.response, r)
        return
}</span>

func (c *context) Attachment(file, name string) error <span class="cov8" title="1">{
        return c.contentDisposition(file, name, "attachment")
}</span>

func (c *context) Inline(file, name string) error <span class="cov8" title="1">{
        return c.contentDisposition(file, name, "inline")
}</span>

var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")

func (c *context) contentDisposition(file, name, dispositionType string) error <span class="cov8" title="1">{
        c.response.Header().Set(HeaderContentDisposition, fmt.Sprintf(`%s; filename="%s"`, dispositionType, quoteEscaper.Replace(name)))
        return c.File(file)
}</span>

func (c *context) NoContent(code int) error <span class="cov8" title="1">{
        c.response.WriteHeader(code)
        return nil
}</span>

func (c *context) Redirect(code int, url string) error <span class="cov8" title="1">{
        if code &lt; 300 || code &gt; 308 </span><span class="cov8" title="1">{
                return ErrInvalidRedirectCode
        }</span>
        <span class="cov8" title="1">c.response.Header().Set(HeaderLocation, url)
        c.response.WriteHeader(code)
        return nil</span>
}

func (c *context) Error(err error) <span class="cov8" title="1">{
        c.echo.HTTPErrorHandler(err, c)
}</span>

func (c *context) Echo() *Echo <span class="cov8" title="1">{
        return c.echo
}</span>

func (c *context) Handler() HandlerFunc <span class="cov8" title="1">{
        return c.handler
}</span>

func (c *context) SetHandler(h HandlerFunc) <span class="cov8" title="1">{
        c.handler = h
}</span>

func (c *context) Logger() Logger <span class="cov8" title="1">{
        res := c.logger
        if res != nil </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return c.echo.Logger</span>
}

func (c *context) SetLogger(l Logger) <span class="cov8" title="1">{
        c.logger = l
}</span>

func (c *context) Reset(r *http.Request, w http.ResponseWriter) <span class="cov8" title="1">{
        c.request = r
        c.response.reset(w)
        c.query = nil
        c.handler = NotFoundHandler
        c.store = nil
        c.path = ""
        c.pnames = nil
        c.logger = nil
        // NOTE: Don't reset because it has to have length c.echo.maxParam (or bigger) at all times
        for i := 0; i &lt; len(c.pvalues); i++ </span><span class="cov8" title="1">{
                c.pvalues[i] = ""
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "errors"
        "io"
        "io/fs"
        "net/http"
        "path/filepath"
)

func (c *context) File(file string) error <span class="cov8" title="1">{
        return fsFile(c, file, c.echo.Filesystem)
}</span>

// FileFS serves file from given file system.
//
// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, "rootDirectory") to create sub fs which uses necessary
// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths
// including `assets/images` as their prefix.
func (c *context) FileFS(file string, filesystem fs.FS) error <span class="cov8" title="1">{
        return fsFile(c, file, filesystem)
}</span>

func fsFile(c Context, file string, filesystem fs.FS) error <span class="cov8" title="1">{
        f, err := filesystem.Open(file)
        if err != nil </span><span class="cov8" title="1">{
                return ErrNotFound
        }</span>
        <span class="cov8" title="1">defer f.Close()

        fi, _ := f.Stat()
        if fi.IsDir() </span><span class="cov8" title="1">{
                file = filepath.ToSlash(filepath.Join(file, indexPage)) // ToSlash is necessary for Windows. fs.Open and os.Open are different in that aspect.
                f, err = filesystem.Open(file)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrNotFound
                }</span>
                <span class="cov8" title="1">defer f.Close()
                if fi, err = f.Stat(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">ff, ok := f.(io.ReadSeeker)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("file does not implement io.ReadSeeker")
        }</span>
        <span class="cov8" title="1">http.ServeContent(c.Response(), c.Request(), fi.Name(), fi.ModTime(), ff)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

/*
Package echo implements high performance, minimalist Go web framework.

Example:

        package main

        import (
          "net/http"

          "github.com/labstack/echo/v4"
          "github.com/labstack/echo/v4/middleware"
        )

        // Handler
        func hello(c echo.Context) error {
          return c.String(http.StatusOK, "Hello, World!")
        }

        func main() {
          // Echo instance
          e := echo.New()

          // Middleware
          e.Use(middleware.Logger())
          e.Use(middleware.Recover())

          // Routes
          e.GET("/", hello)

          // Start server
          e.Logger.Fatal(e.Start(":1323"))
        }

Learn more at https://echo.labstack.com
*/
package echo

import (
        stdContext "context"
        "crypto/tls"
        "encoding/json"
        "errors"
        "fmt"
        stdLog "log"
        "net"
        "net/http"
        "os"
        "reflect"
        "runtime"
        "sync"
        "time"

        "github.com/labstack/gommon/color"
        "github.com/labstack/gommon/log"
        "golang.org/x/crypto/acme"
        "golang.org/x/crypto/acme/autocert"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"
)

// Echo is the top-level framework instance.
//
// Goroutine safety: Do not mutate Echo instance fields after server has started. Accessing these
// fields from handlers/middlewares and changing field values at the same time leads to data-races.
// Adding new routes after the server has been started is also not safe!
type Echo struct {
        filesystem
        common
        // startupMutex is mutex to lock Echo instance access during server configuration and startup. Useful for to get
        // listener address info (on which interface/port was listener bound) without having data races.
        startupMutex sync.RWMutex
        colorer      *color.Color

        // premiddleware are middlewares that are run before routing is done. In case a pre-middleware returns
        // an error the router is not executed and the request will end up in the global error handler.
        premiddleware []MiddlewareFunc
        middleware    []MiddlewareFunc
        maxParam      *int
        router        *Router
        routers       map[string]*Router
        pool          sync.Pool

        StdLogger        *stdLog.Logger
        Server           *http.Server
        TLSServer        *http.Server
        Listener         net.Listener
        TLSListener      net.Listener
        AutoTLSManager   autocert.Manager
        HTTPErrorHandler HTTPErrorHandler
        Binder           Binder
        JSONSerializer   JSONSerializer
        Validator        Validator
        Renderer         Renderer
        Logger           Logger
        IPExtractor      IPExtractor
        ListenerNetwork  string

        // OnAddRouteHandler is called when Echo adds new route to specific host router.
        OnAddRouteHandler func(host string, route Route, handler HandlerFunc, middleware []MiddlewareFunc)
        DisableHTTP2      bool
        Debug             bool
        HideBanner        bool
        HidePort          bool
}

// Route contains a handler and information for matching against requests.
type Route struct {
        Method string `json:"method"`
        Path   string `json:"path"`
        Name   string `json:"name"`
}

// HTTPError represents an error that occurred while handling a request.
type HTTPError struct {
        Internal error       `json:"-"` // Stores the error returned by an external dependency
        Message  interface{} `json:"message"`
        Code     int         `json:"-"`
}

// MiddlewareFunc defines a function to process middleware.
type MiddlewareFunc func(next HandlerFunc) HandlerFunc

// HandlerFunc defines a function to serve HTTP requests.
type HandlerFunc func(c Context) error

// HTTPErrorHandler is a centralized HTTP error handler.
type HTTPErrorHandler func(err error, c Context)

// Validator is the interface that wraps the Validate function.
type Validator interface {
        Validate(i interface{}) error
}

// JSONSerializer is the interface that encodes and decodes JSON to and from interfaces.
type JSONSerializer interface {
        Serialize(c Context, i interface{}, indent string) error
        Deserialize(c Context, i interface{}) error
}

// Map defines a generic map of type `map[string]interface{}`.
type Map map[string]interface{}

// Common struct for Echo &amp; Group.
type common struct{}

// HTTP methods
// NOTE: Deprecated, please use the stdlib constants directly instead.
const (
        CONNECT = http.MethodConnect
        DELETE  = http.MethodDelete
        GET     = http.MethodGet
        HEAD    = http.MethodHead
        OPTIONS = http.MethodOptions
        PATCH   = http.MethodPatch
        POST    = http.MethodPost
        // PROPFIND = "PROPFIND"
        PUT   = http.MethodPut
        TRACE = http.MethodTrace
)

// MIME types
const (
        // MIMEApplicationJSON JavaScript Object Notation (JSON) https://www.rfc-editor.org/rfc/rfc8259
        MIMEApplicationJSON = "application/json"
        // Deprecated: Please use MIMEApplicationJSON instead. JSON should be encoded using UTF-8 by default.
        // No "charset" parameter is defined for this registration.
        // Adding one really has no effect on compliant recipients.
        // See RFC 8259, section 8.1. https://datatracker.ietf.org/doc/html/rfc8259#section-8.1
        MIMEApplicationJSONCharsetUTF8       = MIMEApplicationJSON + "; " + charsetUTF8
        MIMEApplicationJavaScript            = "application/javascript"
        MIMEApplicationJavaScriptCharsetUTF8 = MIMEApplicationJavaScript + "; " + charsetUTF8
        MIMEApplicationXML                   = "application/xml"
        MIMEApplicationXMLCharsetUTF8        = MIMEApplicationXML + "; " + charsetUTF8
        MIMETextXML                          = "text/xml"
        MIMETextXMLCharsetUTF8               = MIMETextXML + "; " + charsetUTF8
        MIMEApplicationForm                  = "application/x-www-form-urlencoded"
        MIMEApplicationProtobuf              = "application/protobuf"
        MIMEApplicationMsgpack               = "application/msgpack"
        MIMETextHTML                         = "text/html"
        MIMETextHTMLCharsetUTF8              = MIMETextHTML + "; " + charsetUTF8
        MIMETextPlain                        = "text/plain"
        MIMETextPlainCharsetUTF8             = MIMETextPlain + "; " + charsetUTF8
        MIMEMultipartForm                    = "multipart/form-data"
        MIMEOctetStream                      = "application/octet-stream"
)

const (
        charsetUTF8 = "charset=UTF-8"
        // PROPFIND Method can be used on collection and property resources.
        PROPFIND = "PROPFIND"
        // REPORT Method can be used to get information about a resource, see rfc 3253
        REPORT = "REPORT"
        // RouteNotFound is special method type for routes handling "route not found" (404) cases
        RouteNotFound = "echo_route_not_found"
)

// Headers
const (
        HeaderAccept         = "Accept"
        HeaderAcceptEncoding = "Accept-Encoding"
        // HeaderAllow is the name of the "Allow" header field used to list the set of methods
        // advertised as supported by the target resource. Returning an Allow header is mandatory
        // for status 405 (method not found) and useful for the OPTIONS method in responses.
        // See RFC 7231: https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1
        HeaderAllow               = "Allow"
        HeaderAuthorization       = "Authorization"
        HeaderContentDisposition  = "Content-Disposition"
        HeaderContentEncoding     = "Content-Encoding"
        HeaderContentLength       = "Content-Length"
        HeaderContentType         = "Content-Type"
        HeaderCookie              = "Cookie"
        HeaderSetCookie           = "Set-Cookie"
        HeaderIfModifiedSince     = "If-Modified-Since"
        HeaderLastModified        = "Last-Modified"
        HeaderLocation            = "Location"
        HeaderRetryAfter          = "Retry-After"
        HeaderUpgrade             = "Upgrade"
        HeaderVary                = "Vary"
        HeaderWWWAuthenticate     = "WWW-Authenticate"
        HeaderXForwardedFor       = "X-Forwarded-For"
        HeaderXForwardedProto     = "X-Forwarded-Proto"
        HeaderXForwardedProtocol  = "X-Forwarded-Protocol"
        HeaderXForwardedSsl       = "X-Forwarded-Ssl"
        HeaderXUrlScheme          = "X-Url-Scheme"
        HeaderXHTTPMethodOverride = "X-HTTP-Method-Override"
        HeaderXRealIP             = "X-Real-Ip"
        HeaderXRequestID          = "X-Request-Id"
        HeaderXCorrelationID      = "X-Correlation-Id"
        HeaderXRequestedWith      = "X-Requested-With"
        HeaderServer              = "Server"
        HeaderOrigin              = "Origin"
        HeaderCacheControl        = "Cache-Control"
        HeaderConnection          = "Connection"

        // Access control
        HeaderAccessControlRequestMethod    = "Access-Control-Request-Method"
        HeaderAccessControlRequestHeaders   = "Access-Control-Request-Headers"
        HeaderAccessControlAllowOrigin      = "Access-Control-Allow-Origin"
        HeaderAccessControlAllowMethods     = "Access-Control-Allow-Methods"
        HeaderAccessControlAllowHeaders     = "Access-Control-Allow-Headers"
        HeaderAccessControlAllowCredentials = "Access-Control-Allow-Credentials"
        HeaderAccessControlExposeHeaders    = "Access-Control-Expose-Headers"
        HeaderAccessControlMaxAge           = "Access-Control-Max-Age"

        // Security
        HeaderStrictTransportSecurity         = "Strict-Transport-Security"
        HeaderXContentTypeOptions             = "X-Content-Type-Options"
        HeaderXXSSProtection                  = "X-XSS-Protection"
        HeaderXFrameOptions                   = "X-Frame-Options"
        HeaderContentSecurityPolicy           = "Content-Security-Policy"
        HeaderContentSecurityPolicyReportOnly = "Content-Security-Policy-Report-Only"
        HeaderXCSRFToken                      = "X-CSRF-Token"
        HeaderReferrerPolicy                  = "Referrer-Policy"
)

const (
        // Version of Echo
        Version = "4.13.3"
        website = "https://echo.labstack.com"
        // http://patorjk.com/software/taag/#p=display&amp;f=Small%20Slant&amp;t=Echo
        banner = `
   ____    __
  / __/___/ /  ___
 / _// __/ _ \/ _ \
/___/\__/_//_/\___/ %s
High performance, minimalist Go web framework
%s
____________________________________O/_______
                                    O\
`
)

var methods = [...]string{
        http.MethodConnect,
        http.MethodDelete,
        http.MethodGet,
        http.MethodHead,
        http.MethodOptions,
        http.MethodPatch,
        http.MethodPost,
        PROPFIND,
        http.MethodPut,
        http.MethodTrace,
        REPORT,
}

// Errors
var (
        ErrBadRequest                    = NewHTTPError(http.StatusBadRequest)                    // HTTP 400 Bad Request
        ErrUnauthorized                  = NewHTTPError(http.StatusUnauthorized)                  // HTTP 401 Unauthorized
        ErrPaymentRequired               = NewHTTPError(http.StatusPaymentRequired)               // HTTP 402 Payment Required
        ErrForbidden                     = NewHTTPError(http.StatusForbidden)                     // HTTP 403 Forbidden
        ErrNotFound                      = NewHTTPError(http.StatusNotFound)                      // HTTP 404 Not Found
        ErrMethodNotAllowed              = NewHTTPError(http.StatusMethodNotAllowed)              // HTTP 405 Method Not Allowed
        ErrNotAcceptable                 = NewHTTPError(http.StatusNotAcceptable)                 // HTTP 406 Not Acceptable
        ErrProxyAuthRequired             = NewHTTPError(http.StatusProxyAuthRequired)             // HTTP 407 Proxy AuthRequired
        ErrRequestTimeout                = NewHTTPError(http.StatusRequestTimeout)                // HTTP 408 Request Timeout
        ErrConflict                      = NewHTTPError(http.StatusConflict)                      // HTTP 409 Conflict
        ErrGone                          = NewHTTPError(http.StatusGone)                          // HTTP 410 Gone
        ErrLengthRequired                = NewHTTPError(http.StatusLengthRequired)                // HTTP 411 Length Required
        ErrPreconditionFailed            = NewHTTPError(http.StatusPreconditionFailed)            // HTTP 412 Precondition Failed
        ErrStatusRequestEntityTooLarge   = NewHTTPError(http.StatusRequestEntityTooLarge)         // HTTP 413 Payload Too Large
        ErrRequestURITooLong             = NewHTTPError(http.StatusRequestURITooLong)             // HTTP 414 URI Too Long
        ErrUnsupportedMediaType          = NewHTTPError(http.StatusUnsupportedMediaType)          // HTTP 415 Unsupported Media Type
        ErrRequestedRangeNotSatisfiable  = NewHTTPError(http.StatusRequestedRangeNotSatisfiable)  // HTTP 416 Range Not Satisfiable
        ErrExpectationFailed             = NewHTTPError(http.StatusExpectationFailed)             // HTTP 417 Expectation Failed
        ErrTeapot                        = NewHTTPError(http.StatusTeapot)                        // HTTP 418 I'm a teapot
        ErrMisdirectedRequest            = NewHTTPError(http.StatusMisdirectedRequest)            // HTTP 421 Misdirected Request
        ErrUnprocessableEntity           = NewHTTPError(http.StatusUnprocessableEntity)           // HTTP 422 Unprocessable Entity
        ErrLocked                        = NewHTTPError(http.StatusLocked)                        // HTTP 423 Locked
        ErrFailedDependency              = NewHTTPError(http.StatusFailedDependency)              // HTTP 424 Failed Dependency
        ErrTooEarly                      = NewHTTPError(http.StatusTooEarly)                      // HTTP 425 Too Early
        ErrUpgradeRequired               = NewHTTPError(http.StatusUpgradeRequired)               // HTTP 426 Upgrade Required
        ErrPreconditionRequired          = NewHTTPError(http.StatusPreconditionRequired)          // HTTP 428 Precondition Required
        ErrTooManyRequests               = NewHTTPError(http.StatusTooManyRequests)               // HTTP 429 Too Many Requests
        ErrRequestHeaderFieldsTooLarge   = NewHTTPError(http.StatusRequestHeaderFieldsTooLarge)   // HTTP 431 Request Header Fields Too Large
        ErrUnavailableForLegalReasons    = NewHTTPError(http.StatusUnavailableForLegalReasons)    // HTTP 451 Unavailable For Legal Reasons
        ErrInternalServerError           = NewHTTPError(http.StatusInternalServerError)           // HTTP 500 Internal Server Error
        ErrNotImplemented                = NewHTTPError(http.StatusNotImplemented)                // HTTP 501 Not Implemented
        ErrBadGateway                    = NewHTTPError(http.StatusBadGateway)                    // HTTP 502 Bad Gateway
        ErrServiceUnavailable            = NewHTTPError(http.StatusServiceUnavailable)            // HTTP 503 Service Unavailable
        ErrGatewayTimeout                = NewHTTPError(http.StatusGatewayTimeout)                // HTTP 504 Gateway Timeout
        ErrHTTPVersionNotSupported       = NewHTTPError(http.StatusHTTPVersionNotSupported)       // HTTP 505 HTTP Version Not Supported
        ErrVariantAlsoNegotiates         = NewHTTPError(http.StatusVariantAlsoNegotiates)         // HTTP 506 Variant Also Negotiates
        ErrInsufficientStorage           = NewHTTPError(http.StatusInsufficientStorage)           // HTTP 507 Insufficient Storage
        ErrLoopDetected                  = NewHTTPError(http.StatusLoopDetected)                  // HTTP 508 Loop Detected
        ErrNotExtended                   = NewHTTPError(http.StatusNotExtended)                   // HTTP 510 Not Extended
        ErrNetworkAuthenticationRequired = NewHTTPError(http.StatusNetworkAuthenticationRequired) // HTTP 511 Network Authentication Required

        ErrValidatorNotRegistered = errors.New("validator not registered")
        ErrRendererNotRegistered  = errors.New("renderer not registered")
        ErrInvalidRedirectCode    = errors.New("invalid redirect status code")
        ErrCookieNotFound         = errors.New("cookie not found")
        ErrInvalidCertOrKeyType   = errors.New("invalid cert or key type, must be string or []byte")
        ErrInvalidListenerNetwork = errors.New("invalid listener network")
)

// NotFoundHandler is the handler that router uses in case there was no matching route found. Returns an error that results
// HTTP 404 status code.
var NotFoundHandler = func(c Context) error <span class="cov8" title="1">{
        return ErrNotFound
}</span>

// MethodNotAllowedHandler is the handler thar router uses in case there was no matching route found but there was
// another matching routes for that requested URL. Returns an error that results HTTP 405 Method Not Allowed status code.
var MethodNotAllowedHandler = func(c Context) error <span class="cov8" title="1">{
        // See RFC 7231 section 7.4.1: An origin server MUST generate an Allow field in a 405 (Method Not Allowed)
        // response and MAY do so in any other response. For disabled resources an empty Allow header may be returned
        routerAllowMethods, ok := c.Get(ContextKeyHeaderAllow).(string)
        if ok &amp;&amp; routerAllowMethods != "" </span><span class="cov8" title="1">{
                c.Response().Header().Set(HeaderAllow, routerAllowMethods)
        }</span>
        <span class="cov8" title="1">return ErrMethodNotAllowed</span>
}

// New creates an instance of Echo.
func New() (e *Echo) <span class="cov8" title="1">{
        e = &amp;Echo{
                filesystem: createFilesystem(),
                Server:     new(http.Server),
                TLSServer:  new(http.Server),
                AutoTLSManager: autocert.Manager{
                        Prompt: autocert.AcceptTOS,
                },
                Logger:          log.New("echo"),
                colorer:         color.New(),
                maxParam:        new(int),
                ListenerNetwork: "tcp",
        }
        e.Server.Handler = e
        e.TLSServer.Handler = e
        e.HTTPErrorHandler = e.DefaultHTTPErrorHandler
        e.Binder = &amp;DefaultBinder{}
        e.JSONSerializer = &amp;DefaultJSONSerializer{}
        e.Logger.SetLevel(log.ERROR)
        e.StdLogger = stdLog.New(e.Logger.Output(), e.Logger.Prefix()+": ", 0)
        e.pool.New = func() interface{} </span><span class="cov8" title="1">{
                return e.NewContext(nil, nil)
        }</span>
        <span class="cov8" title="1">e.router = NewRouter(e)
        e.routers = map[string]*Router{}
        return</span>
}

// NewContext returns a Context instance.
func (e *Echo) NewContext(r *http.Request, w http.ResponseWriter) Context <span class="cov8" title="1">{
        return &amp;context{
                request:  r,
                response: NewResponse(w, e),
                store:    make(Map),
                echo:     e,
                pvalues:  make([]string, *e.maxParam),
                handler:  NotFoundHandler,
        }
}</span>

// Router returns the default router.
func (e *Echo) Router() *Router <span class="cov8" title="1">{
        return e.router
}</span>

// Routers returns the map of host =&gt; router.
func (e *Echo) Routers() map[string]*Router <span class="cov8" title="1">{
        return e.routers
}</span>

// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response
// with status code.
//
// NOTE: In case errors happens in middleware call-chain that is returning from handler (which did not return an error).
// When handler has already sent response (ala c.JSON()) and there is error in middleware that is returning from
// handler. Then the error that global error handler received will be ignored because we have already "committed" the
// response and status code header has been sent to the client.
func (e *Echo) DefaultHTTPErrorHandler(err error, c Context) <span class="cov8" title="1">{

        if c.Response().Committed </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">he, ok := err.(*HTTPError)
        if ok </span><span class="cov8" title="1">{
                if he.Internal != nil </span><span class="cov8" title="1">{
                        if herr, ok := he.Internal.(*HTTPError); ok </span><span class="cov0" title="0">{
                                he = herr
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                he = &amp;HTTPError{
                        Code:    http.StatusInternalServerError,
                        Message: http.StatusText(http.StatusInternalServerError),
                }
        }</span>

        // Issue #1426
        <span class="cov8" title="1">code := he.Code
        message := he.Message

        switch m := he.Message.(type) </span>{
        case string:<span class="cov8" title="1">
                if e.Debug </span><span class="cov8" title="1">{
                        message = Map{"message": m, "error": err.Error()}
                }</span> else<span class="cov8" title="1"> {
                        message = Map{"message": m}
                }</span>
        case json.Marshaler:<span class="cov8" title="1"></span>
                // do nothing - this type knows how to format itself to JSON
        case error:<span class="cov8" title="1">
                message = Map{"message": m.Error()}</span>
        }

        // Send response
        <span class="cov8" title="1">if c.Request().Method == http.MethodHead </span><span class="cov0" title="0">{ // Issue #608
                err = c.NoContent(he.Code)
        }</span> else<span class="cov8" title="1"> {
                err = c.JSON(code, message)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error(err)
        }</span>
}

// Pre adds middleware to the chain which is run before router.
func (e *Echo) Pre(middleware ...MiddlewareFunc) <span class="cov8" title="1">{
        e.premiddleware = append(e.premiddleware, middleware...)
}</span>

// Use adds middleware to the chain which is run after router.
func (e *Echo) Use(middleware ...MiddlewareFunc) <span class="cov8" title="1">{
        e.middleware = append(e.middleware, middleware...)
}</span>

// CONNECT registers a new CONNECT route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodConnect, path, h, m...)
}</span>

// DELETE registers a new DELETE route for a path with matching handler in the router
// with optional route-level middleware.
func (e *Echo) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodDelete, path, h, m...)
}</span>

// GET registers a new GET route for a path with matching handler in the router
// with optional route-level middleware.
func (e *Echo) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodGet, path, h, m...)
}</span>

// HEAD registers a new HEAD route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodHead, path, h, m...)
}</span>

// OPTIONS registers a new OPTIONS route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodOptions, path, h, m...)
}</span>

// PATCH registers a new PATCH route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodPatch, path, h, m...)
}</span>

// POST registers a new POST route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodPost, path, h, m...)
}</span>

// PUT registers a new PUT route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodPut, path, h, m...)
}</span>

// TRACE registers a new TRACE route for a path with matching handler in the
// router with optional route-level middleware.
func (e *Echo) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(http.MethodTrace, path, h, m...)
}</span>

// RouteNotFound registers a special-case route which is executed when no other route is found (i.e. HTTP 404 cases)
// for current request URL.
// Path supports static and named/any parameters just like other http method is defined. Generally path is ended with
// wildcard/match-any character (`/*`, `/download/*` etc).
//
// Example: `e.RouteNotFound("/*", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })`
func (e *Echo) RouteNotFound(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.Add(RouteNotFound, path, h, m...)
}</span>

// Any registers a new route for all HTTP methods (supported by Echo) and path with matching handler
// in the router with optional route-level middleware.
//
// Note: this method only adds specific set of supported HTTP methods as handler and is not true
// "catch-any-arbitrary-method" way of matching requests.
func (e *Echo) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route <span class="cov8" title="1">{
        routes := make([]*Route, len(methods))
        for i, m := range methods </span><span class="cov8" title="1">{
                routes[i] = e.Add(m, path, handler, middleware...)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// Match registers a new route for multiple HTTP methods and path with matching
// handler in the router with optional route-level middleware.
func (e *Echo) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route <span class="cov8" title="1">{
        routes := make([]*Route, len(methods))
        for i, m := range methods </span><span class="cov8" title="1">{
                routes[i] = e.Add(m, path, handler, middleware...)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

func (common) file(path, file string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route,
        m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return get(path, func(c Context) error </span><span class="cov8" title="1">{
                return c.File(file)
        }</span>, m...)
}

// File registers a new route with path to serve a static file with optional route-level middleware.
func (e *Echo) File(path, file string, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.file(path, file, e.GET, m...)
}</span>

func (e *Echo) add(host, method, path string, handler HandlerFunc, middlewares ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        router := e.findRouter(host)
        //FIXME: when handler+middleware are both nil ... make it behave like handler removal
        name := handlerName(handler)
        route := router.add(method, path, name, func(c Context) error </span><span class="cov8" title="1">{
                h := applyMiddleware(handler, middlewares...)
                return h(c)
        }</span>)

        <span class="cov8" title="1">if e.OnAddRouteHandler != nil </span><span class="cov8" title="1">{
                e.OnAddRouteHandler(host, *route, handler, middlewares)
        }</span>

        <span class="cov8" title="1">return route</span>
}

// Add registers a new route for an HTTP method and path with matching handler
// in the router with optional route-level middleware.
func (e *Echo) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.add("", method, path, handler, middleware...)
}</span>

// Host creates a new router group for the provided host and optional host-level middleware.
func (e *Echo) Host(name string, m ...MiddlewareFunc) (g *Group) <span class="cov8" title="1">{
        e.routers[name] = NewRouter(e)
        g = &amp;Group{host: name, echo: e}
        g.Use(m...)
        return
}</span>

// Group creates a new router group with prefix and optional group-level middleware.
func (e *Echo) Group(prefix string, m ...MiddlewareFunc) (g *Group) <span class="cov8" title="1">{
        g = &amp;Group{prefix: prefix, echo: e}
        g.Use(m...)
        return
}</span>

// URI generates an URI from handler.
func (e *Echo) URI(handler HandlerFunc, params ...interface{}) string <span class="cov8" title="1">{
        name := handlerName(handler)
        return e.Reverse(name, params...)
}</span>

// URL is an alias for `URI` function.
func (e *Echo) URL(h HandlerFunc, params ...interface{}) string <span class="cov8" title="1">{
        return e.URI(h, params...)
}</span>

// Reverse generates a URL from route name and provided parameters.
func (e *Echo) Reverse(name string, params ...interface{}) string <span class="cov8" title="1">{
        return e.router.Reverse(name, params...)
}</span>

// Routes returns the registered routes for default router.
// In case when Echo serves multiple hosts/domains use `e.Routers()["domain2.site"].Routes()` to get specific host routes.
func (e *Echo) Routes() []*Route <span class="cov8" title="1">{
        return e.router.Routes()
}</span>

// AcquireContext returns an empty `Context` instance from the pool.
// You must return the context by calling `ReleaseContext()`.
func (e *Echo) AcquireContext() Context <span class="cov8" title="1">{
        return e.pool.Get().(Context)
}</span>

// ReleaseContext returns the `Context` instance back to the pool.
// You must call it after `AcquireContext()`.
func (e *Echo) ReleaseContext(c Context) <span class="cov8" title="1">{
        e.pool.Put(c)
}</span>

// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.
func (e *Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Acquire context
        c := e.pool.Get().(*context)
        c.Reset(r, w)
        var h HandlerFunc

        if e.premiddleware == nil </span><span class="cov8" title="1">{
                e.findRouter(r.Host).Find(r.Method, GetPath(r), c)
                h = c.Handler()
                h = applyMiddleware(h, e.middleware...)
        }</span> else<span class="cov8" title="1"> {
                h = func(c Context) error </span><span class="cov8" title="1">{
                        e.findRouter(r.Host).Find(r.Method, GetPath(r), c)
                        h := c.Handler()
                        h = applyMiddleware(h, e.middleware...)
                        return h(c)
                }</span>
                <span class="cov8" title="1">h = applyMiddleware(h, e.premiddleware...)</span>
        }

        // Execute chain
        <span class="cov8" title="1">if err := h(c); err != nil </span><span class="cov8" title="1">{
                e.HTTPErrorHandler(err, c)
        }</span>

        // Release context
        <span class="cov8" title="1">e.pool.Put(c)</span>
}

// Start starts an HTTP server.
func (e *Echo) Start(address string) error <span class="cov8" title="1">{
        e.startupMutex.Lock()
        e.Server.Addr = address
        if err := e.configureServer(e.Server); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return err
        }</span>
        <span class="cov8" title="1">e.startupMutex.Unlock()
        return e.Server.Serve(e.Listener)</span>
}

// StartTLS starts an HTTPS server.
// If `certFile` or `keyFile` is `string` the values are treated as file paths.
// If `certFile` or `keyFile` is `[]byte` the values are treated as the certificate or key as-is.
func (e *Echo) StartTLS(address string, certFile, keyFile interface{}) (err error) <span class="cov8" title="1">{
        e.startupMutex.Lock()
        var cert []byte
        if cert, err = filepathOrContent(certFile); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return
        }</span>

        <span class="cov8" title="1">var key []byte
        if key, err = filepathOrContent(keyFile); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return
        }</span>

        <span class="cov8" title="1">s := e.TLSServer
        s.TLSConfig = new(tls.Config)
        s.TLSConfig.Certificates = make([]tls.Certificate, 1)
        if s.TLSConfig.Certificates[0], err = tls.X509KeyPair(cert, key); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return
        }</span>

        <span class="cov8" title="1">e.configureTLS(address)
        if err := e.configureServer(s); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return err
        }</span>
        <span class="cov8" title="1">e.startupMutex.Unlock()
        return s.Serve(e.TLSListener)</span>
}

func filepathOrContent(fileOrContent interface{}) (content []byte, err error) <span class="cov8" title="1">{
        switch v := fileOrContent.(type) </span>{
        case string:<span class="cov8" title="1">
                return os.ReadFile(v)</span>
        case []byte:<span class="cov8" title="1">
                return v, nil</span>
        default:<span class="cov8" title="1">
                return nil, ErrInvalidCertOrKeyType</span>
        }
}

// StartAutoTLS starts an HTTPS server using certificates automatically installed from https://letsencrypt.org.
func (e *Echo) StartAutoTLS(address string) error <span class="cov8" title="1">{
        e.startupMutex.Lock()
        s := e.TLSServer
        s.TLSConfig = new(tls.Config)
        s.TLSConfig.GetCertificate = e.AutoTLSManager.GetCertificate
        s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, acme.ALPNProto)

        e.configureTLS(address)
        if err := e.configureServer(s); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return err
        }</span>
        <span class="cov8" title="1">e.startupMutex.Unlock()
        return s.Serve(e.TLSListener)</span>
}

func (e *Echo) configureTLS(address string) <span class="cov8" title="1">{
        s := e.TLSServer
        s.Addr = address
        if !e.DisableHTTP2 </span><span class="cov8" title="1">{
                s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "h2")
        }</span>
}

// StartServer starts a custom http server.
func (e *Echo) StartServer(s *http.Server) (err error) <span class="cov8" title="1">{
        e.startupMutex.Lock()
        if err := e.configureServer(s); err != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return err
        }</span>
        <span class="cov8" title="1">if s.TLSConfig != nil </span><span class="cov8" title="1">{
                e.startupMutex.Unlock()
                return s.Serve(e.TLSListener)
        }</span>
        <span class="cov8" title="1">e.startupMutex.Unlock()
        return s.Serve(e.Listener)</span>
}

func (e *Echo) configureServer(s *http.Server) error <span class="cov8" title="1">{
        // Setup
        e.colorer.SetOutput(e.Logger.Output())
        s.ErrorLog = e.StdLogger
        s.Handler = e
        if e.Debug </span><span class="cov8" title="1">{
                e.Logger.SetLevel(log.DEBUG)
        }</span>

        <span class="cov8" title="1">if !e.HideBanner </span><span class="cov8" title="1">{
                e.colorer.Printf(banner, e.colorer.Red("v"+Version), e.colorer.Blue(website))
        }</span>

        <span class="cov8" title="1">if s.TLSConfig == nil </span><span class="cov8" title="1">{
                if e.Listener == nil </span><span class="cov8" title="1">{
                        l, err := newListener(s.Addr, e.ListenerNetwork)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">e.Listener = l</span>
                }
                <span class="cov8" title="1">if !e.HidePort </span><span class="cov8" title="1">{
                        e.colorer.Printf("â¨ http server started on %s\n", e.colorer.Green(e.Listener.Addr()))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if e.TLSListener == nil </span><span class="cov8" title="1">{
                l, err := newListener(s.Addr, e.ListenerNetwork)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">e.TLSListener = tls.NewListener(l, s.TLSConfig)</span>
        }
        <span class="cov8" title="1">if !e.HidePort </span><span class="cov8" title="1">{
                e.colorer.Printf("â¨ https server started on %s\n", e.colorer.Green(e.TLSListener.Addr()))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListenerAddr returns net.Addr for Listener
func (e *Echo) ListenerAddr() net.Addr <span class="cov8" title="1">{
        e.startupMutex.RLock()
        defer e.startupMutex.RUnlock()
        if e.Listener == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return e.Listener.Addr()</span>
}

// TLSListenerAddr returns net.Addr for TLSListener
func (e *Echo) TLSListenerAddr() net.Addr <span class="cov8" title="1">{
        e.startupMutex.RLock()
        defer e.startupMutex.RUnlock()
        if e.TLSListener == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return e.TLSListener.Addr()</span>
}

// StartH2CServer starts a custom http/2 server with h2c (HTTP/2 Cleartext).
func (e *Echo) StartH2CServer(address string, h2s *http2.Server) error <span class="cov8" title="1">{
        e.startupMutex.Lock()
        // Setup
        s := e.Server
        s.Addr = address
        e.colorer.SetOutput(e.Logger.Output())
        s.ErrorLog = e.StdLogger
        s.Handler = h2c.NewHandler(e, h2s)
        if e.Debug </span><span class="cov8" title="1">{
                e.Logger.SetLevel(log.DEBUG)
        }</span>

        <span class="cov8" title="1">if !e.HideBanner </span><span class="cov8" title="1">{
                e.colorer.Printf(banner, e.colorer.Red("v"+Version), e.colorer.Blue(website))
        }</span>

        <span class="cov8" title="1">if e.Listener == nil </span><span class="cov8" title="1">{
                l, err := newListener(s.Addr, e.ListenerNetwork)
                if err != nil </span><span class="cov8" title="1">{
                        e.startupMutex.Unlock()
                        return err
                }</span>
                <span class="cov8" title="1">e.Listener = l</span>
        }
        <span class="cov8" title="1">if !e.HidePort </span><span class="cov8" title="1">{
                e.colorer.Printf("â¨ http server started on %s\n", e.colorer.Green(e.Listener.Addr()))
        }</span>
        <span class="cov8" title="1">e.startupMutex.Unlock()
        return s.Serve(e.Listener)</span>
}

// Close immediately stops the server.
// It internally calls `http.Server#Close()`.
func (e *Echo) Close() error <span class="cov8" title="1">{
        e.startupMutex.Lock()
        defer e.startupMutex.Unlock()
        if err := e.TLSServer.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return e.Server.Close()</span>
}

// Shutdown stops the server gracefully.
// It internally calls `http.Server#Shutdown()`.
func (e *Echo) Shutdown(ctx stdContext.Context) error <span class="cov8" title="1">{
        e.startupMutex.Lock()
        defer e.startupMutex.Unlock()
        if err := e.TLSServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return e.Server.Shutdown(ctx)</span>
}

// NewHTTPError creates a new HTTPError instance.
func NewHTTPError(code int, message ...interface{}) *HTTPError <span class="cov8" title="1">{
        he := &amp;HTTPError{Code: code, Message: http.StatusText(code)}
        if len(message) &gt; 0 </span><span class="cov8" title="1">{
                he.Message = message[0]
        }</span>
        <span class="cov8" title="1">return he</span>
}

// Error makes it compatible with `error` interface.
func (he *HTTPError) Error() string <span class="cov8" title="1">{
        if he.Internal == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("code=%d, message=%v", he.Code, he.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("code=%d, message=%v, internal=%v", he.Code, he.Message, he.Internal)</span>
}

// SetInternal sets error to HTTPError.Internal
func (he *HTTPError) SetInternal(err error) *HTTPError <span class="cov8" title="1">{
        he.Internal = err
        return he
}</span>

// WithInternal returns clone of HTTPError with err set to HTTPError.Internal field
func (he *HTTPError) WithInternal(err error) *HTTPError <span class="cov8" title="1">{
        return &amp;HTTPError{
                Code:     he.Code,
                Message:  he.Message,
                Internal: err,
        }
}</span>

// Unwrap satisfies the Go 1.13 error wrapper interface.
func (he *HTTPError) Unwrap() error <span class="cov8" title="1">{
        return he.Internal
}</span>

// WrapHandler wraps `http.Handler` into `echo.HandlerFunc`.
func WrapHandler(h http.Handler) HandlerFunc <span class="cov8" title="1">{
        return func(c Context) error </span><span class="cov8" title="1">{
                h.ServeHTTP(c.Response(), c.Request())
                return nil
        }</span>
}

// WrapMiddleware wraps `func(http.Handler) http.Handler` into `echo.MiddlewareFunc`
func WrapMiddleware(m func(http.Handler) http.Handler) MiddlewareFunc <span class="cov8" title="1">{
        return func(next HandlerFunc) HandlerFunc </span><span class="cov8" title="1">{
                return func(c Context) (err error) </span><span class="cov8" title="1">{
                        m(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                                c.SetRequest(r)
                                c.SetResponse(NewResponse(w, c.Echo()))
                                err = next(c)
                        }</span>)).ServeHTTP(c.Response(), c.Request())
                        <span class="cov8" title="1">return</span>
                }
        }
}

// GetPath returns RawPath, if it's empty returns Path from URL
// Difference between RawPath and Path is:
//   - Path is where request path is stored. Value is stored in decoded form: /%47%6f%2f becomes /Go/.
//   - RawPath is an optional field which only gets set if the default encoding is different from Path.
func GetPath(r *http.Request) string <span class="cov8" title="1">{
        path := r.URL.RawPath
        if path == "" </span><span class="cov8" title="1">{
                path = r.URL.Path
        }</span>
        <span class="cov8" title="1">return path</span>
}

func (e *Echo) findRouter(host string) *Router <span class="cov8" title="1">{
        if len(e.routers) &gt; 0 </span><span class="cov8" title="1">{
                if r, ok := e.routers[host]; ok </span><span class="cov8" title="1">{
                        return r
                }</span>
        }
        <span class="cov8" title="1">return e.router</span>
}

func handlerName(h HandlerFunc) string <span class="cov8" title="1">{
        t := reflect.ValueOf(h).Type()
        if t.Kind() == reflect.Func </span><span class="cov8" title="1">{
                return runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()
        }</span>
        <span class="cov0" title="0">return t.String()</span>
}

// // PathUnescape is wraps `url.PathUnescape`
// func PathUnescape(s string) (string, error) {
//         return url.PathUnescape(s)
// }

// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted
// connections. It's used by ListenAndServe and ListenAndServeTLS so
// dead TCP connections (e.g. closing laptop mid-download) eventually
// go away.
type tcpKeepAliveListener struct {
        *net.TCPListener
}

func (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) <span class="cov8" title="1">{
        if c, err = ln.AcceptTCP(); err != nil </span><span class="cov8" title="1">{
                return
        }</span> else<span class="cov8" title="1"> if err = c.(*net.TCPConn).SetKeepAlive(true); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // Ignore error from setting the KeepAlivePeriod as some systems, such as
        // OpenBSD, do not support setting TCP_USER_TIMEOUT on IPPROTO_TCP
        <span class="cov8" title="1">_ = c.(*net.TCPConn).SetKeepAlivePeriod(3 * time.Minute)
        return</span>
}

func newListener(address, network string) (*tcpKeepAliveListener, error) <span class="cov8" title="1">{
        if network != "tcp" &amp;&amp; network != "tcp4" &amp;&amp; network != "tcp6" </span><span class="cov8" title="1">{
                return nil, ErrInvalidListenerNetwork
        }</span>
        <span class="cov8" title="1">l, err := net.Listen(network, address)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;tcpKeepAliveListener{l.(*net.TCPListener)}, nil</span>
}

func applyMiddleware(h HandlerFunc, middleware ...MiddlewareFunc) HandlerFunc <span class="cov8" title="1">{
        for i := len(middleware) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                h = middleware[i](h)
        }</span>
        <span class="cov8" title="1">return h</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "fmt"
        "io/fs"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strings"
)

type filesystem struct {
        // Filesystem is file system used by Static and File handlers to access files.
        // Defaults to os.DirFS(".")
        //
        // When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, "rootDirectory") to create sub fs which uses necessary
        // prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths
        // including `assets/images` as their prefix.
        Filesystem fs.FS
}

func createFilesystem() filesystem <span class="cov8" title="1">{
        return filesystem{
                Filesystem: newDefaultFS(),
        }
}</span>

// Static registers a new route with path prefix to serve static files from the provided root directory.
func (e *Echo) Static(pathPrefix, fsRoot string) *Route <span class="cov8" title="1">{
        subFs := MustSubFS(e.Filesystem, fsRoot)
        return e.Add(
                http.MethodGet,
                pathPrefix+"*",
                StaticDirectoryHandler(subFs, false),
        )
}</span>

// StaticFS registers a new route with path prefix to serve static files from the provided file system.
//
// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, "rootDirectory") to create sub fs which uses necessary
// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths
// including `assets/images` as their prefix.
func (e *Echo) StaticFS(pathPrefix string, filesystem fs.FS) *Route <span class="cov8" title="1">{
        return e.Add(
                http.MethodGet,
                pathPrefix+"*",
                StaticDirectoryHandler(filesystem, false),
        )
}</span>

// StaticDirectoryHandler creates handler function to serve files from provided file system
// When disablePathUnescaping is set then file name from path is not unescaped and is served as is.
func StaticDirectoryHandler(fileSystem fs.FS, disablePathUnescaping bool) HandlerFunc <span class="cov8" title="1">{
        return func(c Context) error </span><span class="cov8" title="1">{
                p := c.Param("*")
                if !disablePathUnescaping </span><span class="cov8" title="1">{ // when router is already unescaping we do not want to do is twice
                        tmpPath, err := url.PathUnescape(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unescape path variable: %w", err)
                        }</span>
                        <span class="cov8" title="1">p = tmpPath</span>
                }

                // fs.FS.Open() already assumes that file names are relative to FS root path and considers name with prefix `/` as invalid
                <span class="cov8" title="1">name := filepath.ToSlash(filepath.Clean(strings.TrimPrefix(p, "/")))
                fi, err := fs.Stat(fileSystem, name)
                if err != nil </span><span class="cov8" title="1">{
                        return ErrNotFound
                }</span>

                // If the request is for a directory and does not end with "/"
                <span class="cov8" title="1">p = c.Request().URL.Path // path must not be empty.
                if fi.IsDir() &amp;&amp; len(p) &gt; 0 &amp;&amp; p[len(p)-1] != '/' </span><span class="cov8" title="1">{
                        // Redirect to ends with "/"
                        return c.Redirect(http.StatusMovedPermanently, sanitizeURI(p+"/"))
                }</span>
                <span class="cov8" title="1">return fsFile(c, name, fileSystem)</span>
        }
}

// FileFS registers a new route with path to serve file from the provided file system.
func (e *Echo) FileFS(path, file string, filesystem fs.FS, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return e.GET(path, StaticFileHandler(file, filesystem), m...)
}</span>

// StaticFileHandler creates handler function to serve file from provided file system
func StaticFileHandler(file string, filesystem fs.FS) HandlerFunc <span class="cov8" title="1">{
        return func(c Context) error </span><span class="cov8" title="1">{
                return fsFile(c, file, filesystem)
        }</span>
}

// defaultFS exists to preserve pre v4.7.0 behaviour where files were open by `os.Open`.
// v4.7 introduced `echo.Filesystem` field which is Go1.16+ `fs.Fs` interface.
// Difference between `os.Open` and `fs.Open` is that FS does not allow opening path that start with `.`, `..` or `/`
// etc. For example previously you could have `../images` in your application but `fs := os.DirFS("./")` would not
// allow you to use `fs.Open("../images")` and this would break all old applications that rely on being able to
// traverse up from current executable run path.
// NB: private because you really should use fs.FS implementation instances
type defaultFS struct {
        fs     fs.FS
        prefix string
}

func newDefaultFS() *defaultFS <span class="cov8" title="1">{
        dir, _ := os.Getwd()
        return &amp;defaultFS{
                prefix: dir,
                fs:     nil,
        }
}</span>

func (fs defaultFS) Open(name string) (fs.File, error) <span class="cov8" title="1">{
        if fs.fs == nil </span><span class="cov8" title="1">{
                return os.Open(name)
        }</span>
        <span class="cov8" title="1">return fs.fs.Open(name)</span>
}

func subFS(currentFs fs.FS, root string) (fs.FS, error) <span class="cov8" title="1">{
        root = filepath.ToSlash(filepath.Clean(root)) // note: fs.FS operates only with slashes. `ToSlash` is necessary for Windows
        if dFS, ok := currentFs.(*defaultFS); ok </span><span class="cov8" title="1">{
                // we need to make exception for `defaultFS` instances as it interprets root prefix differently from fs.FS.
                // fs.Fs.Open does not like relative paths ("./", "../") and absolute paths at all but prior echo.Filesystem we
                // were able to use paths like `./myfile.log`, `/etc/hosts` and these would work fine with `os.Open` but not with fs.Fs
                if !filepath.IsAbs(root) </span><span class="cov8" title="1">{
                        root = filepath.Join(dFS.prefix, root)
                }</span>
                <span class="cov8" title="1">return &amp;defaultFS{
                        prefix: root,
                        fs:     os.DirFS(root),
                }, nil</span>
        }
        <span class="cov8" title="1">return fs.Sub(currentFs, root)</span>
}

// MustSubFS creates sub FS from current filesystem or panic on failure.
// Panic happens when `fsRoot` contains invalid path according to `fs.ValidPath` rules.
//
// MustSubFS is helpful when dealing with `embed.FS` because for example `//go:embed assets/images` embeds files with
// paths including `assets/images` as their prefix. In that case use `fs := echo.MustSubFS(fs, "rootDirectory") to
// create sub fs which uses necessary prefix for directory path.
func MustSubFS(currentFs fs.FS, fsRoot string) fs.FS <span class="cov8" title="1">{
        subFs, err := subFS(currentFs, fsRoot)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Errorf("can not create sub FS, invalid root given, err: %w", err))</span>
        }
        <span class="cov8" title="1">return subFs</span>
}

func sanitizeURI(uri string) string <span class="cov8" title="1">{
        // double slash `\\`, `//` or even `\/` is absolute uri for browsers and by redirecting request to that uri
        // we are vulnerable to open redirect attack. so replace all slashes from the beginning with single slash
        if len(uri) &gt; 1 &amp;&amp; (uri[0] == '\\' || uri[0] == '/') &amp;&amp; (uri[1] == '\\' || uri[1] == '/') </span><span class="cov0" title="0">{
                uri = "/" + strings.TrimLeft(uri, `/\`)
        }</span>
        <span class="cov8" title="1">return uri</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "net/http"
)

// Group is a set of sub-routes for a specified route. It can be used for inner
// routes that share a common middleware or functionality that should be separate
// from the parent echo instance while still inheriting from it.
type Group struct {
        common
        host       string
        prefix     string
        echo       *Echo
        middleware []MiddlewareFunc
}

// Use implements `Echo#Use()` for sub-routes within the Group.
func (g *Group) Use(middleware ...MiddlewareFunc) <span class="cov8" title="1">{
        g.middleware = append(g.middleware, middleware...)
        if len(g.middleware) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        // group level middlewares are different from Echo `Pre` and `Use` middlewares (those are global). Group level middlewares
        // are only executed if they are added to the Router with route.
        // So we register catch all route (404 is a safe way to emulate route match) for this group and now during routing the
        // Router would find route to match our request path and therefore guarantee the middleware(s) will get executed.
        <span class="cov8" title="1">g.RouteNotFound("", NotFoundHandler)
        g.RouteNotFound("/*", NotFoundHandler)</span>
}

// CONNECT implements `Echo#CONNECT()` for sub-routes within the Group.
func (g *Group) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodConnect, path, h, m...)
}</span>

// DELETE implements `Echo#DELETE()` for sub-routes within the Group.
func (g *Group) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodDelete, path, h, m...)
}</span>

// GET implements `Echo#GET()` for sub-routes within the Group.
func (g *Group) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodGet, path, h, m...)
}</span>

// HEAD implements `Echo#HEAD()` for sub-routes within the Group.
func (g *Group) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodHead, path, h, m...)
}</span>

// OPTIONS implements `Echo#OPTIONS()` for sub-routes within the Group.
func (g *Group) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodOptions, path, h, m...)
}</span>

// PATCH implements `Echo#PATCH()` for sub-routes within the Group.
func (g *Group) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodPatch, path, h, m...)
}</span>

// POST implements `Echo#POST()` for sub-routes within the Group.
func (g *Group) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodPost, path, h, m...)
}</span>

// PUT implements `Echo#PUT()` for sub-routes within the Group.
func (g *Group) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodPut, path, h, m...)
}</span>

// TRACE implements `Echo#TRACE()` for sub-routes within the Group.
func (g *Group) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(http.MethodTrace, path, h, m...)
}</span>

// Any implements `Echo#Any()` for sub-routes within the Group.
func (g *Group) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route <span class="cov8" title="1">{
        routes := make([]*Route, len(methods))
        for i, m := range methods </span><span class="cov8" title="1">{
                routes[i] = g.Add(m, path, handler, middleware...)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// Match implements `Echo#Match()` for sub-routes within the Group.
func (g *Group) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route <span class="cov8" title="1">{
        routes := make([]*Route, len(methods))
        for i, m := range methods </span><span class="cov8" title="1">{
                routes[i] = g.Add(m, path, handler, middleware...)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// Group creates a new sub-group with prefix and optional sub-group-level middleware.
func (g *Group) Group(prefix string, middleware ...MiddlewareFunc) (sg *Group) <span class="cov8" title="1">{
        m := make([]MiddlewareFunc, 0, len(g.middleware)+len(middleware))
        m = append(m, g.middleware...)
        m = append(m, middleware...)
        sg = g.echo.Group(g.prefix+prefix, m...)
        sg.host = g.host
        return
}</span>

// File implements `Echo#File()` for sub-routes within the Group.
func (g *Group) File(path, file string) <span class="cov8" title="1">{
        g.file(path, file, g.GET)
}</span>

// RouteNotFound implements `Echo#RouteNotFound()` for sub-routes within the Group.
//
// Example: `g.RouteNotFound("/*", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })`
func (g *Group) RouteNotFound(path string, h HandlerFunc, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.Add(RouteNotFound, path, h, m...)
}</span>

// Add implements `Echo#Add()` for sub-routes within the Group.
func (g *Group) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        // Combine into a new slice to avoid accidentally passing the same slice for
        // multiple routes, which would lead to later add() calls overwriting the
        // middleware from earlier calls.
        m := make([]MiddlewareFunc, 0, len(g.middleware)+len(middleware))
        m = append(m, g.middleware...)
        m = append(m, middleware...)
        return g.echo.add(g.host, method, g.prefix+path, handler, m...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "io/fs"
        "net/http"
)

// Static implements `Echo#Static()` for sub-routes within the Group.
func (g *Group) Static(pathPrefix, fsRoot string) <span class="cov8" title="1">{
        subFs := MustSubFS(g.echo.Filesystem, fsRoot)
        g.StaticFS(pathPrefix, subFs)
}</span>

// StaticFS implements `Echo#StaticFS()` for sub-routes within the Group.
//
// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, "rootDirectory") to create sub fs which uses necessary
// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths
// including `assets/images` as their prefix.
func (g *Group) StaticFS(pathPrefix string, filesystem fs.FS) <span class="cov8" title="1">{
        g.Add(
                http.MethodGet,
                pathPrefix+"*",
                StaticDirectoryHandler(filesystem, false),
        )
}</span>

// FileFS implements `Echo#FileFS()` for sub-routes within the Group.
func (g *Group) FileFS(path, file string, filesystem fs.FS, m ...MiddlewareFunc) *Route <span class="cov8" title="1">{
        return g.GET(path, StaticFileHandler(file, filesystem), m...)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "net"
        "net/http"
        "strings"
)

/**
By: https://github.com/tmshn (See: https://github.com/labstack/echo/pull/1478 , https://github.com/labstack/echox/pull/134 )
Source: https://echo.labstack.com/guide/ip-address/

IP address plays fundamental role in HTTP; it's used for access control, auditing, geo-based access analysis and more.
Echo provides handy method [`Context#RealIP()`](https://godoc.org/github.com/labstack/echo#Context) for that.

However, it is not trivial to retrieve the _real_ IP address from requests especially when you put L7 proxies before the application.
In such situation, _real_ IP needs to be relayed on HTTP layer from proxies to your app, but you must not trust HTTP headers unconditionally.
Otherwise, you might give someone a chance of deceiving you. **A security risk!**

To retrieve IP address reliably/securely, you must let your application be aware of the entire architecture of your infrastructure.
In Echo, this can be done by configuring `Echo#IPExtractor` appropriately.
This guides show you why and how.

&gt; Note: if you don't set `Echo#IPExtractor` explicitly, Echo fallback to legacy behavior, which is not a good choice.

Let's start from two questions to know the right direction:

1. Do you put any HTTP (L7) proxy in front of the application?
    - It includes both cloud solutions (such as AWS ALB or GCP HTTP LB) and OSS ones (such as Nginx, Envoy or Istio ingress gateway).
2. If yes, what HTTP header do your proxies use to pass client IP to the application?

## Case 1. With no proxy

If you put no proxy (e.g.: directory facing to the internet), all you need to (and have to) see is IP address from network layer.
Any HTTP header is untrustable because the clients have full control what headers to be set.

In this case, use `echo.ExtractIPDirect()`.

```go
e.IPExtractor = echo.ExtractIPDirect()
```

## Case 2. With proxies using `X-Forwarded-For` header

[`X-Forwared-For` (XFF)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) is the popular header
to relay clients' IP addresses.
At each hop on the proxies, they append the request IP address at the end of the header.

Following example diagram illustrates this behavior.

```text
ââââââââââââ            ââââââââââââ            ââââââââââââ            ââââââââââââ
â "Origin" ââââââââââââ&gt;â Proxy 1  ââââââââââââ&gt;â Proxy 2  ââââââââââââ&gt;â Your app â
â (IP: a)  â            â (IP: b)  â            â (IP: c)  â            â          â
ââââââââââââ            ââââââââââââ            ââââââââââââ            ââââââââââââ

Case 1.
XFF:  ""                    "a"                     "a, b"
                                                    ~~~~~~
Case 2.
XFF:  "x"                   "x, a"                  "x, a, b"
                                                    ~~~~~~~~~
                                                    â What your app will see
```

In this case, use **first _untrustable_ IP reading from right**. Never use first one reading from left, as it is
configurable by client. Here "trustable" means "you are sure the IP address belongs to your infrastructure".
In above example, if `b` and `c` are trustable, the IP address of the client is `a` for both cases, never be `x`.

In Echo, use `ExtractIPFromXFFHeader(...TrustOption)`.

```go
e.IPExtractor = echo.ExtractIPFromXFFHeader()
```

By default, it trusts internal IP addresses (loopback, link-local unicast, private-use and unique local address
from [RFC6890](https://tools.ietf.org/html/rfc6890), [RFC4291](https://tools.ietf.org/html/rfc4291) and
[RFC4193](https://tools.ietf.org/html/rfc4193)).
To control this behavior, use [`TrustOption`](https://godoc.org/github.com/labstack/echo#TrustOption)s.

E.g.:

```go
e.IPExtractor = echo.ExtractIPFromXFFHeader(
        TrustLinkLocal(false),
        TrustIPRanges(lbIPRange),
)
```

- Ref: https://godoc.org/github.com/labstack/echo#TrustOption

## Case 3. With proxies using `X-Real-IP` header

`X-Real-IP` is another HTTP header to relay clients' IP addresses, but it carries only one address unlike XFF.

If your proxies set this header, use `ExtractIPFromRealIPHeader(...TrustOption)`.

```go
e.IPExtractor = echo.ExtractIPFromRealIPHeader()
```

Again, it trusts internal IP addresses by default (loopback, link-local unicast, private-use and unique local address
from [RFC6890](https://tools.ietf.org/html/rfc6890), [RFC4291](https://tools.ietf.org/html/rfc4291) and
[RFC4193](https://tools.ietf.org/html/rfc4193)).
To control this behavior, use [`TrustOption`](https://godoc.org/github.com/labstack/echo#TrustOption)s.

- Ref: https://godoc.org/github.com/labstack/echo#TrustOption

&gt; **Never forget** to configure the outermost proxy (i.e.; at the edge of your infrastructure) **not to pass through incoming headers**.
&gt; Otherwise there is a chance of fraud, as it is what clients can control.

## About default behavior

In default behavior, Echo sees all of first XFF header, X-Real-IP header and IP from network layer.

As you might already notice, after reading this article, this is not good.
Sole reason this is default is just backward compatibility.

## Private IP ranges

See: https://en.wikipedia.org/wiki/Private_network

Private IPv4 address ranges (RFC 1918):
* 10.0.0.0 â 10.255.255.255 (24-bit block)
* 172.16.0.0 â 172.31.255.255 (20-bit block)
* 192.168.0.0 â 192.168.255.255 (16-bit block)

Private IPv6 address ranges:
* fc00::/7 address block = RFC 4193 Unique Local Addresses (ULA)

*/

type ipChecker struct {
        trustExtraRanges []*net.IPNet
        trustLoopback    bool
        trustLinkLocal   bool
        trustPrivateNet  bool
}

// TrustOption is config for which IP address to trust
type TrustOption func(*ipChecker)

// TrustLoopback configures if you trust loopback address (default: true).
func TrustLoopback(v bool) TrustOption <span class="cov8" title="1">{
        return func(c *ipChecker) </span><span class="cov8" title="1">{
                c.trustLoopback = v
        }</span>
}

// TrustLinkLocal configures if you trust link-local address (default: true).
func TrustLinkLocal(v bool) TrustOption <span class="cov8" title="1">{
        return func(c *ipChecker) </span><span class="cov8" title="1">{
                c.trustLinkLocal = v
        }</span>
}

// TrustPrivateNet configures if you trust private network address (default: true).
func TrustPrivateNet(v bool) TrustOption <span class="cov8" title="1">{
        return func(c *ipChecker) </span><span class="cov8" title="1">{
                c.trustPrivateNet = v
        }</span>
}

// TrustIPRange add trustable IP ranges using CIDR notation.
func TrustIPRange(ipRange *net.IPNet) TrustOption <span class="cov8" title="1">{
        return func(c *ipChecker) </span><span class="cov8" title="1">{
                c.trustExtraRanges = append(c.trustExtraRanges, ipRange)
        }</span>
}

func newIPChecker(configs []TrustOption) *ipChecker <span class="cov8" title="1">{
        checker := &amp;ipChecker{trustLoopback: true, trustLinkLocal: true, trustPrivateNet: true}
        for _, configure := range configs </span><span class="cov8" title="1">{
                configure(checker)
        }</span>
        <span class="cov8" title="1">return checker</span>
}

// Go1.16+ added `ip.IsPrivate()` but until that use this implementation
func isPrivateIPRange(ip net.IP) bool <span class="cov8" title="1">{
        if ip4 := ip.To4(); ip4 != nil </span><span class="cov8" title="1">{
                return ip4[0] == 10 ||
                        ip4[0] == 172 &amp;&amp; ip4[1]&amp;0xf0 == 16 ||
                        ip4[0] == 192 &amp;&amp; ip4[1] == 168
        }</span>
        <span class="cov8" title="1">return len(ip) == net.IPv6len &amp;&amp; ip[0]&amp;0xfe == 0xfc</span>
}

func (c *ipChecker) trust(ip net.IP) bool <span class="cov8" title="1">{
        if c.trustLoopback &amp;&amp; ip.IsLoopback() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if c.trustLinkLocal &amp;&amp; ip.IsLinkLocalUnicast() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if c.trustPrivateNet &amp;&amp; isPrivateIPRange(ip) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, trustedRange := range c.trustExtraRanges </span><span class="cov8" title="1">{
                if trustedRange.Contains(ip) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IPExtractor is a function to extract IP addr from http.Request.
// Set appropriate one to Echo#IPExtractor.
// See https://echo.labstack.com/guide/ip-address for more details.
type IPExtractor func(*http.Request) string

// ExtractIPDirect extracts IP address using actual IP address.
// Use this if your server faces to internet directory (i.e.: uses no proxy).
func ExtractIPDirect() IPExtractor <span class="cov8" title="1">{
        return extractIP
}</span>

func extractIP(req *http.Request) string <span class="cov8" title="1">{
        ra, _, _ := net.SplitHostPort(req.RemoteAddr)
        return ra
}</span>

// ExtractIPFromRealIPHeader extracts IP address using x-real-ip header.
// Use this if you put proxy which uses this header.
func ExtractIPFromRealIPHeader(options ...TrustOption) IPExtractor <span class="cov8" title="1">{
        checker := newIPChecker(options)
        return func(req *http.Request) string </span><span class="cov8" title="1">{
                directIP := extractIP(req)
                realIP := req.Header.Get(HeaderXRealIP)
                if realIP == "" </span><span class="cov8" title="1">{
                        return directIP
                }</span>

                <span class="cov8" title="1">if checker.trust(net.ParseIP(directIP)) </span><span class="cov8" title="1">{
                        realIP = strings.TrimPrefix(realIP, "[")
                        realIP = strings.TrimSuffix(realIP, "]")
                        if rIP := net.ParseIP(realIP); rIP != nil </span><span class="cov8" title="1">{
                                return realIP
                        }</span>
                }

                <span class="cov8" title="1">return directIP</span>
        }
}

// ExtractIPFromXFFHeader extracts IP address using x-forwarded-for header.
// Use this if you put proxy which uses this header.
// This returns nearest untrustable IP. If all IPs are trustable, returns furthest one (i.e.: XFF[0]).
func ExtractIPFromXFFHeader(options ...TrustOption) IPExtractor <span class="cov8" title="1">{
        checker := newIPChecker(options)
        return func(req *http.Request) string </span><span class="cov8" title="1">{
                directIP := extractIP(req)
                xffs := req.Header[HeaderXForwardedFor]
                if len(xffs) == 0 </span><span class="cov8" title="1">{
                        return directIP
                }</span>
                <span class="cov8" title="1">ips := append(strings.Split(strings.Join(xffs, ","), ","), directIP)
                for i := len(ips) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        ips[i] = strings.TrimSpace(ips[i])
                        ips[i] = strings.TrimPrefix(ips[i], "[")
                        ips[i] = strings.TrimSuffix(ips[i], "]")
                        ip := net.ParseIP(ips[i])
                        if ip == nil </span><span class="cov8" title="1">{
                                // Unable to parse IP; cannot trust entire records
                                return directIP
                        }</span>
                        <span class="cov8" title="1">if !checker.trust(ip) </span><span class="cov8" title="1">{
                                return ip.String()
                        }</span>
                }
                // All of the IPs are trusted; return first element because it is furthest from server (best effort strategy).
                <span class="cov8" title="1">return strings.TrimSpace(ips[0])</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "encoding/json"
        "fmt"
        "net/http"
)

// DefaultJSONSerializer implements JSON encoding using encoding/json.
type DefaultJSONSerializer struct{}

// Serialize converts an interface into a json and writes it to the response.
// You can optionally use the indent parameter to produce pretty JSONs.
func (d DefaultJSONSerializer) Serialize(c Context, i interface{}, indent string) error <span class="cov8" title="1">{
        enc := json.NewEncoder(c.Response())
        if indent != "" </span><span class="cov8" title="1">{
                enc.SetIndent("", indent)
        }</span>
        <span class="cov8" title="1">return enc.Encode(i)</span>
}

// Deserialize reads a JSON from a request body and converts it into an interface.
func (d DefaultJSONSerializer) Deserialize(c Context, i interface{}) error <span class="cov8" title="1">{
        err := json.NewDecoder(c.Request().Body).Decode(i)
        if ute, ok := err.(*json.UnmarshalTypeError); ok </span><span class="cov8" title="1">{
                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v", ute.Type, ute.Value, ute.Field, ute.Offset)).SetInternal(err)
        }</span> else<span class="cov8" title="1"> if se, ok := err.(*json.SyntaxError); ok </span><span class="cov8" title="1">{
                return NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Syntax error: offset=%v, error=%v", se.Offset, se.Error())).SetInternal(err)
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "encoding/base64"
        "net/http"
        "strconv"
        "strings"

        "github.com/labstack/echo/v4"
)

// BasicAuthConfig defines the config for BasicAuth middleware.
type BasicAuthConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Validator is a function to validate BasicAuth credentials.
        // Required.
        Validator BasicAuthValidator

        // Realm is a string to define realm attribute of BasicAuth.
        // Default value "Restricted".
        Realm string
}

// BasicAuthValidator defines a function to validate BasicAuth credentials.
// The function should return a boolean indicating whether the credentials are valid,
// and an error if any error occurs during the validation process.
type BasicAuthValidator func(string, string, echo.Context) (bool, error)

const (
        basic        = "basic"
        defaultRealm = "Restricted"
)

// DefaultBasicAuthConfig is the default BasicAuth middleware config.
var DefaultBasicAuthConfig = BasicAuthConfig{
        Skipper: DefaultSkipper,
        Realm:   defaultRealm,
}

// BasicAuth returns an BasicAuth middleware.
//
// For valid credentials it calls the next handler.
// For missing or invalid credentials, it sends "401 - Unauthorized" response.
func BasicAuth(fn BasicAuthValidator) echo.MiddlewareFunc <span class="cov0" title="0">{
        c := DefaultBasicAuthConfig
        c.Validator = fn
        return BasicAuthWithConfig(c)
}</span>

// BasicAuthWithConfig returns an BasicAuth middleware with config.
// See `BasicAuth()`.
func BasicAuthWithConfig(config BasicAuthConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Validator == nil </span><span class="cov0" title="0">{
                panic("echo: basic-auth middleware requires a validator function")</span>
        }
        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov0" title="0">{
                config.Skipper = DefaultBasicAuthConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Realm == "" </span><span class="cov0" title="0">{
                config.Realm = defaultRealm
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">auth := c.Request().Header.Get(echo.HeaderAuthorization)
                        l := len(basic)

                        if len(auth) &gt; l+1 &amp;&amp; strings.EqualFold(auth[:l], basic) </span><span class="cov8" title="1">{
                                // Invalid base64 shouldn't be treated as error
                                // instead should be treated as invalid client input
                                b, err := base64.StdEncoding.DecodeString(auth[l+1:])
                                if err != nil </span><span class="cov8" title="1">{
                                        return echo.NewHTTPError(http.StatusBadRequest).SetInternal(err)
                                }</span>

                                <span class="cov8" title="1">cred := string(b)
                                for i := 0; i &lt; len(cred); i++ </span><span class="cov8" title="1">{
                                        if cred[i] == ':' </span><span class="cov8" title="1">{
                                                // Verify credentials
                                                valid, err := config.Validator(cred[:i], cred[i+1:], c)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span> else<span class="cov8" title="1"> if valid </span><span class="cov8" title="1">{
                                                        return next(c)
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">realm := defaultRealm
                        if config.Realm != defaultRealm </span><span class="cov8" title="1">{
                                realm = strconv.Quote(config.Realm)
                        }</span>

                        // Need to return `401` for browsers to pop-up login box.
                        <span class="cov8" title="1">c.Response().Header().Set(echo.HeaderWWWAuthenticate, basic+" realm="+realm)
                        return echo.ErrUnauthorized</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "bufio"
        "bytes"
        "errors"
        "io"
        "net"
        "net/http"

        "github.com/labstack/echo/v4"
)

// BodyDumpConfig defines the config for BodyDump middleware.
type BodyDumpConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Handler receives request and response payload.
        // Required.
        Handler BodyDumpHandler
}

// BodyDumpHandler receives the request and response payload.
type BodyDumpHandler func(echo.Context, []byte, []byte)

type bodyDumpResponseWriter struct {
        io.Writer
        http.ResponseWriter
}

// DefaultBodyDumpConfig is the default BodyDump middleware config.
var DefaultBodyDumpConfig = BodyDumpConfig{
        Skipper: DefaultSkipper,
}

// BodyDump returns a BodyDump middleware.
//
// BodyDump middleware captures the request and response payload and calls the
// registered handler.
func BodyDump(handler BodyDumpHandler) echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultBodyDumpConfig
        c.Handler = handler
        return BodyDumpWithConfig(c)
}</span>

// BodyDumpWithConfig returns a BodyDump middleware with config.
// See: `BodyDump()`.
func BodyDumpWithConfig(config BodyDumpConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Handler == nil </span><span class="cov8" title="1">{
                panic("echo: body-dump middleware requires a handler function")</span>
        }
        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultBodyDumpConfig.Skipper
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) (err error) </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        // Request
                        <span class="cov8" title="1">reqBody := []byte{}
                        if c.Request().Body != nil </span><span class="cov8" title="1">{ // Read
                                reqBody, _ = io.ReadAll(c.Request().Body)
                        }</span>
                        <span class="cov8" title="1">c.Request().Body = io.NopCloser(bytes.NewBuffer(reqBody)) // Reset

                        // Response
                        resBody := new(bytes.Buffer)
                        mw := io.MultiWriter(c.Response().Writer, resBody)
                        writer := &amp;bodyDumpResponseWriter{Writer: mw, ResponseWriter: c.Response().Writer}
                        c.Response().Writer = writer

                        if err = next(c); err != nil </span><span class="cov8" title="1">{
                                c.Error(err)
                        }</span>

                        // Callback
                        <span class="cov8" title="1">config.Handler(c, reqBody, resBody.Bytes())

                        return</span>
                }
        }
}

func (w *bodyDumpResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        w.ResponseWriter.WriteHeader(code)
}</span>

func (w *bodyDumpResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return w.Writer.Write(b)
}</span>

func (w *bodyDumpResponseWriter) Flush() <span class="cov8" title="1">{
        err := http.NewResponseController(w.ResponseWriter).Flush()
        if err != nil &amp;&amp; errors.Is(err, http.ErrNotSupported) </span><span class="cov8" title="1">{
                panic(errors.New("response writer flushing is not supported"))</span>
        }
}

func (w *bodyDumpResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        return http.NewResponseController(w.ResponseWriter).Hijack()
}</span>

func (w *bodyDumpResponseWriter) Unwrap() http.ResponseWriter <span class="cov8" title="1">{
        return w.ResponseWriter
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "fmt"
        "io"
        "sync"

        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/bytes"
)

// BodyLimitConfig defines the config for BodyLimit middleware.
type BodyLimitConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Maximum allowed size for a request body, it can be specified
        // as `4x` or `4xB`, where x is one of the multiple from K, M, G, T or P.
        Limit string `yaml:"limit"`
        limit int64
}

type limitedReader struct {
        BodyLimitConfig
        reader io.ReadCloser
        read   int64
}

// DefaultBodyLimitConfig is the default BodyLimit middleware config.
var DefaultBodyLimitConfig = BodyLimitConfig{
        Skipper: DefaultSkipper,
}

// BodyLimit returns a BodyLimit middleware.
//
// BodyLimit middleware sets the maximum allowed size for a request body, if the
// size exceeds the configured limit, it sends "413 - Request Entity Too Large"
// response. The BodyLimit is determined based on both `Content-Length` request
// header and actual content read, which makes it super secure.
// Limit can be specified as `4x` or `4xB`, where x is one of the multiple from K, M,
// G, T or P.
func BodyLimit(limit string) echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultBodyLimitConfig
        c.Limit = limit
        return BodyLimitWithConfig(c)
}</span>

// BodyLimitWithConfig returns a BodyLimit middleware with config.
// See: `BodyLimit()`.
func BodyLimitWithConfig(config BodyLimitConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultBodyLimitConfig.Skipper
        }</span>

        <span class="cov8" title="1">limit, err := bytes.Parse(config.Limit)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Errorf("echo: invalid body-limit=%s", config.Limit))</span>
        }
        <span class="cov8" title="1">config.limit = limit
        pool := limitedReaderPool(config)

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()

                        // Based on content length
                        if req.ContentLength &gt; config.limit </span><span class="cov8" title="1">{
                                return echo.ErrStatusRequestEntityTooLarge
                        }</span>

                        // Based on content read
                        <span class="cov8" title="1">r := pool.Get().(*limitedReader)
                        r.Reset(req.Body)
                        defer pool.Put(r)
                        req.Body = r

                        return next(c)</span>
                }
        }
}

func (r *limitedReader) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = r.reader.Read(b)
        r.read += int64(n)
        if r.read &gt; r.limit </span><span class="cov8" title="1">{
                return n, echo.ErrStatusRequestEntityTooLarge
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *limitedReader) Close() error <span class="cov0" title="0">{
        return r.reader.Close()
}</span>

func (r *limitedReader) Reset(reader io.ReadCloser) <span class="cov8" title="1">{
        r.reader = reader
        r.read = 0
}</span>

func limitedReaderPool(c BodyLimitConfig) sync.Pool <span class="cov8" title="1">{
        return sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return &amp;limitedReader{BodyLimitConfig: c}
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "bufio"
        "bytes"
        "compress/gzip"
        "io"
        "net"
        "net/http"
        "strings"
        "sync"

        "github.com/labstack/echo/v4"
)

// GzipConfig defines the config for Gzip middleware.
type GzipConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Gzip compression level.
        // Optional. Default value -1.
        Level int `yaml:"level"`

        // Length threshold before gzip compression is applied.
        // Optional. Default value 0.
        //
        // Most of the time you will not need to change the default. Compressing
        // a short response might increase the transmitted data because of the
        // gzip format overhead. Compressing the response will also consume CPU
        // and time on the server and the client (for decompressing). Depending on
        // your use case such a threshold might be useful.
        //
        // See also:
        // https://webmasters.stackexchange.com/questions/31750/what-is-recommended-minimum-object-size-for-gzip-performance-benefits
        MinLength int
}

type gzipResponseWriter struct {
        io.Writer
        http.ResponseWriter
        wroteHeader       bool
        wroteBody         bool
        minLength         int
        minLengthExceeded bool
        buffer            *bytes.Buffer
        code              int
}

const (
        gzipScheme = "gzip"
)

// DefaultGzipConfig is the default Gzip middleware config.
var DefaultGzipConfig = GzipConfig{
        Skipper:   DefaultSkipper,
        Level:     -1,
        MinLength: 0,
}

// Gzip returns a middleware which compresses HTTP response using gzip compression
// scheme.
func Gzip() echo.MiddlewareFunc <span class="cov8" title="1">{
        return GzipWithConfig(DefaultGzipConfig)
}</span>

// GzipWithConfig return Gzip middleware with config.
// See: `Gzip()`.
func GzipWithConfig(config GzipConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultGzipConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Level == 0 </span><span class="cov8" title="1">{
                config.Level = DefaultGzipConfig.Level
        }</span>
        <span class="cov8" title="1">if config.MinLength &lt; 0 </span><span class="cov0" title="0">{
                config.MinLength = DefaultGzipConfig.MinLength
        }</span>

        <span class="cov8" title="1">pool := gzipCompressPool(config)
        bpool := bufferPool()

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">res := c.Response()
                        res.Header().Add(echo.HeaderVary, echo.HeaderAcceptEncoding)
                        if strings.Contains(c.Request().Header.Get(echo.HeaderAcceptEncoding), gzipScheme) </span><span class="cov8" title="1">{
                                i := pool.Get()
                                w, ok := i.(*gzip.Writer)
                                if !ok </span><span class="cov8" title="1">{
                                        return echo.NewHTTPError(http.StatusInternalServerError, i.(error).Error())
                                }</span>
                                <span class="cov8" title="1">rw := res.Writer
                                w.Reset(rw)

                                buf := bpool.Get().(*bytes.Buffer)
                                buf.Reset()

                                grw := &amp;gzipResponseWriter{Writer: w, ResponseWriter: rw, minLength: config.MinLength, buffer: buf}
                                defer func() </span><span class="cov8" title="1">{
                                        // There are different reasons for cases when we have not yet written response to the client and now need to do so.
                                        // a) handler response had only response code and no response body (ala 404 or redirects etc). Response code need to be written now.
                                        // b) body is shorter than our minimum length threshold and being buffered currently and needs to be written
                                        if !grw.wroteBody </span><span class="cov8" title="1">{
                                                if res.Header().Get(echo.HeaderContentEncoding) == gzipScheme </span><span class="cov0" title="0">{
                                                        res.Header().Del(echo.HeaderContentEncoding)
                                                }</span>
                                                <span class="cov8" title="1">if grw.wroteHeader </span><span class="cov8" title="1">{
                                                        rw.WriteHeader(grw.code)
                                                }</span>
                                                // We have to reset response to it's pristine state when
                                                // nothing is written to body or error is returned.
                                                // See issue #424, #407.
                                                <span class="cov8" title="1">res.Writer = rw
                                                w.Reset(io.Discard)</span>
                                        } else<span class="cov8" title="1"> if !grw.minLengthExceeded </span><span class="cov8" title="1">{
                                                // Write uncompressed response
                                                res.Writer = rw
                                                if grw.wroteHeader </span><span class="cov8" title="1">{
                                                        grw.ResponseWriter.WriteHeader(grw.code)
                                                }</span>
                                                <span class="cov8" title="1">grw.buffer.WriteTo(rw)
                                                w.Reset(io.Discard)</span>
                                        }
                                        <span class="cov8" title="1">w.Close()
                                        bpool.Put(buf)
                                        pool.Put(w)</span>
                                }()
                                <span class="cov8" title="1">res.Writer = grw</span>
                        }
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

func (w *gzipResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        w.Header().Del(echo.HeaderContentLength) // Issue #444

        w.wroteHeader = true

        // Delay writing of the header until we know if we'll actually compress the response
        w.code = code
}</span>

func (w *gzipResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if w.Header().Get(echo.HeaderContentType) == "" </span><span class="cov8" title="1">{
                w.Header().Set(echo.HeaderContentType, http.DetectContentType(b))
        }</span>
        <span class="cov8" title="1">w.wroteBody = true

        if !w.minLengthExceeded </span><span class="cov8" title="1">{
                n, err := w.buffer.Write(b)

                if w.buffer.Len() &gt;= w.minLength </span><span class="cov8" title="1">{
                        w.minLengthExceeded = true

                        // The minimum length is exceeded, add Content-Encoding header and write the header
                        w.Header().Set(echo.HeaderContentEncoding, gzipScheme) // Issue #806
                        if w.wroteHeader </span><span class="cov8" title="1">{
                                w.ResponseWriter.WriteHeader(w.code)
                        }</span>

                        <span class="cov8" title="1">return w.Writer.Write(w.buffer.Bytes())</span>
                }

                <span class="cov8" title="1">return n, err</span>
        }

        <span class="cov8" title="1">return w.Writer.Write(b)</span>
}

func (w *gzipResponseWriter) Flush() <span class="cov8" title="1">{
        if !w.minLengthExceeded </span><span class="cov8" title="1">{
                // Enforce compression because we will not know how much more data will come
                w.minLengthExceeded = true
                w.Header().Set(echo.HeaderContentEncoding, gzipScheme) // Issue #806
                if w.wroteHeader </span><span class="cov8" title="1">{
                        w.ResponseWriter.WriteHeader(w.code)
                }</span>

                <span class="cov8" title="1">w.Writer.Write(w.buffer.Bytes())</span>
        }

        <span class="cov8" title="1">w.Writer.(*gzip.Writer).Flush()
        _ = http.NewResponseController(w.ResponseWriter).Flush()</span>
}

func (w *gzipResponseWriter) Unwrap() http.ResponseWriter <span class="cov8" title="1">{
        return w.ResponseWriter
}</span>

func (w *gzipResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        return http.NewResponseController(w.ResponseWriter).Hijack()
}</span>

func (w *gzipResponseWriter) Push(target string, opts *http.PushOptions) error <span class="cov0" title="0">{
        if p, ok := w.ResponseWriter.(http.Pusher); ok </span><span class="cov0" title="0">{
                return p.Push(target, opts)
        }</span>
        <span class="cov0" title="0">return http.ErrNotSupported</span>
}

func gzipCompressPool(config GzipConfig) sync.Pool <span class="cov8" title="1">{
        return sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        w, err := gzip.NewWriterLevel(io.Discard, config.Level)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return w</span>
                },
        }
}

func bufferPool() sync.Pool <span class="cov8" title="1">{
        return sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        b := &amp;bytes.Buffer{}
                        return b
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "context"
        "errors"
        "time"

        "github.com/labstack/echo/v4"
)

// ContextTimeoutConfig defines the config for ContextTimeout middleware.
type ContextTimeoutConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // ErrorHandler is a function when error aries in middleware execution.
        ErrorHandler func(err error, c echo.Context) error

        // Timeout configures a timeout for the middleware, defaults to 0 for no timeout
        Timeout time.Duration
}

// ContextTimeout returns a middleware which returns error (503 Service Unavailable error) to client
// when underlying method returns context.DeadlineExceeded error.
func ContextTimeout(timeout time.Duration) echo.MiddlewareFunc <span class="cov8" title="1">{
        return ContextTimeoutWithConfig(ContextTimeoutConfig{Timeout: timeout})
}</span>

// ContextTimeoutWithConfig returns a Timeout middleware with config.
func ContextTimeoutWithConfig(config ContextTimeoutConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        mw, err := config.ToMiddleware()
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return mw</span>
}

// ToMiddleware converts Config to middleware.
func (config ContextTimeoutConfig) ToMiddleware() (echo.MiddlewareFunc, error) <span class="cov8" title="1">{
        if config.Timeout == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("timeout must be set")
        }</span>
        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultSkipper
        }</span>
        <span class="cov8" title="1">if config.ErrorHandler == nil </span><span class="cov8" title="1">{
                config.ErrorHandler = func(err error, c echo.Context) error </span><span class="cov8" title="1">{
                        if err != nil &amp;&amp; errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                                return echo.ErrServiceUnavailable.WithInternal(err)
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">timeoutContext, cancel := context.WithTimeout(c.Request().Context(), config.Timeout)
                        defer cancel()

                        c.SetRequest(c.Request().WithContext(timeoutContext))

                        if err := next(c); err != nil </span><span class="cov8" title="1">{
                                return config.ErrorHandler(err, c)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }, nil
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "net/http"
        "regexp"
        "strconv"
        "strings"

        "github.com/labstack/echo/v4"
)

// CORSConfig defines the config for CORS middleware.
type CORSConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // AllowOrigins determines the value of the Access-Control-Allow-Origin
        // response header.  This header defines a list of origins that may access the
        // resource.  The wildcard characters '*' and '?' are supported and are
        // converted to regex fragments '.*' and '.' accordingly.
        //
        // Security: use extreme caution when handling the origin, and carefully
        // validate any logic. Remember that attackers may register hostile domain names.
        // See https://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html
        //
        // Optional. Default value []string{"*"}.
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
        AllowOrigins []string `yaml:"allow_origins"`

        // AllowOriginFunc is a custom function to validate the origin. It takes the
        // origin as an argument and returns true if allowed or false otherwise. If
        // an error is returned, it is returned by the handler. If this option is
        // set, AllowOrigins is ignored.
        //
        // Security: use extreme caution when handling the origin, and carefully
        // validate any logic. Remember that attackers may register hostile domain names.
        // See https://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html
        //
        // Optional.
        AllowOriginFunc func(origin string) (bool, error) `yaml:"-"`

        // AllowMethods determines the value of the Access-Control-Allow-Methods
        // response header.  This header specified the list of methods allowed when
        // accessing the resource.  This is used in response to a preflight request.
        //
        // Optional. Default value DefaultCORSConfig.AllowMethods.
        // If `allowMethods` is left empty, this middleware will fill for preflight
        // request `Access-Control-Allow-Methods` header value
        // from `Allow` header that echo.Router set into context.
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods
        AllowMethods []string `yaml:"allow_methods"`

        // AllowHeaders determines the value of the Access-Control-Allow-Headers
        // response header.  This header is used in response to a preflight request to
        // indicate which HTTP headers can be used when making the actual request.
        //
        // Optional. Default value []string{}.
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
        AllowHeaders []string `yaml:"allow_headers"`

        // AllowCredentials determines the value of the
        // Access-Control-Allow-Credentials response header.  This header indicates
        // whether or not the response to the request can be exposed when the
        // credentials mode (Request.credentials) is true. When used as part of a
        // response to a preflight request, this indicates whether or not the actual
        // request can be made using credentials.  See also
        // [MDN: Access-Control-Allow-Credentials].
        //
        // Optional. Default value false, in which case the header is not set.
        //
        // Security: avoid using `AllowCredentials = true` with `AllowOrigins = *`.
        // See "Exploiting CORS misconfigurations for Bitcoins and bounties",
        // https://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials
        AllowCredentials bool `yaml:"allow_credentials"`

        // UnsafeWildcardOriginWithAllowCredentials UNSAFE/INSECURE: allows wildcard '*' origin to be used with AllowCredentials
        // flag. In that case we consider any origin allowed and send it back to the client with `Access-Control-Allow-Origin` header.
        //
        // This is INSECURE and potentially leads to [cross-origin](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
        // attacks. See: https://github.com/labstack/echo/issues/2400 for discussion on the subject.
        //
        // Optional. Default value is false.
        UnsafeWildcardOriginWithAllowCredentials bool `yaml:"unsafe_wildcard_origin_with_allow_credentials"`

        // ExposeHeaders determines the value of Access-Control-Expose-Headers, which
        // defines a list of headers that clients are allowed to access.
        //
        // Optional. Default value []string{}, in which case the header is not set.
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Header
        ExposeHeaders []string `yaml:"expose_headers"`

        // MaxAge determines the value of the Access-Control-Max-Age response header.
        // This header indicates how long (in seconds) the results of a preflight
        // request can be cached.
        // The header is set only if MaxAge != 0, negative value sends "0" which instructs browsers not to cache that response.
        //
        // Optional. Default value 0 - meaning header is not sent.
        //
        // See also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age
        MaxAge int `yaml:"max_age"`
}

// DefaultCORSConfig is the default CORS middleware config.
var DefaultCORSConfig = CORSConfig{
        Skipper:      DefaultSkipper,
        AllowOrigins: []string{"*"},
        AllowMethods: []string{http.MethodGet, http.MethodHead, http.MethodPut, http.MethodPatch, http.MethodPost, http.MethodDelete},
}

// CORS returns a Cross-Origin Resource Sharing (CORS) middleware.
// See also [MDN: Cross-Origin Resource Sharing (CORS)].
//
// Security: Poorly configured CORS can compromise security because it allows
// relaxation of the browser's Same-Origin policy.  See [Exploiting CORS
// misconfigurations for Bitcoins and bounties] and [Portswigger: Cross-origin
// resource sharing (CORS)] for more details.
//
// [MDN: Cross-Origin Resource Sharing (CORS)]: https://developer.mozilla.org/en/docs/Web/HTTP/Access_control_CORS
// [Exploiting CORS misconfigurations for Bitcoins and bounties]: https://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html
// [Portswigger: Cross-origin resource sharing (CORS)]: https://portswigger.net/web-security/cors
func CORS() echo.MiddlewareFunc <span class="cov8" title="1">{
        return CORSWithConfig(DefaultCORSConfig)
}</span>

// CORSWithConfig returns a CORS middleware with config.
// See: [CORS].
func CORSWithConfig(config CORSConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultCORSConfig.Skipper
        }</span>
        <span class="cov8" title="1">if len(config.AllowOrigins) == 0 </span><span class="cov8" title="1">{
                config.AllowOrigins = DefaultCORSConfig.AllowOrigins
        }</span>
        <span class="cov8" title="1">hasCustomAllowMethods := true
        if len(config.AllowMethods) == 0 </span><span class="cov8" title="1">{
                hasCustomAllowMethods = false
                config.AllowMethods = DefaultCORSConfig.AllowMethods
        }</span>

        <span class="cov8" title="1">allowOriginPatterns := make([]*regexp.Regexp, 0, len(config.AllowOrigins))
        for _, origin := range config.AllowOrigins </span><span class="cov8" title="1">{
                if origin == "*" </span><span class="cov8" title="1">{
                        continue</span> // "*" is handled differently and does not need regexp
                }
                <span class="cov8" title="1">pattern := regexp.QuoteMeta(origin)
                pattern = strings.ReplaceAll(pattern, "\\*", ".*")
                pattern = strings.ReplaceAll(pattern, "\\?", ".")
                pattern = "^" + pattern + "$"

                re, err := regexp.Compile(pattern)
                if err != nil </span><span class="cov8" title="1">{
                        // this is to preserve previous behaviour - invalid patterns were just ignored.
                        // If we would turn this to panic, users with invalid patterns
                        // would have applications crashing in production due unrecovered panic.
                        // TODO: this should be turned to error/panic in `v5`
                        continue</span>
                }
                <span class="cov8" title="1">allowOriginPatterns = append(allowOriginPatterns, re)</span>
        }

        <span class="cov8" title="1">allowMethods := strings.Join(config.AllowMethods, ",")
        allowHeaders := strings.Join(config.AllowHeaders, ",")
        exposeHeaders := strings.Join(config.ExposeHeaders, ",")

        maxAge := "0"
        if config.MaxAge &gt; 0 </span><span class="cov8" title="1">{
                maxAge = strconv.Itoa(config.MaxAge)
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()
                        origin := req.Header.Get(echo.HeaderOrigin)
                        allowOrigin := ""

                        res.Header().Add(echo.HeaderVary, echo.HeaderOrigin)

                        // Preflight request is an OPTIONS request, using three HTTP request headers: Access-Control-Request-Method,
                        // Access-Control-Request-Headers, and the Origin header. See: https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
                        // For simplicity we just consider method type and later `Origin` header.
                        preflight := req.Method == http.MethodOptions

                        // Although router adds special handler in case of OPTIONS method we avoid calling next for OPTIONS in this middleware
                        // as CORS requests do not have cookies / authentication headers by default, so we could get stuck in auth
                        // middlewares by calling next(c).
                        // But we still want to send `Allow` header as response in case of Non-CORS OPTIONS request as router default
                        // handler does.
                        routerAllowMethods := ""
                        if preflight </span><span class="cov8" title="1">{
                                tmpAllowMethods, ok := c.Get(echo.ContextKeyHeaderAllow).(string)
                                if ok &amp;&amp; tmpAllowMethods != "" </span><span class="cov8" title="1">{
                                        routerAllowMethods = tmpAllowMethods
                                        c.Response().Header().Set(echo.HeaderAllow, routerAllowMethods)
                                }</span>
                        }

                        // No Origin provided. This is (probably) not request from actual browser - proceed executing middleware chain
                        <span class="cov8" title="1">if origin == "" </span><span class="cov8" title="1">{
                                if !preflight </span><span class="cov8" title="1">{
                                        return next(c)
                                }</span>
                                <span class="cov8" title="1">return c.NoContent(http.StatusNoContent)</span>
                        }

                        <span class="cov8" title="1">if config.AllowOriginFunc != nil </span><span class="cov8" title="1">{
                                allowed, err := config.AllowOriginFunc(origin)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                                        allowOrigin = origin
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Check allowed origins
                                for _, o := range config.AllowOrigins </span><span class="cov8" title="1">{
                                        if o == "*" &amp;&amp; config.AllowCredentials &amp;&amp; config.UnsafeWildcardOriginWithAllowCredentials </span><span class="cov8" title="1">{
                                                allowOrigin = origin
                                                break</span>
                                        }
                                        <span class="cov8" title="1">if o == "*" || o == origin </span><span class="cov8" title="1">{
                                                allowOrigin = o
                                                break</span>
                                        }
                                        <span class="cov8" title="1">if matchSubdomain(origin, o) </span><span class="cov8" title="1">{
                                                allowOrigin = origin
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">checkPatterns := false
                                if allowOrigin == "" </span><span class="cov8" title="1">{
                                        // to avoid regex cost by invalid (long) domains (253 is domain name max limit)
                                        if len(origin) &lt;= (253+3+5) &amp;&amp; strings.Contains(origin, "://") </span><span class="cov8" title="1">{
                                                checkPatterns = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if checkPatterns </span><span class="cov8" title="1">{
                                        for _, re := range allowOriginPatterns </span><span class="cov8" title="1">{
                                                if match := re.MatchString(origin); match </span><span class="cov8" title="1">{
                                                        allowOrigin = origin
                                                        break</span>
                                                }
                                        }
                                }
                        }

                        // Origin not allowed
                        <span class="cov8" title="1">if allowOrigin == "" </span><span class="cov8" title="1">{
                                if !preflight </span><span class="cov8" title="1">{
                                        return echo.ErrUnauthorized
                                }</span>
                                <span class="cov8" title="1">return c.NoContent(http.StatusNoContent)</span>
                        }

                        <span class="cov8" title="1">res.Header().Set(echo.HeaderAccessControlAllowOrigin, allowOrigin)
                        if config.AllowCredentials </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderAccessControlAllowCredentials, "true")
                        }</span>

                        // Simple request
                        <span class="cov8" title="1">if !preflight </span><span class="cov8" title="1">{
                                if exposeHeaders != "" </span><span class="cov0" title="0">{
                                        res.Header().Set(echo.HeaderAccessControlExposeHeaders, exposeHeaders)
                                }</span>
                                <span class="cov8" title="1">return next(c)</span>
                        }

                        // Preflight request
                        <span class="cov8" title="1">res.Header().Add(echo.HeaderVary, echo.HeaderAccessControlRequestMethod)
                        res.Header().Add(echo.HeaderVary, echo.HeaderAccessControlRequestHeaders)

                        if !hasCustomAllowMethods &amp;&amp; routerAllowMethods != "" </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderAccessControlAllowMethods, routerAllowMethods)
                        }</span> else<span class="cov8" title="1"> {
                                res.Header().Set(echo.HeaderAccessControlAllowMethods, allowMethods)
                        }</span>

                        <span class="cov8" title="1">if allowHeaders != "" </span><span class="cov0" title="0">{
                                res.Header().Set(echo.HeaderAccessControlAllowHeaders, allowHeaders)
                        }</span> else<span class="cov8" title="1"> {
                                h := req.Header.Get(echo.HeaderAccessControlRequestHeaders)
                                if h != "" </span><span class="cov8" title="1">{
                                        res.Header().Set(echo.HeaderAccessControlAllowHeaders, h)
                                }</span>
                        }
                        <span class="cov8" title="1">if config.MaxAge != 0 </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderAccessControlMaxAge, maxAge)
                        }</span>
                        <span class="cov8" title="1">return c.NoContent(http.StatusNoContent)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "crypto/subtle"
        "net/http"
        "time"

        "github.com/labstack/echo/v4"
)

// CSRFConfig defines the config for CSRF middleware.
type CSRFConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // TokenLength is the length of the generated token.
        TokenLength uint8 `yaml:"token_length"`
        // Optional. Default value 32.

        // TokenLookup is a string in the form of "&lt;source&gt;:&lt;name&gt;" or "&lt;source&gt;:&lt;name&gt;,&lt;source&gt;:&lt;name&gt;" that is used
        // to extract token from the request.
        // Optional. Default value "header:X-CSRF-Token".
        // Possible values:
        // - "header:&lt;name&gt;" or "header:&lt;name&gt;:&lt;cut-prefix&gt;"
        // - "query:&lt;name&gt;"
        // - "form:&lt;name&gt;"
        // Multiple sources example:
        // - "header:X-CSRF-Token,query:csrf"
        TokenLookup string `yaml:"token_lookup"`

        // Context key to store generated CSRF token into context.
        // Optional. Default value "csrf".
        ContextKey string `yaml:"context_key"`

        // Name of the CSRF cookie. This cookie will store CSRF token.
        // Optional. Default value "csrf".
        CookieName string `yaml:"cookie_name"`

        // Domain of the CSRF cookie.
        // Optional. Default value none.
        CookieDomain string `yaml:"cookie_domain"`

        // Path of the CSRF cookie.
        // Optional. Default value none.
        CookiePath string `yaml:"cookie_path"`

        // Max age (in seconds) of the CSRF cookie.
        // Optional. Default value 86400 (24hr).
        CookieMaxAge int `yaml:"cookie_max_age"`

        // Indicates if CSRF cookie is secure.
        // Optional. Default value false.
        CookieSecure bool `yaml:"cookie_secure"`

        // Indicates if CSRF cookie is HTTP only.
        // Optional. Default value false.
        CookieHTTPOnly bool `yaml:"cookie_http_only"`

        // Indicates SameSite mode of the CSRF cookie.
        // Optional. Default value SameSiteDefaultMode.
        CookieSameSite http.SameSite `yaml:"cookie_same_site"`

        // ErrorHandler defines a function which is executed for returning custom errors.
        ErrorHandler CSRFErrorHandler
}

// CSRFErrorHandler is a function which is executed for creating custom errors.
type CSRFErrorHandler func(err error, c echo.Context) error

// ErrCSRFInvalid is returned when CSRF check fails
var ErrCSRFInvalid = echo.NewHTTPError(http.StatusForbidden, "invalid csrf token")

// DefaultCSRFConfig is the default CSRF middleware config.
var DefaultCSRFConfig = CSRFConfig{
        Skipper:        DefaultSkipper,
        TokenLength:    32,
        TokenLookup:    "header:" + echo.HeaderXCSRFToken,
        ContextKey:     "csrf",
        CookieName:     "_csrf",
        CookieMaxAge:   86400,
        CookieSameSite: http.SameSiteDefaultMode,
}

// CSRF returns a Cross-Site Request Forgery (CSRF) middleware.
// See: https://en.wikipedia.org/wiki/Cross-site_request_forgery
func CSRF() echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultCSRFConfig
        return CSRFWithConfig(c)
}</span>

// CSRFWithConfig returns a CSRF middleware with config.
// See `CSRF()`.
func CSRFWithConfig(config CSRFConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultCSRFConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.TokenLength == 0 </span><span class="cov8" title="1">{
                config.TokenLength = DefaultCSRFConfig.TokenLength
        }</span>

        <span class="cov8" title="1">if config.TokenLookup == "" </span><span class="cov8" title="1">{
                config.TokenLookup = DefaultCSRFConfig.TokenLookup
        }</span>
        <span class="cov8" title="1">if config.ContextKey == "" </span><span class="cov8" title="1">{
                config.ContextKey = DefaultCSRFConfig.ContextKey
        }</span>
        <span class="cov8" title="1">if config.CookieName == "" </span><span class="cov8" title="1">{
                config.CookieName = DefaultCSRFConfig.CookieName
        }</span>
        <span class="cov8" title="1">if config.CookieMaxAge == 0 </span><span class="cov8" title="1">{
                config.CookieMaxAge = DefaultCSRFConfig.CookieMaxAge
        }</span>
        <span class="cov8" title="1">if config.CookieSameSite == http.SameSiteNoneMode </span><span class="cov8" title="1">{
                config.CookieSecure = true
        }</span>

        <span class="cov8" title="1">extractors, cErr := CreateExtractors(config.TokenLookup)
        if cErr != nil </span><span class="cov0" title="0">{
                panic(cErr)</span>
        }

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">token := ""
                        if k, err := c.Cookie(config.CookieName); err != nil </span><span class="cov8" title="1">{
                                token = randomString(config.TokenLength)
                        }</span> else<span class="cov8" title="1"> {
                                token = k.Value // Reuse token
                        }</span>

                        <span class="cov8" title="1">switch c.Request().Method </span>{
                        case http.MethodGet, http.MethodHead, http.MethodOptions, http.MethodTrace:<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1">
                                // Validate token only for requests which are not defined as 'safe' by RFC7231
                                var lastExtractorErr error
                                var lastTokenErr error
                        outer:
                                for _, extractor := range extractors </span><span class="cov8" title="1">{
                                        clientTokens, err := extractor(c)
                                        if err != nil </span><span class="cov8" title="1">{
                                                lastExtractorErr = err
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">for _, clientToken := range clientTokens </span><span class="cov8" title="1">{
                                                if validateCSRFToken(token, clientToken) </span><span class="cov8" title="1">{
                                                        lastTokenErr = nil
                                                        lastExtractorErr = nil
                                                        break outer</span>
                                                }
                                                <span class="cov8" title="1">lastTokenErr = ErrCSRFInvalid</span>
                                        }
                                }
                                <span class="cov8" title="1">var finalErr error
                                if lastTokenErr != nil </span><span class="cov8" title="1">{
                                        finalErr = lastTokenErr
                                }</span> else<span class="cov8" title="1"> if lastExtractorErr != nil </span><span class="cov8" title="1">{
                                        // ugly part to preserve backwards compatible errors. someone could rely on them
                                        if lastExtractorErr == errQueryExtractorValueMissing </span><span class="cov8" title="1">{
                                                lastExtractorErr = echo.NewHTTPError(http.StatusBadRequest, "missing csrf token in the query string")
                                        }</span> else<span class="cov8" title="1"> if lastExtractorErr == errFormExtractorValueMissing </span><span class="cov8" title="1">{
                                                lastExtractorErr = echo.NewHTTPError(http.StatusBadRequest, "missing csrf token in the form parameter")
                                        }</span> else<span class="cov8" title="1"> if lastExtractorErr == errHeaderExtractorValueMissing </span><span class="cov8" title="1">{
                                                lastExtractorErr = echo.NewHTTPError(http.StatusBadRequest, "missing csrf token in request header")
                                        }</span> else<span class="cov0" title="0"> {
                                                lastExtractorErr = echo.NewHTTPError(http.StatusBadRequest, lastExtractorErr.Error())
                                        }</span>
                                        <span class="cov8" title="1">finalErr = lastExtractorErr</span>
                                }

                                <span class="cov8" title="1">if finalErr != nil </span><span class="cov8" title="1">{
                                        if config.ErrorHandler != nil </span><span class="cov8" title="1">{
                                                return config.ErrorHandler(finalErr, c)
                                        }</span>
                                        <span class="cov8" title="1">return finalErr</span>
                                }
                        }

                        // Set CSRF cookie
                        <span class="cov8" title="1">cookie := new(http.Cookie)
                        cookie.Name = config.CookieName
                        cookie.Value = token
                        if config.CookiePath != "" </span><span class="cov0" title="0">{
                                cookie.Path = config.CookiePath
                        }</span>
                        <span class="cov8" title="1">if config.CookieDomain != "" </span><span class="cov0" title="0">{
                                cookie.Domain = config.CookieDomain
                        }</span>
                        <span class="cov8" title="1">if config.CookieSameSite != http.SameSiteDefaultMode </span><span class="cov8" title="1">{
                                cookie.SameSite = config.CookieSameSite
                        }</span>
                        <span class="cov8" title="1">cookie.Expires = time.Now().Add(time.Duration(config.CookieMaxAge) * time.Second)
                        cookie.Secure = config.CookieSecure
                        cookie.HttpOnly = config.CookieHTTPOnly
                        c.SetCookie(cookie)

                        // Store token in the context
                        c.Set(config.ContextKey, token)

                        // Protect clients from caching the response
                        c.Response().Header().Add(echo.HeaderVary, echo.HeaderCookie)

                        return next(c)</span>
                }
        }
}

func validateCSRFToken(token, clientToken string) bool <span class="cov8" title="1">{
        return subtle.ConstantTimeCompare([]byte(token), []byte(clientToken)) == 1
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "compress/gzip"
        "io"
        "net/http"
        "sync"

        "github.com/labstack/echo/v4"
)

// DecompressConfig defines the config for Decompress middleware.
type DecompressConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // GzipDecompressPool defines an interface to provide the sync.Pool used to create/store Gzip readers
        GzipDecompressPool Decompressor
}

// GZIPEncoding content-encoding header if set to "gzip", decompress body contents.
const GZIPEncoding string = "gzip"

// Decompressor is used to get the sync.Pool used by the middleware to get Gzip readers
type Decompressor interface {
        gzipDecompressPool() sync.Pool
}

// DefaultDecompressConfig defines the config for decompress middleware
var DefaultDecompressConfig = DecompressConfig{
        Skipper:            DefaultSkipper,
        GzipDecompressPool: &amp;DefaultGzipDecompressPool{},
}

// DefaultGzipDecompressPool is the default implementation of Decompressor interface
type DefaultGzipDecompressPool struct {
}

func (d *DefaultGzipDecompressPool) gzipDecompressPool() sync.Pool <span class="cov8" title="1">{
        return sync.Pool{New: func() interface{} </span><span class="cov8" title="1">{ return new(gzip.Reader) }</span>}
}

// Decompress decompresses request body based if content encoding type is set to "gzip" with default config
func Decompress() echo.MiddlewareFunc <span class="cov8" title="1">{
        return DecompressWithConfig(DefaultDecompressConfig)
}</span>

// DecompressWithConfig decompresses request body based if content encoding type is set to "gzip" with config
func DecompressWithConfig(config DecompressConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultGzipConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.GzipDecompressPool == nil </span><span class="cov8" title="1">{
                config.GzipDecompressPool = DefaultDecompressConfig.GzipDecompressPool
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                pool := config.GzipDecompressPool.gzipDecompressPool()

                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">if c.Request().Header.Get(echo.HeaderContentEncoding) != GZIPEncoding </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">i := pool.Get()
                        gr, ok := i.(*gzip.Reader)
                        if !ok || gr == nil </span><span class="cov8" title="1">{
                                return echo.NewHTTPError(http.StatusInternalServerError, i.(error).Error())
                        }</span>
                        <span class="cov8" title="1">defer pool.Put(gr)

                        b := c.Request().Body
                        defer b.Close()

                        if err := gr.Reset(b); err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov8" title="1">{ //ignore if body is empty
                                        return next(c)
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        // only Close gzip reader if it was set to a proper gzip source otherwise it will panic on close.
                        <span class="cov8" title="1">defer gr.Close()

                        c.Request().Body = gr

                        return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "net/textproto"
        "strings"
)

const (
        // extractorLimit is arbitrary number to limit values extractor can return. this limits possible resource exhaustion
        // attack vector
        extractorLimit = 20
)

var errHeaderExtractorValueMissing = errors.New("missing value in request header")
var errHeaderExtractorValueInvalid = errors.New("invalid value in request header")
var errQueryExtractorValueMissing = errors.New("missing value in the query string")
var errParamExtractorValueMissing = errors.New("missing value in path params")
var errCookieExtractorValueMissing = errors.New("missing value in cookies")
var errFormExtractorValueMissing = errors.New("missing value in the form")

// ValuesExtractor defines a function for extracting values (keys/tokens) from the given context.
type ValuesExtractor func(c echo.Context) ([]string, error)

// CreateExtractors creates ValuesExtractors from given lookups.
// Lookups is a string in the form of "&lt;source&gt;:&lt;name&gt;" or "&lt;source&gt;:&lt;name&gt;,&lt;source&gt;:&lt;name&gt;" that is used
// to extract key from the request.
// Possible values:
//   - "header:&lt;name&gt;" or "header:&lt;name&gt;:&lt;cut-prefix&gt;"
//     `&lt;cut-prefix&gt;` is argument value to cut/trim prefix of the extracted value. This is useful if header
//     value has static prefix like `Authorization: &lt;auth-scheme&gt; &lt;authorisation-parameters&gt;` where part that we
//     want to cut is `&lt;auth-scheme&gt; ` note the space at the end.
//     In case of basic authentication `Authorization: Basic &lt;credentials&gt;` prefix we want to remove is `Basic `.
//   - "query:&lt;name&gt;"
//   - "param:&lt;name&gt;"
//   - "form:&lt;name&gt;"
//   - "cookie:&lt;name&gt;"
//
// Multiple sources example:
// - "header:Authorization,header:X-Api-Key"
func CreateExtractors(lookups string) ([]ValuesExtractor, error) <span class="cov8" title="1">{
        return createExtractors(lookups, "")
}</span>

func createExtractors(lookups string, authScheme string) ([]ValuesExtractor, error) <span class="cov8" title="1">{
        if lookups == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">sources := strings.Split(lookups, ",")
        var extractors = make([]ValuesExtractor, 0)
        for _, source := range sources </span><span class="cov8" title="1">{
                parts := strings.Split(source, ":")
                if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("extractor source for lookup could not be split into needed parts: %v", source)
                }</span>

                <span class="cov8" title="1">switch parts[0] </span>{
                case "query":<span class="cov8" title="1">
                        extractors = append(extractors, valuesFromQuery(parts[1]))</span>
                case "param":<span class="cov8" title="1">
                        extractors = append(extractors, valuesFromParam(parts[1]))</span>
                case "cookie":<span class="cov8" title="1">
                        extractors = append(extractors, valuesFromCookie(parts[1]))</span>
                case "form":<span class="cov8" title="1">
                        extractors = append(extractors, valuesFromForm(parts[1]))</span>
                case "header":<span class="cov8" title="1">
                        prefix := ""
                        if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                                prefix = parts[2]
                        }</span> else<span class="cov8" title="1"> if authScheme != "" &amp;&amp; parts[1] == echo.HeaderAuthorization </span><span class="cov8" title="1">{
                                // backwards compatibility for JWT and KeyAuth:
                                // * we only apply this fix to Authorization as header we use and uses prefixes like "Bearer &lt;token-value&gt;" etc
                                // * previously header extractor assumed that auth-scheme/prefix had a space as suffix we need to retain that
                                //   behaviour for default values and Authorization header.
                                prefix = authScheme
                                if !strings.HasSuffix(prefix, " ") </span><span class="cov8" title="1">{
                                        prefix += " "
                                }</span>
                        }
                        <span class="cov8" title="1">extractors = append(extractors, valuesFromHeader(parts[1], prefix))</span>
                }
        }
        <span class="cov8" title="1">return extractors, nil</span>
}

// valuesFromHeader returns a functions that extracts values from the request header.
// valuePrefix is parameter to remove first part (prefix) of the extracted value. This is useful if header value has static
// prefix like `Authorization: &lt;auth-scheme&gt; &lt;authorisation-parameters&gt;` where part that we want to remove is `&lt;auth-scheme&gt; `
// note the space at the end. In case of basic authentication `Authorization: Basic &lt;credentials&gt;` prefix we want to remove
// is `Basic `. In case of JWT tokens `Authorization: Bearer &lt;token&gt;` prefix is `Bearer `.
// If prefix is left empty the whole value is returned.
func valuesFromHeader(header string, valuePrefix string) ValuesExtractor <span class="cov8" title="1">{
        prefixLen := len(valuePrefix)
        // standard library parses http.Request header keys in canonical form but we may provide something else so fix this
        header = textproto.CanonicalMIMEHeaderKey(header)
        return func(c echo.Context) ([]string, error) </span><span class="cov8" title="1">{
                values := c.Request().Header.Values(header)
                if len(values) == 0 </span><span class="cov8" title="1">{
                        return nil, errHeaderExtractorValueMissing
                }</span>

                <span class="cov8" title="1">result := make([]string, 0)
                for i, value := range values </span><span class="cov8" title="1">{
                        if prefixLen == 0 </span><span class="cov8" title="1">{
                                result = append(result, value)
                                if i &gt;= extractorLimit-1 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">if len(value) &gt; prefixLen &amp;&amp; strings.EqualFold(value[:prefixLen], valuePrefix) </span><span class="cov8" title="1">{
                                result = append(result, value[prefixLen:])
                                if i &gt;= extractorLimit-1 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if len(result) == 0 </span><span class="cov8" title="1">{
                        if prefixLen &gt; 0 </span><span class="cov8" title="1">{
                                return nil, errHeaderExtractorValueInvalid
                        }</span>
                        <span class="cov0" title="0">return nil, errHeaderExtractorValueMissing</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
}

// valuesFromQuery returns a function that extracts values from the query string.
func valuesFromQuery(param string) ValuesExtractor <span class="cov8" title="1">{
        return func(c echo.Context) ([]string, error) </span><span class="cov8" title="1">{
                result := c.QueryParams()[param]
                if len(result) == 0 </span><span class="cov8" title="1">{
                        return nil, errQueryExtractorValueMissing
                }</span> else<span class="cov8" title="1"> if len(result) &gt; extractorLimit-1 </span><span class="cov8" title="1">{
                        result = result[:extractorLimit]
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

// valuesFromParam returns a function that extracts values from the url param string.
func valuesFromParam(param string) ValuesExtractor <span class="cov8" title="1">{
        return func(c echo.Context) ([]string, error) </span><span class="cov8" title="1">{
                result := make([]string, 0)
                paramVales := c.ParamValues()
                for i, p := range c.ParamNames() </span><span class="cov8" title="1">{
                        if param == p </span><span class="cov8" title="1">{
                                result = append(result, paramVales[i])
                                if i &gt;= extractorLimit-1 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if len(result) == 0 </span><span class="cov8" title="1">{
                        return nil, errParamExtractorValueMissing
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

// valuesFromCookie returns a function that extracts values from the named cookie.
func valuesFromCookie(name string) ValuesExtractor <span class="cov8" title="1">{
        return func(c echo.Context) ([]string, error) </span><span class="cov8" title="1">{
                cookies := c.Cookies()
                if len(cookies) == 0 </span><span class="cov8" title="1">{
                        return nil, errCookieExtractorValueMissing
                }</span>

                <span class="cov8" title="1">result := make([]string, 0)
                for i, cookie := range cookies </span><span class="cov8" title="1">{
                        if name == cookie.Name </span><span class="cov8" title="1">{
                                result = append(result, cookie.Value)
                                if i &gt;= extractorLimit-1 </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if len(result) == 0 </span><span class="cov8" title="1">{
                        return nil, errCookieExtractorValueMissing
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

// valuesFromForm returns a function that extracts values from the form field.
func valuesFromForm(name string) ValuesExtractor <span class="cov8" title="1">{
        return func(c echo.Context) ([]string, error) </span><span class="cov8" title="1">{
                if c.Request().Form == nil </span><span class="cov8" title="1">{
                        _ = c.Request().ParseMultipartForm(32 &lt;&lt; 20) // same what `c.Request().FormValue(name)` does
                }</span>
                <span class="cov8" title="1">values := c.Request().Form[name]
                if len(values) == 0 </span><span class="cov8" title="1">{
                        return nil, errFormExtractorValueMissing
                }</span>
                <span class="cov8" title="1">if len(values) &gt; extractorLimit-1 </span><span class="cov8" title="1">{
                        values = values[:extractorLimit]
                }</span>
                <span class="cov8" title="1">result := append([]string{}, values...)
                return result, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "errors"
        "github.com/labstack/echo/v4"
        "net/http"
)

// KeyAuthConfig defines the config for KeyAuth middleware.
type KeyAuthConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // KeyLookup is a string in the form of "&lt;source&gt;:&lt;name&gt;" or "&lt;source&gt;:&lt;name&gt;,&lt;source&gt;:&lt;name&gt;" that is used
        // to extract key from the request.
        // Optional. Default value "header:Authorization".
        // Possible values:
        // - "header:&lt;name&gt;" or "header:&lt;name&gt;:&lt;cut-prefix&gt;"
        //                         `&lt;cut-prefix&gt;` is argument value to cut/trim prefix of the extracted value. This is useful if header
        //                        value has static prefix like `Authorization: &lt;auth-scheme&gt; &lt;authorisation-parameters&gt;` where part that we
        //                        want to cut is `&lt;auth-scheme&gt; ` note the space at the end.
        //                        In case of basic authentication `Authorization: Basic &lt;credentials&gt;` prefix we want to remove is `Basic `.
        // - "query:&lt;name&gt;"
        // - "form:&lt;name&gt;"
        // - "cookie:&lt;name&gt;"
        // Multiple sources example:
        // - "header:Authorization,header:X-Api-Key"
        KeyLookup string

        // AuthScheme to be used in the Authorization header.
        // Optional. Default value "Bearer".
        AuthScheme string

        // Validator is a function to validate key.
        // Required.
        Validator KeyAuthValidator

        // ErrorHandler defines a function which is executed for an invalid key.
        // It may be used to define a custom error.
        ErrorHandler KeyAuthErrorHandler

        // ContinueOnIgnoredError allows the next middleware/handler to be called when ErrorHandler decides to
        // ignore the error (by returning `nil`).
        // This is useful when parts of your site/api allow public access and some authorized routes provide extra functionality.
        // In that case you can use ErrorHandler to set a default public key auth value in the request context
        // and continue. Some logic down the remaining execution chain needs to check that (public) key auth value then.
        ContinueOnIgnoredError bool
}

// KeyAuthValidator defines a function to validate KeyAuth credentials.
type KeyAuthValidator func(auth string, c echo.Context) (bool, error)

// KeyAuthErrorHandler defines a function which is executed for an invalid key.
type KeyAuthErrorHandler func(err error, c echo.Context) error

// ErrKeyAuthMissing is error type when KeyAuth middleware is unable to extract value from lookups
type ErrKeyAuthMissing struct {
        Err error
}

// DefaultKeyAuthConfig is the default KeyAuth middleware config.
var DefaultKeyAuthConfig = KeyAuthConfig{
        Skipper:    DefaultSkipper,
        KeyLookup:  "header:" + echo.HeaderAuthorization,
        AuthScheme: "Bearer",
}

// Error returns errors text
func (e *ErrKeyAuthMissing) Error() string <span class="cov8" title="1">{
        return e.Err.Error()
}</span>

// Unwrap unwraps error
func (e *ErrKeyAuthMissing) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// KeyAuth returns an KeyAuth middleware.
//
// For valid key it calls the next handler.
// For invalid key, it sends "401 - Unauthorized" response.
// For missing key, it sends "400 - Bad Request" response.
func KeyAuth(fn KeyAuthValidator) echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultKeyAuthConfig
        c.Validator = fn
        return KeyAuthWithConfig(c)
}</span>

// KeyAuthWithConfig returns an KeyAuth middleware with config.
// See `KeyAuth()`.
func KeyAuthWithConfig(config KeyAuthConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultKeyAuthConfig.Skipper
        }</span>
        // Defaults
        <span class="cov8" title="1">if config.AuthScheme == "" </span><span class="cov8" title="1">{
                config.AuthScheme = DefaultKeyAuthConfig.AuthScheme
        }</span>
        <span class="cov8" title="1">if config.KeyLookup == "" </span><span class="cov8" title="1">{
                config.KeyLookup = DefaultKeyAuthConfig.KeyLookup
        }</span>
        <span class="cov8" title="1">if config.Validator == nil </span><span class="cov8" title="1">{
                panic("echo: key-auth middleware requires a validator function")</span>
        }

        <span class="cov8" title="1">extractors, cErr := createExtractors(config.KeyLookup, config.AuthScheme)
        if cErr != nil </span><span class="cov8" title="1">{
                panic(cErr)</span>
        }

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">var lastExtractorErr error
                        var lastValidatorErr error
                        for _, extractor := range extractors </span><span class="cov8" title="1">{
                                keys, err := extractor(c)
                                if err != nil </span><span class="cov8" title="1">{
                                        lastExtractorErr = err
                                        continue</span>
                                }
                                <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                                        valid, err := config.Validator(key, c)
                                        if err != nil </span><span class="cov8" title="1">{
                                                lastValidatorErr = err
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                                                return next(c)
                                        }</span>
                                        <span class="cov8" title="1">lastValidatorErr = errors.New("invalid key")</span>
                                }
                        }

                        // we are here only when we did not successfully extract and validate any of keys
                        <span class="cov8" title="1">err := lastValidatorErr
                        if err == nil </span><span class="cov8" title="1">{ // prioritize validator errors over extracting errors
                                // ugly part to preserve backwards compatible errors. someone could rely on them
                                if lastExtractorErr == errQueryExtractorValueMissing </span><span class="cov8" title="1">{
                                        err = errors.New("missing key in the query string")
                                }</span> else<span class="cov8" title="1"> if lastExtractorErr == errCookieExtractorValueMissing </span><span class="cov8" title="1">{
                                        err = errors.New("missing key in cookies")
                                }</span> else<span class="cov8" title="1"> if lastExtractorErr == errFormExtractorValueMissing </span><span class="cov8" title="1">{
                                        err = errors.New("missing key in the form")
                                }</span> else<span class="cov8" title="1"> if lastExtractorErr == errHeaderExtractorValueMissing </span><span class="cov8" title="1">{
                                        err = errors.New("missing key in request header")
                                }</span> else<span class="cov8" title="1"> if lastExtractorErr == errHeaderExtractorValueInvalid </span><span class="cov8" title="1">{
                                        err = errors.New("invalid key in the request header")
                                }</span> else<span class="cov0" title="0"> {
                                        err = lastExtractorErr
                                }</span>
                                <span class="cov8" title="1">err = &amp;ErrKeyAuthMissing{Err: err}</span>
                        }

                        <span class="cov8" title="1">if config.ErrorHandler != nil </span><span class="cov8" title="1">{
                                tmpErr := config.ErrorHandler(err, c)
                                if config.ContinueOnIgnoredError &amp;&amp; tmpErr == nil </span><span class="cov8" title="1">{
                                        return next(c)
                                }</span>
                                <span class="cov8" title="1">return tmpErr</span>
                        }
                        <span class="cov8" title="1">if lastValidatorErr != nil </span><span class="cov8" title="1">{ // prioritize validator errors over extracting errors
                                return &amp;echo.HTTPError{
                                        Code:     http.StatusUnauthorized,
                                        Message:  "Unauthorized",
                                        Internal: lastValidatorErr,
                                }
                        }</span>
                        <span class="cov8" title="1">return echo.NewHTTPError(http.StatusBadRequest, err.Error())</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "bytes"
        "encoding/json"
        "io"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/color"
        "github.com/valyala/fasttemplate"
)

// LoggerConfig defines the config for Logger middleware.
type LoggerConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Tags to construct the logger format.
        //
        // - time_unix
        // - time_unix_milli
        // - time_unix_micro
        // - time_unix_nano
        // - time_rfc3339
        // - time_rfc3339_nano
        // - time_custom
        // - id (Request ID)
        // - remote_ip
        // - uri
        // - host
        // - method
        // - path
        // - route
        // - protocol
        // - referer
        // - user_agent
        // - status
        // - error
        // - latency (In nanoseconds)
        // - latency_human (Human readable)
        // - bytes_in (Bytes received)
        // - bytes_out (Bytes sent)
        // - header:&lt;NAME&gt;
        // - query:&lt;NAME&gt;
        // - form:&lt;NAME&gt;
        // - custom (see CustomTagFunc field)
        //
        // Example "${remote_ip} ${status}"
        //
        // Optional. Default value DefaultLoggerConfig.Format.
        Format string `yaml:"format"`

        // Optional. Default value DefaultLoggerConfig.CustomTimeFormat.
        CustomTimeFormat string `yaml:"custom_time_format"`

        // CustomTagFunc is function called for `${custom}` tag to output user implemented text by writing it to buf.
        // Make sure that outputted text creates valid JSON string with other logged tags.
        // Optional.
        CustomTagFunc func(c echo.Context, buf *bytes.Buffer) (int, error)

        // Output is a writer where logs in JSON format are written.
        // Optional. Default value os.Stdout.
        Output io.Writer

        template *fasttemplate.Template
        colorer  *color.Color
        pool     *sync.Pool
}

// DefaultLoggerConfig is the default Logger middleware config.
var DefaultLoggerConfig = LoggerConfig{
        Skipper: DefaultSkipper,
        Format: `{"time":"${time_rfc3339_nano}","id":"${id}","remote_ip":"${remote_ip}",` +
                `"host":"${host}","method":"${method}","uri":"${uri}","user_agent":"${user_agent}",` +
                `"status":${status},"error":"${error}","latency":${latency},"latency_human":"${latency_human}"` +
                `,"bytes_in":${bytes_in},"bytes_out":${bytes_out}}` + "\n",
        CustomTimeFormat: "2006-01-02 15:04:05.00000",
        colorer:          color.New(),
}

// Logger returns a middleware that logs HTTP requests.
func Logger() echo.MiddlewareFunc <span class="cov8" title="1">{
        return LoggerWithConfig(DefaultLoggerConfig)
}</span>

// LoggerWithConfig returns a Logger middleware with config.
// See: `Logger()`.
func LoggerWithConfig(config LoggerConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultLoggerConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Format == "" </span><span class="cov0" title="0">{
                config.Format = DefaultLoggerConfig.Format
        }</span>
        <span class="cov8" title="1">if config.Output == nil </span><span class="cov8" title="1">{
                config.Output = DefaultLoggerConfig.Output
        }</span>

        <span class="cov8" title="1">config.template = fasttemplate.New(config.Format, "${", "}")
        config.colorer = color.New()
        config.colorer.SetOutput(config.Output)
        config.pool = &amp;sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return bytes.NewBuffer(make([]byte, 256))
                }</span>,
        }

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) (err error) </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()
                        start := time.Now()
                        if err = next(c); err != nil </span><span class="cov8" title="1">{
                                c.Error(err)
                        }</span>
                        <span class="cov8" title="1">stop := time.Now()
                        buf := config.pool.Get().(*bytes.Buffer)
                        buf.Reset()
                        defer config.pool.Put(buf)

                        if _, err = config.template.ExecuteFunc(buf, func(w io.Writer, tag string) (int, error) </span><span class="cov8" title="1">{
                                switch tag </span>{
                                case "custom":<span class="cov8" title="1">
                                        if config.CustomTagFunc == nil </span><span class="cov0" title="0">{
                                                return 0, nil
                                        }</span>
                                        <span class="cov8" title="1">return config.CustomTagFunc(c, buf)</span>
                                case "time_unix":<span class="cov0" title="0">
                                        return buf.WriteString(strconv.FormatInt(time.Now().Unix(), 10))</span>
                                case "time_unix_milli":<span class="cov8" title="1">
                                        // go 1.17 or later, it supports time#UnixMilli()
                                        return buf.WriteString(strconv.FormatInt(time.Now().UnixNano()/1000000, 10))</span>
                                case "time_unix_micro":<span class="cov8" title="1">
                                        // go 1.17 or later, it supports time#UnixMicro()
                                        return buf.WriteString(strconv.FormatInt(time.Now().UnixNano()/1000, 10))</span>
                                case "time_unix_nano":<span class="cov0" title="0">
                                        return buf.WriteString(strconv.FormatInt(time.Now().UnixNano(), 10))</span>
                                case "time_rfc3339":<span class="cov0" title="0">
                                        return buf.WriteString(time.Now().Format(time.RFC3339))</span>
                                case "time_rfc3339_nano":<span class="cov8" title="1">
                                        return buf.WriteString(time.Now().Format(time.RFC3339Nano))</span>
                                case "time_custom":<span class="cov8" title="1">
                                        return buf.WriteString(time.Now().Format(config.CustomTimeFormat))</span>
                                case "id":<span class="cov8" title="1">
                                        id := req.Header.Get(echo.HeaderXRequestID)
                                        if id == "" </span><span class="cov8" title="1">{
                                                id = res.Header().Get(echo.HeaderXRequestID)
                                        }</span>
                                        <span class="cov8" title="1">return buf.WriteString(id)</span>
                                case "remote_ip":<span class="cov8" title="1">
                                        return buf.WriteString(c.RealIP())</span>
                                case "host":<span class="cov8" title="1">
                                        return buf.WriteString(req.Host)</span>
                                case "uri":<span class="cov8" title="1">
                                        return buf.WriteString(req.RequestURI)</span>
                                case "method":<span class="cov8" title="1">
                                        return buf.WriteString(req.Method)</span>
                                case "path":<span class="cov8" title="1">
                                        p := req.URL.Path
                                        if p == "" </span><span class="cov0" title="0">{
                                                p = "/"
                                        }</span>
                                        <span class="cov8" title="1">return buf.WriteString(p)</span>
                                case "route":<span class="cov8" title="1">
                                        return buf.WriteString(c.Path())</span>
                                case "protocol":<span class="cov8" title="1">
                                        return buf.WriteString(req.Proto)</span>
                                case "referer":<span class="cov8" title="1">
                                        return buf.WriteString(req.Referer())</span>
                                case "user_agent":<span class="cov8" title="1">
                                        return buf.WriteString(req.UserAgent())</span>
                                case "status":<span class="cov8" title="1">
                                        n := res.Status
                                        s := config.colorer.Green(n)
                                        switch </span>{
                                        case n &gt;= 500:<span class="cov8" title="1">
                                                s = config.colorer.Red(n)</span>
                                        case n &gt;= 400:<span class="cov8" title="1">
                                                s = config.colorer.Yellow(n)</span>
                                        case n &gt;= 300:<span class="cov8" title="1">
                                                s = config.colorer.Cyan(n)</span>
                                        }
                                        <span class="cov8" title="1">return buf.WriteString(s)</span>
                                case "error":<span class="cov8" title="1">
                                        if err != nil </span><span class="cov8" title="1">{
                                                // Error may contain invalid JSON e.g. `"`
                                                b, _ := json.Marshal(err.Error())
                                                b = b[1 : len(b)-1]
                                                return buf.Write(b)
                                        }</span>
                                case "latency":<span class="cov8" title="1">
                                        l := stop.Sub(start)
                                        return buf.WriteString(strconv.FormatInt(int64(l), 10))</span>
                                case "latency_human":<span class="cov8" title="1">
                                        return buf.WriteString(stop.Sub(start).String())</span>
                                case "bytes_in":<span class="cov8" title="1">
                                        cl := req.Header.Get(echo.HeaderContentLength)
                                        if cl == "" </span><span class="cov8" title="1">{
                                                cl = "0"
                                        }</span>
                                        <span class="cov8" title="1">return buf.WriteString(cl)</span>
                                case "bytes_out":<span class="cov8" title="1">
                                        return buf.WriteString(strconv.FormatInt(res.Size, 10))</span>
                                default:<span class="cov8" title="1">
                                        switch </span>{
                                        case strings.HasPrefix(tag, "header:"):<span class="cov8" title="1">
                                                return buf.Write([]byte(c.Request().Header.Get(tag[7:])))</span>
                                        case strings.HasPrefix(tag, "query:"):<span class="cov8" title="1">
                                                return buf.Write([]byte(c.QueryParam(tag[6:])))</span>
                                        case strings.HasPrefix(tag, "form:"):<span class="cov8" title="1">
                                                return buf.Write([]byte(c.FormValue(tag[5:])))</span>
                                        case strings.HasPrefix(tag, "cookie:"):<span class="cov8" title="1">
                                                cookie, err := c.Cookie(tag[7:])
                                                if err == nil </span><span class="cov8" title="1">{
                                                        return buf.Write([]byte(cookie.Value))
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">return 0, nil</span>
                        }); err != nil <span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">if config.Output == nil </span><span class="cov8" title="1">{
                                _, err = c.Logger().Output().Write(buf.Bytes())
                                return
                        }</span>
                        <span class="cov8" title="1">_, err = config.Output.Write(buf.Bytes())
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

// MethodOverrideConfig defines the config for MethodOverride middleware.
type MethodOverrideConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Getter is a function that gets overridden method from the request.
        // Optional. Default values MethodFromHeader(echo.HeaderXHTTPMethodOverride).
        Getter MethodOverrideGetter
}

// MethodOverrideGetter is a function that gets overridden method from the request
type MethodOverrideGetter func(echo.Context) string

// DefaultMethodOverrideConfig is the default MethodOverride middleware config.
var DefaultMethodOverrideConfig = MethodOverrideConfig{
        Skipper: DefaultSkipper,
        Getter:  MethodFromHeader(echo.HeaderXHTTPMethodOverride),
}

// MethodOverride returns a MethodOverride middleware.
// MethodOverride  middleware checks for the overridden method from the request and
// uses it instead of the original method.
//
// For security reasons, only `POST` method can be overridden.
func MethodOverride() echo.MiddlewareFunc <span class="cov8" title="1">{
        return MethodOverrideWithConfig(DefaultMethodOverrideConfig)
}</span>

// MethodOverrideWithConfig returns a MethodOverride middleware with config.
// See: `MethodOverride()`.
func MethodOverrideWithConfig(config MethodOverrideConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultMethodOverrideConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Getter == nil </span><span class="cov0" title="0">{
                config.Getter = DefaultMethodOverrideConfig.Getter
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        if req.Method == http.MethodPost </span><span class="cov8" title="1">{
                                m := config.Getter(c)
                                if m != "" </span><span class="cov8" title="1">{
                                        req.Method = m
                                }</span>
                        }
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// MethodFromHeader is a `MethodOverrideGetter` that gets overridden method from
// the request header.
func MethodFromHeader(header string) MethodOverrideGetter <span class="cov8" title="1">{
        return func(c echo.Context) string </span><span class="cov8" title="1">{
                return c.Request().Header.Get(header)
        }</span>
}

// MethodFromForm is a `MethodOverrideGetter` that gets overridden method from the
// form parameter.
func MethodFromForm(param string) MethodOverrideGetter <span class="cov8" title="1">{
        return func(c echo.Context) string </span><span class="cov8" title="1">{
                return c.FormValue(param)
        }</span>
}

// MethodFromQuery is a `MethodOverrideGetter` that gets overridden method from
// the query parameter.
func MethodFromQuery(param string) MethodOverrideGetter <span class="cov8" title="1">{
        return func(c echo.Context) string </span><span class="cov8" title="1">{
                return c.QueryParam(param)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "net/http"
        "regexp"
        "strconv"
        "strings"

        "github.com/labstack/echo/v4"
)

// Skipper defines a function to skip middleware. Returning true skips processing
// the middleware.
type Skipper func(c echo.Context) bool

// BeforeFunc defines a function which is executed just before the middleware.
type BeforeFunc func(c echo.Context)

func captureTokens(pattern *regexp.Regexp, input string) *strings.Replacer <span class="cov8" title="1">{
        groups := pattern.FindAllStringSubmatch(input, -1)
        if groups == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">values := groups[0][1:]
        replace := make([]string, 2*len(values))
        for i, v := range values </span><span class="cov8" title="1">{
                j := 2 * i
                replace[j] = "$" + strconv.Itoa(i+1)
                replace[j+1] = v
        }</span>
        <span class="cov8" title="1">return strings.NewReplacer(replace...)</span>
}

func rewriteRulesRegex(rewrite map[string]string) map[*regexp.Regexp]string <span class="cov8" title="1">{
        // Initialize
        rulesRegex := map[*regexp.Regexp]string{}
        for k, v := range rewrite </span><span class="cov8" title="1">{
                k = regexp.QuoteMeta(k)
                k = strings.ReplaceAll(k, `\*`, "(.*?)")
                if strings.HasPrefix(k, `\^`) </span><span class="cov8" title="1">{
                        k = strings.ReplaceAll(k, `\^`, "^")
                }</span>
                <span class="cov8" title="1">k = k + "$"
                rulesRegex[regexp.MustCompile(k)] = v</span>
        }
        <span class="cov8" title="1">return rulesRegex</span>
}

func rewriteURL(rewriteRegex map[*regexp.Regexp]string, req *http.Request) error <span class="cov8" title="1">{
        if len(rewriteRegex) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Depending on how HTTP request is sent RequestURI could contain Scheme://Host/path or be just /path.
        // We only want to use path part for rewriting and therefore trim prefix if it exists
        <span class="cov8" title="1">rawURI := req.RequestURI
        if rawURI != "" &amp;&amp; rawURI[0] != '/' </span><span class="cov8" title="1">{
                prefix := ""
                if req.URL.Scheme != "" </span><span class="cov8" title="1">{
                        prefix = req.URL.Scheme + "://"
                }</span>
                <span class="cov8" title="1">if req.URL.Host != "" </span><span class="cov8" title="1">{
                        prefix += req.URL.Host // host or host:port
                }</span>
                <span class="cov8" title="1">if prefix != "" </span><span class="cov8" title="1">{
                        rawURI = strings.TrimPrefix(rawURI, prefix)
                }</span>
        }

        <span class="cov8" title="1">for k, v := range rewriteRegex </span><span class="cov8" title="1">{
                if replacer := captureTokens(k, rawURI); replacer != nil </span><span class="cov8" title="1">{
                        url, err := req.URL.Parse(replacer.Replace(v))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">req.URL = url

                        return nil</span> // rewrite only once
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// DefaultSkipper returns false which processes the middleware.
func DefaultSkipper(echo.Context) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "context"
        "fmt"
        "io"
        "math/rand"
        "net"
        "net/http"
        "net/http/httputil"
        "net/url"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/labstack/echo/v4"
)

// TODO: Handle TLS proxy

// ProxyConfig defines the config for Proxy middleware.
type ProxyConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Balancer defines a load balancing technique.
        // Required.
        Balancer ProxyBalancer

        // RetryCount defines the number of times a failed proxied request should be retried
        // using the next available ProxyTarget. Defaults to 0, meaning requests are never retried.
        RetryCount int

        // RetryFilter defines a function used to determine if a failed request to a
        // ProxyTarget should be retried. The RetryFilter will only be called when the number
        // of previous retries is less than RetryCount. If the function returns true, the
        // request will be retried. The provided error indicates the reason for the request
        // failure. When the ProxyTarget is unavailable, the error will be an instance of
        // echo.HTTPError with a Code of http.StatusBadGateway. In all other cases, the error
        // will indicate an internal error in the Proxy middleware. When a RetryFilter is not
        // specified, all requests that fail with http.StatusBadGateway will be retried. A custom
        // RetryFilter can be provided to only retry specific requests. Note that RetryFilter is
        // only called when the request to the target fails, or an internal error in the Proxy
        // middleware has occurred. Successful requests that return a non-200 response code cannot
        // be retried.
        RetryFilter func(c echo.Context, e error) bool

        // ErrorHandler defines a function which can be used to return custom errors from
        // the Proxy middleware. ErrorHandler is only invoked when there has been
        // either an internal error in the Proxy middleware or the ProxyTarget is
        // unavailable. Due to the way requests are proxied, ErrorHandler is not invoked
        // when a ProxyTarget returns a non-200 response. In these cases, the response
        // is already written so errors cannot be modified. ErrorHandler is only
        // invoked after all retry attempts have been exhausted.
        ErrorHandler func(c echo.Context, err error) error

        // Rewrite defines URL path rewrite rules. The values captured in asterisk can be
        // retrieved by index e.g. $1, $2 and so on.
        // Examples:
        // "/old":              "/new",
        // "/api/*":            "/$1",
        // "/js/*":             "/public/javascripts/$1",
        // "/users/*/orders/*": "/user/$1/order/$2",
        Rewrite map[string]string

        // RegexRewrite defines rewrite rules using regexp.Rexexp with captures
        // Every capture group in the values can be retrieved by index e.g. $1, $2 and so on.
        // Example:
        // "^/old/[0.9]+/":     "/new",
        // "^/api/.+?/(.*)":    "/v2/$1",
        RegexRewrite map[*regexp.Regexp]string

        // Context key to store selected ProxyTarget into context.
        // Optional. Default value "target".
        ContextKey string

        // To customize the transport to remote.
        // Examples: If custom TLS certificates are required.
        Transport http.RoundTripper

        // ModifyResponse defines function to modify response from ProxyTarget.
        ModifyResponse func(*http.Response) error
}

// ProxyTarget defines the upstream target.
type ProxyTarget struct {
        Name string
        URL  *url.URL
        Meta echo.Map
}

// ProxyBalancer defines an interface to implement a load balancing technique.
type ProxyBalancer interface {
        AddTarget(*ProxyTarget) bool
        RemoveTarget(string) bool
        Next(echo.Context) *ProxyTarget
}

// TargetProvider defines an interface that gives the opportunity for balancer
// to return custom errors when selecting target.
type TargetProvider interface {
        NextTarget(echo.Context) (*ProxyTarget, error)
}

type commonBalancer struct {
        targets []*ProxyTarget
        mutex   sync.Mutex
}

// RandomBalancer implements a random load balancing technique.
type randomBalancer struct {
        commonBalancer
        random *rand.Rand
}

// RoundRobinBalancer implements a round-robin load balancing technique.
type roundRobinBalancer struct {
        commonBalancer
        // tracking the index on `targets` slice for the next `*ProxyTarget` to be used
        i int
}

// DefaultProxyConfig is the default Proxy middleware config.
var DefaultProxyConfig = ProxyConfig{
        Skipper:    DefaultSkipper,
        ContextKey: "target",
}

func proxyRaw(t *ProxyTarget, c echo.Context) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                in, _, err := c.Response().Hijack()
                if err != nil </span><span class="cov0" title="0">{
                        c.Set("_error", fmt.Errorf("proxy raw, hijack error=%w, url=%s", err, t.URL))
                        return
                }</span>
                <span class="cov0" title="0">defer in.Close()

                out, err := net.Dial("tcp", t.URL.Host)
                if err != nil </span><span class="cov0" title="0">{
                        c.Set("_error", echo.NewHTTPError(http.StatusBadGateway, fmt.Sprintf("proxy raw, dial error=%v, url=%s", err, t.URL)))
                        return
                }</span>
                <span class="cov0" title="0">defer out.Close()

                // Write header
                err = r.Write(out)
                if err != nil </span><span class="cov0" title="0">{
                        c.Set("_error", echo.NewHTTPError(http.StatusBadGateway, fmt.Sprintf("proxy raw, request header copy error=%v, url=%s", err, t.URL)))
                        return
                }</span>

                <span class="cov0" title="0">errCh := make(chan error, 2)
                cp := func(dst io.Writer, src io.Reader) </span><span class="cov0" title="0">{
                        _, err = io.Copy(dst, src)
                        errCh &lt;- err
                }</span>

                <span class="cov0" title="0">go cp(out, in)
                go cp(in, out)
                err = &lt;-errCh
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        c.Set("_error", fmt.Errorf("proxy raw, copy body error=%w, url=%s", err, t.URL))
                }</span>
        })
}

// NewRandomBalancer returns a random proxy balancer.
func NewRandomBalancer(targets []*ProxyTarget) ProxyBalancer <span class="cov8" title="1">{
        b := randomBalancer{}
        b.targets = targets
        b.random = rand.New(rand.NewSource(int64(time.Now().Nanosecond())))
        return &amp;b
}</span>

// NewRoundRobinBalancer returns a round-robin proxy balancer.
func NewRoundRobinBalancer(targets []*ProxyTarget) ProxyBalancer <span class="cov8" title="1">{
        b := roundRobinBalancer{}
        b.targets = targets
        return &amp;b
}</span>

// AddTarget adds an upstream target to the list and returns `true`.
//
// However, if a target with the same name already exists then the operation is aborted returning `false`.
func (b *commonBalancer) AddTarget(target *ProxyTarget) bool <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        for _, t := range b.targets </span><span class="cov8" title="1">{
                if t.Name == target.Name </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">b.targets = append(b.targets, target)
        return true</span>
}

// RemoveTarget removes an upstream target from the list by name.
//
// Returns `true` on success, `false` if no target with the name is found.
func (b *commonBalancer) RemoveTarget(name string) bool <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        for i, t := range b.targets </span><span class="cov8" title="1">{
                if t.Name == name </span><span class="cov8" title="1">{
                        b.targets = append(b.targets[:i], b.targets[i+1:]...)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Next randomly returns an upstream target.
//
// Note: `nil` is returned in case upstream target list is empty.
func (b *randomBalancer) Next(c echo.Context) *ProxyTarget <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        if len(b.targets) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if len(b.targets) == 1 </span><span class="cov8" title="1">{
                return b.targets[0]
        }</span>
        <span class="cov8" title="1">return b.targets[b.random.Intn(len(b.targets))]</span>
}

// Next returns an upstream target using round-robin technique. In the case
// where a previously failed request is being retried, the round-robin
// balancer will attempt to use the next target relative to the original
// request. If the list of targets held by the balancer is modified while a
// failed request is being retried, it is possible that the balancer will
// return the original failed target.
//
// Note: `nil` is returned in case upstream target list is empty.
func (b *roundRobinBalancer) Next(c echo.Context) *ProxyTarget <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        if len(b.targets) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if len(b.targets) == 1 </span><span class="cov8" title="1">{
                return b.targets[0]
        }</span>

        <span class="cov8" title="1">var i int
        const lastIdxKey = "_round_robin_last_index"
        // This request is a retry, start from the index of the previous
        // target to ensure we don't attempt to retry the request with
        // the same failed target
        if c.Get(lastIdxKey) != nil </span><span class="cov8" title="1">{
                i = c.Get(lastIdxKey).(int)
                i++
                if i &gt;= len(b.targets) </span><span class="cov0" title="0">{
                        i = 0
                }</span>
        } else<span class="cov8" title="1"> {
                // This is a first time request, use the global index
                if b.i &gt;= len(b.targets) </span><span class="cov8" title="1">{
                        b.i = 0
                }</span>
                <span class="cov8" title="1">i = b.i
                b.i++</span>
        }

        <span class="cov8" title="1">c.Set(lastIdxKey, i)
        return b.targets[i]</span>
}

// Proxy returns a Proxy middleware.
//
// Proxy middleware forwards the request to upstream server using a configured load balancing technique.
func Proxy(balancer ProxyBalancer) echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultProxyConfig
        c.Balancer = balancer
        return ProxyWithConfig(c)
}</span>

// ProxyWithConfig returns a Proxy middleware with config.
// See: `Proxy()`
func ProxyWithConfig(config ProxyConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        if config.Balancer == nil </span><span class="cov0" title="0">{
                panic("echo: proxy middleware requires balancer")</span>
        }
        // Defaults
        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultProxyConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.RetryFilter == nil </span><span class="cov8" title="1">{
                config.RetryFilter = func(c echo.Context, e error) bool </span><span class="cov8" title="1">{
                        if httpErr, ok := e.(*echo.HTTPError); ok </span><span class="cov8" title="1">{
                                return httpErr.Code == http.StatusBadGateway
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }
        }
        <span class="cov8" title="1">if config.ErrorHandler == nil </span><span class="cov8" title="1">{
                config.ErrorHandler = func(c echo.Context, err error) error </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if config.Rewrite != nil </span><span class="cov8" title="1">{
                if config.RegexRewrite == nil </span><span class="cov8" title="1">{
                        config.RegexRewrite = make(map[*regexp.Regexp]string)
                }</span>
                <span class="cov8" title="1">for k, v := range rewriteRulesRegex(config.Rewrite) </span><span class="cov8" title="1">{
                        config.RegexRewrite[k] = v
                }</span>
        }

        <span class="cov8" title="1">provider, isTargetProvider := config.Balancer.(TargetProvider)

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()
                        if err := rewriteURL(config.RegexRewrite, req); err != nil </span><span class="cov0" title="0">{
                                return config.ErrorHandler(c, err)
                        }</span>

                        // Fix header
                        // Basically it's not good practice to unconditionally pass incoming x-real-ip header to upstream.
                        // However, for backward compatibility, legacy behavior is preserved unless you configure Echo#IPExtractor.
                        <span class="cov8" title="1">if req.Header.Get(echo.HeaderXRealIP) == "" || c.Echo().IPExtractor != nil </span><span class="cov8" title="1">{
                                req.Header.Set(echo.HeaderXRealIP, c.RealIP())
                        }</span>
                        <span class="cov8" title="1">if req.Header.Get(echo.HeaderXForwardedProto) == "" </span><span class="cov8" title="1">{
                                req.Header.Set(echo.HeaderXForwardedProto, c.Scheme())
                        }</span>
                        <span class="cov8" title="1">if c.IsWebSocket() &amp;&amp; req.Header.Get(echo.HeaderXForwardedFor) == "" </span><span class="cov0" title="0">{ // For HTTP, it is automatically set by Go HTTP reverse proxy.
                                req.Header.Set(echo.HeaderXForwardedFor, c.RealIP())
                        }</span>

                        <span class="cov8" title="1">retries := config.RetryCount
                        for </span><span class="cov8" title="1">{
                                var tgt *ProxyTarget
                                var err error
                                if isTargetProvider </span><span class="cov8" title="1">{
                                        tgt, err = provider.NextTarget(c)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return config.ErrorHandler(c, err)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        tgt = config.Balancer.Next(c)
                                }</span>

                                <span class="cov8" title="1">c.Set(config.ContextKey, tgt)

                                //If retrying a failed request, clear any previous errors from
                                //context here so that balancers have the option to check for
                                //errors that occurred using previous target
                                if retries &lt; config.RetryCount </span><span class="cov8" title="1">{
                                        c.Set("_error", nil)
                                }</span>

                                // This is needed for ProxyConfig.ModifyResponse and/or ProxyConfig.Transport to be able to process the Request
                                // that Balancer may have replaced with c.SetRequest.
                                <span class="cov8" title="1">req = c.Request()

                                // Proxy
                                switch </span>{
                                case c.IsWebSocket():<span class="cov0" title="0">
                                        proxyRaw(tgt, c).ServeHTTP(res, req)</span>
                                default:<span class="cov8" title="1"> // even SSE requests
                                        proxyHTTP(tgt, c, config).ServeHTTP(res, req)</span>
                                }

                                <span class="cov8" title="1">err, hasError := c.Get("_error").(error)
                                if !hasError </span><span class="cov8" title="1">{
                                        return nil
                                }</span>

                                <span class="cov8" title="1">retry := retries &gt; 0 &amp;&amp; config.RetryFilter(c, err)
                                if !retry </span><span class="cov8" title="1">{
                                        return config.ErrorHandler(c, err)
                                }</span>

                                <span class="cov8" title="1">retries--</span>
                        }
                }
        }
}

// StatusCodeContextCanceled is a custom HTTP status code for situations
// where a client unexpectedly closed the connection to the server.
// As there is no standard error code for "client closed connection", but
// various well-known HTTP clients and server implement this HTTP code we use
// 499 too instead of the more problematic 5xx, which does not allow to detect this situation
const StatusCodeContextCanceled = 499

func proxyHTTP(tgt *ProxyTarget, c echo.Context, config ProxyConfig) http.Handler <span class="cov8" title="1">{
        proxy := httputil.NewSingleHostReverseProxy(tgt.URL)
        proxy.ErrorHandler = func(resp http.ResponseWriter, req *http.Request, err error) </span><span class="cov8" title="1">{
                desc := tgt.URL.String()
                if tgt.Name != "" </span><span class="cov8" title="1">{
                        desc = fmt.Sprintf("%s(%s)", tgt.Name, tgt.URL.String())
                }</span>
                // If the client canceled the request (usually by closing the connection), we can report a
                // client error (4xx) instead of a server error (5xx) to correctly identify the situation.
                // The Go standard library (at of late 2020) wraps the exported, standard
                // context.Canceled error with unexported garbage value requiring a substring check, see
                // https://github.com/golang/go/blob/6965b01ea248cabb70c3749fd218b36089a21efb/src/net/net.go#L416-L430
                <span class="cov8" title="1">if err == context.Canceled || strings.Contains(err.Error(), "operation was canceled") </span><span class="cov8" title="1">{
                        httpError := echo.NewHTTPError(StatusCodeContextCanceled, fmt.Sprintf("client closed connection: %v", err))
                        httpError.Internal = err
                        c.Set("_error", httpError)
                }</span> else<span class="cov8" title="1"> {
                        httpError := echo.NewHTTPError(http.StatusBadGateway, fmt.Sprintf("remote %s unreachable, could not forward: %v", desc, err))
                        httpError.Internal = err
                        c.Set("_error", httpError)
                }</span>
        }
        <span class="cov8" title="1">proxy.Transport = config.Transport
        proxy.ModifyResponse = config.ModifyResponse
        return proxy</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "net/http"
        "sync"
        "time"

        "github.com/labstack/echo/v4"
        "golang.org/x/time/rate"
)

// RateLimiterStore is the interface to be implemented by custom stores.
type RateLimiterStore interface {
        // Stores for the rate limiter have to implement the Allow method
        Allow(identifier string) (bool, error)
}

// RateLimiterConfig defines the configuration for the rate limiter
type RateLimiterConfig struct {
        Skipper    Skipper
        BeforeFunc BeforeFunc
        // IdentifierExtractor uses echo.Context to extract the identifier for a visitor
        IdentifierExtractor Extractor
        // Store defines a store for the rate limiter
        Store RateLimiterStore
        // ErrorHandler provides a handler to be called when IdentifierExtractor returns an error
        ErrorHandler func(context echo.Context, err error) error
        // DenyHandler provides a handler to be called when RateLimiter denies access
        DenyHandler func(context echo.Context, identifier string, err error) error
}

// Extractor is used to extract data from echo.Context
type Extractor func(context echo.Context) (string, error)

// ErrRateLimitExceeded denotes an error raised when rate limit is exceeded
var ErrRateLimitExceeded = echo.NewHTTPError(http.StatusTooManyRequests, "rate limit exceeded")

// ErrExtractorError denotes an error raised when extractor function is unsuccessful
var ErrExtractorError = echo.NewHTTPError(http.StatusForbidden, "error while extracting identifier")

// DefaultRateLimiterConfig defines default values for RateLimiterConfig
var DefaultRateLimiterConfig = RateLimiterConfig{
        Skipper: DefaultSkipper,
        IdentifierExtractor: func(ctx echo.Context) (string, error) <span class="cov8" title="1">{
                id := ctx.RealIP()
                return id, nil
        }</span>,
        ErrorHandler: func(context echo.Context, err error) error <span class="cov8" title="1">{
                return &amp;echo.HTTPError{
                        Code:     ErrExtractorError.Code,
                        Message:  ErrExtractorError.Message,
                        Internal: err,
                }
        }</span>,
        DenyHandler: func(context echo.Context, identifier string, err error) error <span class="cov8" title="1">{
                return &amp;echo.HTTPError{
                        Code:     ErrRateLimitExceeded.Code,
                        Message:  ErrRateLimitExceeded.Message,
                        Internal: err,
                }
        }</span>,
}

/*
RateLimiter returns a rate limiting middleware

        e := echo.New()

        limiterStore := middleware.NewRateLimiterMemoryStore(20)

        e.GET("/rate-limited", func(c echo.Context) error {
                return c.String(http.StatusOK, "test")
        }, RateLimiter(limiterStore))
*/
func RateLimiter(store RateLimiterStore) echo.MiddlewareFunc <span class="cov8" title="1">{
        config := DefaultRateLimiterConfig
        config.Store = store

        return RateLimiterWithConfig(config)
}</span>

/*
RateLimiterWithConfig returns a rate limiting middleware

        e := echo.New()

        config := middleware.RateLimiterConfig{
                Skipper: DefaultSkipper,
                Store: middleware.NewRateLimiterMemoryStore(
                        middleware.RateLimiterMemoryStoreConfig{Rate: 10, Burst: 30, ExpiresIn: 3 * time.Minute}
                )
                IdentifierExtractor: func(ctx echo.Context) (string, error) {
                        id := ctx.RealIP()
                        return id, nil
                },
                ErrorHandler: func(context echo.Context, err error) error {
                        return context.JSON(http.StatusTooManyRequests, nil)
                },
                DenyHandler: func(context echo.Context, identifier string) error {
                        return context.JSON(http.StatusForbidden, nil)
                },
        }

        e.GET("/rate-limited", func(c echo.Context) error {
                return c.String(http.StatusOK, "test")
        }, middleware.RateLimiterWithConfig(config))
*/
func RateLimiterWithConfig(config RateLimiterConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultRateLimiterConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.IdentifierExtractor == nil </span><span class="cov8" title="1">{
                config.IdentifierExtractor = DefaultRateLimiterConfig.IdentifierExtractor
        }</span>
        <span class="cov8" title="1">if config.ErrorHandler == nil </span><span class="cov8" title="1">{
                config.ErrorHandler = DefaultRateLimiterConfig.ErrorHandler
        }</span>
        <span class="cov8" title="1">if config.DenyHandler == nil </span><span class="cov8" title="1">{
                config.DenyHandler = DefaultRateLimiterConfig.DenyHandler
        }</span>
        <span class="cov8" title="1">if config.Store == nil </span><span class="cov8" title="1">{
                panic("Store configuration must be provided")</span>
        }
        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>
                        <span class="cov8" title="1">if config.BeforeFunc != nil </span><span class="cov8" title="1">{
                                config.BeforeFunc(c)
                        }</span>

                        <span class="cov8" title="1">identifier, err := config.IdentifierExtractor(c)
                        if err != nil </span><span class="cov8" title="1">{
                                c.Error(config.ErrorHandler(c, err))
                                return nil
                        }</span>

                        <span class="cov8" title="1">if allow, err := config.Store.Allow(identifier); !allow </span><span class="cov8" title="1">{
                                c.Error(config.DenyHandler(c, identifier, err))
                                return nil
                        }</span>
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// RateLimiterMemoryStore is the built-in store implementation for RateLimiter
type RateLimiterMemoryStore struct {
        visitors map[string]*Visitor
        mutex    sync.Mutex
        rate     rate.Limit // for more info check out Limiter docs - https://pkg.go.dev/golang.org/x/time/rate#Limit.

        burst       int
        expiresIn   time.Duration
        lastCleanup time.Time

        timeNow func() time.Time
}

// Visitor signifies a unique user's limiter details
type Visitor struct {
        *rate.Limiter
        lastSeen time.Time
}

/*
NewRateLimiterMemoryStore returns an instance of RateLimiterMemoryStore with
the provided rate (as req/s).
for more info check out Limiter docs - https://pkg.go.dev/golang.org/x/time/rate#Limit.

Burst and ExpiresIn will be set to default values.

Note that if the provided rate is a float number and Burst is zero, Burst will be treated as the rounded down value of the rate.

Example (with 20 requests/sec):

        limiterStore := middleware.NewRateLimiterMemoryStore(20)
*/
func NewRateLimiterMemoryStore(rate rate.Limit) (store *RateLimiterMemoryStore) <span class="cov8" title="1">{
        return NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
                Rate: rate,
        })
}</span>

/*
NewRateLimiterMemoryStoreWithConfig returns an instance of RateLimiterMemoryStore
with the provided configuration. Rate must be provided. Burst will be set to the rounded down value of
the configured rate if not provided or set to 0.

The built-in memory store is usually capable for modest loads. For higher loads other
store implementations should be considered.

Characteristics:
* Concurrency above 100 parallel requests may causes measurable lock contention
* A high number of different IP addresses (above 16000) may be impacted by the internally used Go map
* A high number of requests from a single IP address may cause lock contention

Example:

        limiterStore := middleware.NewRateLimiterMemoryStoreWithConfig(
                middleware.RateLimiterMemoryStoreConfig{Rate: 50, Burst: 200, ExpiresIn: 5 * time.Minute},
        )
*/
func NewRateLimiterMemoryStoreWithConfig(config RateLimiterMemoryStoreConfig) (store *RateLimiterMemoryStore) <span class="cov8" title="1">{
        store = &amp;RateLimiterMemoryStore{}

        store.rate = config.Rate
        store.burst = config.Burst
        store.expiresIn = config.ExpiresIn
        if config.ExpiresIn == 0 </span><span class="cov8" title="1">{
                store.expiresIn = DefaultRateLimiterMemoryStoreConfig.ExpiresIn
        }</span>
        <span class="cov8" title="1">if config.Burst == 0 </span><span class="cov8" title="1">{
                store.burst = int(config.Rate)
        }</span>
        <span class="cov8" title="1">store.visitors = make(map[string]*Visitor)
        store.timeNow = time.Now
        store.lastCleanup = store.timeNow()
        return</span>
}

// RateLimiterMemoryStoreConfig represents configuration for RateLimiterMemoryStore
type RateLimiterMemoryStoreConfig struct {
        Rate      rate.Limit    // Rate of requests allowed to pass as req/s. For more info check out Limiter docs - https://pkg.go.dev/golang.org/x/time/rate#Limit.
        Burst     int           // Burst is maximum number of requests to pass at the same moment. It additionally allows a number of requests to pass when rate limit is reached.
        ExpiresIn time.Duration // ExpiresIn is the duration after that a rate limiter is cleaned up
}

// DefaultRateLimiterMemoryStoreConfig provides default configuration values for RateLimiterMemoryStore
var DefaultRateLimiterMemoryStoreConfig = RateLimiterMemoryStoreConfig{
        ExpiresIn: 3 * time.Minute,
}

// Allow implements RateLimiterStore.Allow
func (store *RateLimiterMemoryStore) Allow(identifier string) (bool, error) <span class="cov8" title="1">{
        store.mutex.Lock()
        limiter, exists := store.visitors[identifier]
        if !exists </span><span class="cov8" title="1">{
                limiter = new(Visitor)
                limiter.Limiter = rate.NewLimiter(store.rate, store.burst)
                store.visitors[identifier] = limiter
        }</span>
        <span class="cov8" title="1">now := store.timeNow()
        limiter.lastSeen = now
        if now.Sub(store.lastCleanup) &gt; store.expiresIn </span><span class="cov0" title="0">{
                store.cleanupStaleVisitors()
        }</span>
        <span class="cov8" title="1">store.mutex.Unlock()
        return limiter.AllowN(store.timeNow(), 1), nil</span>
}

/*
cleanupStaleVisitors helps manage the size of the visitors map by removing stale records
of users who haven't visited again after the configured expiry time has elapsed
*/
func (store *RateLimiterMemoryStore) cleanupStaleVisitors() <span class="cov8" title="1">{
        for id, visitor := range store.visitors </span><span class="cov8" title="1">{
                if store.timeNow().Sub(visitor.lastSeen) &gt; store.expiresIn </span><span class="cov8" title="1">{
                        delete(store.visitors, id)
                }</span>
        }
        <span class="cov8" title="1">store.lastCleanup = store.timeNow()</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "fmt"
        "net/http"
        "runtime"

        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/log"
)

// LogErrorFunc defines a function for custom logging in the middleware.
type LogErrorFunc func(c echo.Context, err error, stack []byte) error

// RecoverConfig defines the config for Recover middleware.
type RecoverConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Size of the stack to be printed.
        // Optional. Default value 4KB.
        StackSize int `yaml:"stack_size"`

        // DisableStackAll disables formatting stack traces of all other goroutines
        // into buffer after the trace for the current goroutine.
        // Optional. Default value false.
        DisableStackAll bool `yaml:"disable_stack_all"`

        // DisablePrintStack disables printing stack trace.
        // Optional. Default value as false.
        DisablePrintStack bool `yaml:"disable_print_stack"`

        // LogLevel is log level to printing stack trace.
        // Optional. Default value 0 (Print).
        LogLevel log.Lvl

        // LogErrorFunc defines a function for custom logging in the middleware.
        // If it's set you don't need to provide LogLevel for config.
        // If this function returns nil, the centralized HTTPErrorHandler will not be called.
        LogErrorFunc LogErrorFunc

        // DisableErrorHandler disables the call to centralized HTTPErrorHandler.
        // The recovered error is then passed back to upstream middleware, instead of swallowing the error.
        // Optional. Default value false.
        DisableErrorHandler bool `yaml:"disable_error_handler"`
}

// DefaultRecoverConfig is the default Recover middleware config.
var DefaultRecoverConfig = RecoverConfig{
        Skipper:             DefaultSkipper,
        StackSize:           4 &lt;&lt; 10, // 4 KB
        DisableStackAll:     false,
        DisablePrintStack:   false,
        LogLevel:            0,
        LogErrorFunc:        nil,
        DisableErrorHandler: false,
}

// Recover returns a middleware which recovers from panics anywhere in the chain
// and handles the control to the centralized HTTPErrorHandler.
func Recover() echo.MiddlewareFunc <span class="cov8" title="1">{
        return RecoverWithConfig(DefaultRecoverConfig)
}</span>

// RecoverWithConfig returns a Recover middleware with config.
// See: `Recover()`.
func RecoverWithConfig(config RecoverConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov0" title="0">{
                config.Skipper = DefaultRecoverConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.StackSize == 0 </span><span class="cov0" title="0">{
                config.StackSize = DefaultRecoverConfig.StackSize
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) (returnErr error) </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov8" title="1">{
                                        if r == http.ErrAbortHandler </span><span class="cov8" title="1">{
                                                panic(r)</span>
                                        }
                                        <span class="cov8" title="1">err, ok := r.(error)
                                        if !ok </span><span class="cov8" title="1">{
                                                err = fmt.Errorf("%v", r)
                                        }</span>
                                        <span class="cov8" title="1">var stack []byte
                                        var length int

                                        if !config.DisablePrintStack </span><span class="cov8" title="1">{
                                                stack = make([]byte, config.StackSize)
                                                length = runtime.Stack(stack, !config.DisableStackAll)
                                                stack = stack[:length]
                                        }</span>

                                        <span class="cov8" title="1">if config.LogErrorFunc != nil </span><span class="cov8" title="1">{
                                                err = config.LogErrorFunc(c, err, stack)
                                        }</span> else<span class="cov8" title="1"> if !config.DisablePrintStack </span><span class="cov8" title="1">{
                                                msg := fmt.Sprintf("[PANIC RECOVER] %v %s\n", err, stack[:length])
                                                switch config.LogLevel </span>{
                                                case log.DEBUG:<span class="cov8" title="1">
                                                        c.Logger().Debug(msg)</span>
                                                case log.INFO:<span class="cov8" title="1">
                                                        c.Logger().Info(msg)</span>
                                                case log.WARN:<span class="cov8" title="1">
                                                        c.Logger().Warn(msg)</span>
                                                case log.ERROR:<span class="cov8" title="1">
                                                        c.Logger().Error(msg)</span>
                                                case log.OFF:<span class="cov8" title="1"></span>
                                                        // None.
                                                default:<span class="cov8" title="1">
                                                        c.Logger().Print(msg)</span>
                                                }
                                        }

                                        <span class="cov8" title="1">if err != nil &amp;&amp; !config.DisableErrorHandler </span><span class="cov8" title="1">{
                                                c.Error(err)
                                        }</span> else<span class="cov8" title="1"> {
                                                returnErr = err
                                        }</span>
                                }
                        }()
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"
)

// RedirectConfig defines the config for Redirect middleware.
type RedirectConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper

        // Status code to be used when redirecting the request.
        // Optional. Default value http.StatusMovedPermanently.
        Code int `yaml:"code"`
}

// redirectLogic represents a function that given a scheme, host and uri
// can both: 1) determine if redirect is needed (will set ok accordingly) and
// 2) return the appropriate redirect url.
type redirectLogic func(scheme, host, uri string) (ok bool, url string)

const www = "www."

// DefaultRedirectConfig is the default Redirect middleware config.
var DefaultRedirectConfig = RedirectConfig{
        Skipper: DefaultSkipper,
        Code:    http.StatusMovedPermanently,
}

// HTTPSRedirect redirects http requests to https.
// For example, http://labstack.com will be redirect to https://labstack.com.
//
// Usage `Echo#Pre(HTTPSRedirect())`
func HTTPSRedirect() echo.MiddlewareFunc <span class="cov8" title="1">{
        return HTTPSRedirectWithConfig(DefaultRedirectConfig)
}</span>

// HTTPSRedirectWithConfig returns an HTTPSRedirect middleware with config.
// See `HTTPSRedirect()`.
func HTTPSRedirectWithConfig(config RedirectConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        return redirect(config, func(scheme, host, uri string) (bool, string) </span><span class="cov8" title="1">{
                if scheme != "https" </span><span class="cov8" title="1">{
                        return true, "https://" + host + uri
                }</span>
                <span class="cov8" title="1">return false, ""</span>
        })
}

// HTTPSWWWRedirect redirects http requests to https www.
// For example, http://labstack.com will be redirect to https://www.labstack.com.
//
// Usage `Echo#Pre(HTTPSWWWRedirect())`
func HTTPSWWWRedirect() echo.MiddlewareFunc <span class="cov8" title="1">{
        return HTTPSWWWRedirectWithConfig(DefaultRedirectConfig)
}</span>

// HTTPSWWWRedirectWithConfig returns an HTTPSRedirect middleware with config.
// See `HTTPSWWWRedirect()`.
func HTTPSWWWRedirectWithConfig(config RedirectConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        return redirect(config, func(scheme, host, uri string) (bool, string) </span><span class="cov8" title="1">{
                if scheme != "https" &amp;&amp; !strings.HasPrefix(host, www) </span><span class="cov8" title="1">{
                        return true, "https://www." + host + uri
                }</span>
                <span class="cov8" title="1">return false, ""</span>
        })
}

// HTTPSNonWWWRedirect redirects http requests to https non www.
// For example, http://www.labstack.com will be redirect to https://labstack.com.
//
// Usage `Echo#Pre(HTTPSNonWWWRedirect())`
func HTTPSNonWWWRedirect() echo.MiddlewareFunc <span class="cov8" title="1">{
        return HTTPSNonWWWRedirectWithConfig(DefaultRedirectConfig)
}</span>

// HTTPSNonWWWRedirectWithConfig returns an HTTPSRedirect middleware with config.
// See `HTTPSNonWWWRedirect()`.
func HTTPSNonWWWRedirectWithConfig(config RedirectConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        return redirect(config, func(scheme, host, uri string) (ok bool, url string) </span><span class="cov8" title="1">{
                if scheme != "https" </span><span class="cov8" title="1">{
                        host = strings.TrimPrefix(host, www)
                        return true, "https://" + host + uri
                }</span>
                <span class="cov8" title="1">return false, ""</span>
        })
}

// WWWRedirect redirects non www requests to www.
// For example, http://labstack.com will be redirect to http://www.labstack.com.
//
// Usage `Echo#Pre(WWWRedirect())`
func WWWRedirect() echo.MiddlewareFunc <span class="cov8" title="1">{
        return WWWRedirectWithConfig(DefaultRedirectConfig)
}</span>

// WWWRedirectWithConfig returns an HTTPSRedirect middleware with config.
// See `WWWRedirect()`.
func WWWRedirectWithConfig(config RedirectConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        return redirect(config, func(scheme, host, uri string) (bool, string) </span><span class="cov8" title="1">{
                if !strings.HasPrefix(host, www) </span><span class="cov8" title="1">{
                        return true, scheme + "://www." + host + uri
                }</span>
                <span class="cov8" title="1">return false, ""</span>
        })
}

// NonWWWRedirect redirects www requests to non www.
// For example, http://www.labstack.com will be redirect to http://labstack.com.
//
// Usage `Echo#Pre(NonWWWRedirect())`
func NonWWWRedirect() echo.MiddlewareFunc <span class="cov8" title="1">{
        return NonWWWRedirectWithConfig(DefaultRedirectConfig)
}</span>

// NonWWWRedirectWithConfig returns an HTTPSRedirect middleware with config.
// See `NonWWWRedirect()`.
func NonWWWRedirectWithConfig(config RedirectConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        return redirect(config, func(scheme, host, uri string) (bool, string) </span><span class="cov8" title="1">{
                if strings.HasPrefix(host, www) </span><span class="cov8" title="1">{
                        return true, scheme + "://" + host[4:] + uri
                }</span>
                <span class="cov8" title="1">return false, ""</span>
        })
}

func redirect(config RedirectConfig, cb redirectLogic) echo.MiddlewareFunc <span class="cov8" title="1">{
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultRedirectConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Code == 0 </span><span class="cov8" title="1">{
                config.Code = DefaultRedirectConfig.Code
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req, scheme := c.Request(), c.Scheme()
                        host := req.Host
                        if ok, url := cb(scheme, host, req.RequestURI); ok </span><span class="cov8" title="1">{
                                return c.Redirect(config.Code, url)
                        }</span>

                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "github.com/labstack/echo/v4"
)

// RequestIDConfig defines the config for RequestID middleware.
type RequestIDConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Generator defines a function to generate an ID.
        // Optional. Defaults to generator for random string of length 32.
        Generator func() string

        // RequestIDHandler defines a function which is executed for a request id.
        RequestIDHandler func(echo.Context, string)

        // TargetHeader defines what header to look for to populate the id
        TargetHeader string
}

// DefaultRequestIDConfig is the default RequestID middleware config.
var DefaultRequestIDConfig = RequestIDConfig{
        Skipper:      DefaultSkipper,
        Generator:    generator,
        TargetHeader: echo.HeaderXRequestID,
}

// RequestID returns a X-Request-ID middleware.
func RequestID() echo.MiddlewareFunc <span class="cov0" title="0">{
        return RequestIDWithConfig(DefaultRequestIDConfig)
}</span>

// RequestIDWithConfig returns a X-Request-ID middleware with config.
func RequestIDWithConfig(config RequestIDConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultRequestIDConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Generator == nil </span><span class="cov8" title="1">{
                config.Generator = generator
        }</span>
        <span class="cov8" title="1">if config.TargetHeader == "" </span><span class="cov8" title="1">{
                config.TargetHeader = echo.HeaderXRequestID
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()
                        rid := req.Header.Get(config.TargetHeader)
                        if rid == "" </span><span class="cov8" title="1">{
                                rid = config.Generator()
                        }</span>
                        <span class="cov8" title="1">res.Header().Set(config.TargetHeader, rid)
                        if config.RequestIDHandler != nil </span><span class="cov8" title="1">{
                                config.RequestIDHandler(c, rid)
                        }</span>

                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

func generator() string <span class="cov8" title="1">{
        return randomString(32)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "errors"
        "net/http"
        "time"

        "github.com/labstack/echo/v4"
)

// Example for `slog` https://pkg.go.dev/log/slog
//         logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
//        e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
//                LogStatus:   true,
//                LogURI:      true,
//                LogError:    true,
//                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
//                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
//                        if v.Error == nil {
//                                logger.LogAttrs(context.Background(), slog.LevelInfo, "REQUEST",
//                                        slog.String("uri", v.URI),
//                                        slog.Int("status", v.Status),
//                                )
//                        } else {
//                                logger.LogAttrs(context.Background(), slog.LevelError, "REQUEST_ERROR",
//                                        slog.String("uri", v.URI),
//                                        slog.Int("status", v.Status),
//                                        slog.String("err", v.Error.Error()),
//                                )
//                        }
//                        return nil
//                },
//        }))
//
// Example for `fmt.Printf`
//         e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
//                LogStatus:   true,
//                LogURI:      true,
//                LogError:    true,
//                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
//                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
//                        if v.Error == nil {
//                                fmt.Printf("REQUEST: uri: %v, status: %v\n", v.URI, v.Status)
//                        } else {
//                                fmt.Printf("REQUEST_ERROR: uri: %v, status: %v, err: %v\n", v.URI, v.Status, v.Error)
//                        }
//                        return nil
//                },
//        }))
//
// Example for Zerolog (https://github.com/rs/zerolog)
//         logger := zerolog.New(os.Stdout)
//        e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
//                LogURI:      true,
//                LogStatus:   true,
//                LogError:    true,
//                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
//                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
//                        if v.Error == nil {
//                                logger.Info().
//                                        Str("URI", v.URI).
//                                        Int("status", v.Status).
//                                        Msg("request")
//                        } else {
//                                logger.Error().
//                                        Err(v.Error).
//                                        Str("URI", v.URI).
//                                        Int("status", v.Status).
//                                        Msg("request error")
//                        }
//                        return nil
//                },
//        }))
//
// Example for Zap (https://github.com/uber-go/zap)
//         logger, _ := zap.NewProduction()
//        e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
//                LogURI:      true,
//                LogStatus:   true,
//                LogError:    true,
//                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
//                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
//                        if v.Error == nil {
//                                logger.Info("request",
//                                        zap.String("URI", v.URI),
//                                        zap.Int("status", v.Status),
//                                )
//                        } else {
//                                logger.Error("request error",
//                                        zap.String("URI", v.URI),
//                                        zap.Int("status", v.Status),
//                                        zap.Error(v.Error),
//                                )
//                        }
//                        return nil
//                },
//        }))
//
// Example for Logrus (https://github.com/sirupsen/logrus)
//  log := logrus.New()
//        e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
//                LogURI:      true,
//                LogStatus:   true,
//                LogError:    true,
//                HandleError: true, // forwards error to the global error handler, so it can decide appropriate status code
//                LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
//                        if v.Error == nil {
//                                log.WithFields(logrus.Fields{
//                                        "URI":    v.URI,
//                                        "status": v.Status,
//                                }).Info("request")
//                        } else {
//                                log.WithFields(logrus.Fields{
//                                        "URI":    v.URI,
//                                        "status": v.Status,
//                                        "error":  v.Error,
//                                }).Error("request error")
//                        }
//                        return nil
//                },
//        }))

// RequestLoggerConfig is configuration for Request Logger middleware.
type RequestLoggerConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // BeforeNextFunc defines a function that is called before next middleware or handler is called in chain.
        BeforeNextFunc func(c echo.Context)
        // LogValuesFunc defines a function that is called with values extracted by logger from request/response.
        // Mandatory.
        LogValuesFunc func(c echo.Context, v RequestLoggerValues) error

        // HandleError instructs logger to call global error handler when next middleware/handler returns an error.
        // This is useful when you have custom error handler that can decide to use different status codes.
        //
        // A side-effect of calling global error handler is that now Response has been committed and sent to the client
        // and middlewares up in chain can not change Response status code or response body.
        HandleError bool

        // LogLatency instructs logger to record duration it took to execute rest of the handler chain (next(c) call).
        LogLatency bool
        // LogProtocol instructs logger to extract request protocol (i.e. `HTTP/1.1` or `HTTP/2`)
        LogProtocol bool
        // LogRemoteIP instructs logger to extract request remote IP. See `echo.Context.RealIP()` for implementation details.
        LogRemoteIP bool
        // LogHost instructs logger to extract request host value (i.e. `example.com`)
        LogHost bool
        // LogMethod instructs logger to extract request method value (i.e. `GET` etc)
        LogMethod bool
        // LogURI instructs logger to extract request URI (i.e. `/list?lang=en&amp;page=1`)
        LogURI bool
        // LogURIPath instructs logger to extract request URI path part (i.e. `/list`)
        LogURIPath bool
        // LogRoutePath instructs logger to extract route path part to which request was matched to (i.e. `/user/:id`)
        LogRoutePath bool
        // LogRequestID instructs logger to extract request ID from request `X-Request-ID` header or response if request did not have value.
        LogRequestID bool
        // LogReferer instructs logger to extract request referer values.
        LogReferer bool
        // LogUserAgent instructs logger to extract request user agent values.
        LogUserAgent bool
        // LogStatus instructs logger to extract response status code. If handler chain returns an echo.HTTPError,
        // the status code is extracted from the echo.HTTPError returned
        LogStatus bool
        // LogError instructs logger to extract error returned from executed handler chain.
        LogError bool
        // LogContentLength instructs logger to extract content length header value. Note: this value could be different from
        // actual request body size as it could be spoofed etc.
        LogContentLength bool
        // LogResponseSize instructs logger to extract response content length value. Note: when used with Gzip middleware
        // this value may not be always correct.
        LogResponseSize bool
        // LogHeaders instructs logger to extract given list of headers from request. Note: request can contain more than
        // one header with same value so slice of values is been logger for each given header.
        //
        // Note: header values are converted to canonical form with http.CanonicalHeaderKey as this how request parser converts header
        // names to. For example, the canonical key for "accept-encoding" is "Accept-Encoding".
        LogHeaders []string
        // LogQueryParams instructs logger to extract given list of query parameters from request URI. Note: request can
        // contain more than one query parameter with same name so slice of values is been logger for each given query param name.
        LogQueryParams []string
        // LogFormValues instructs logger to extract given list of form values from request body+URI. Note: request can
        // contain more than one form value with same name so slice of values is been logger for each given form value name.
        LogFormValues []string

        timeNow func() time.Time
}

// RequestLoggerValues contains extracted values from logger.
type RequestLoggerValues struct {
        // StartTime is time recorded before next middleware/handler is executed.
        StartTime time.Time
        // Latency is duration it took to execute rest of the handler chain (next(c) call).
        Latency time.Duration
        // Protocol is request protocol (i.e. `HTTP/1.1` or `HTTP/2`)
        Protocol string
        // RemoteIP is request remote IP. See `echo.Context.RealIP()` for implementation details.
        RemoteIP string
        // Host is request host value (i.e. `example.com`)
        Host string
        // Method is request method value (i.e. `GET` etc)
        Method string
        // URI is request URI (i.e. `/list?lang=en&amp;page=1`)
        URI string
        // URIPath is request URI path part (i.e. `/list`)
        URIPath string
        // RoutePath is route path part to which request was matched to (i.e. `/user/:id`)
        RoutePath string
        // RequestID is request ID from request `X-Request-ID` header or response if request did not have value.
        RequestID string
        // Referer is request referer values.
        Referer string
        // UserAgent is request user agent values.
        UserAgent string
        // Status is response status code. Then handler returns an echo.HTTPError then code from there.
        Status int
        // Error is error returned from executed handler chain.
        Error error
        // ContentLength is content length header value. Note: this value could be different from actual request body size
        // as it could be spoofed etc.
        ContentLength string
        // ResponseSize is response content length value. Note: when used with Gzip middleware this value may not be always correct.
        ResponseSize int64
        // Headers are list of headers from request. Note: request can contain more than one header with same value so slice
        // of values is been logger for each given header.
        // Note: header values are converted to canonical form with http.CanonicalHeaderKey as this how request parser converts header
        // names to. For example, the canonical key for "accept-encoding" is "Accept-Encoding".
        Headers map[string][]string
        // QueryParams are list of query parameters from request URI. Note: request can contain more than one query parameter
        // with same name so slice of values is been logger for each given query param name.
        QueryParams map[string][]string
        // FormValues are list of form values from request body+URI. Note: request can contain more than one form value with
        // same name so slice of values is been logger for each given form value name.
        FormValues map[string][]string
}

// RequestLoggerWithConfig returns a RequestLogger middleware with config.
func RequestLoggerWithConfig(config RequestLoggerConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        mw, err := config.ToMiddleware()
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return mw</span>
}

// ToMiddleware converts RequestLoggerConfig into middleware or returns an error for invalid configuration.
func (config RequestLoggerConfig) ToMiddleware() (echo.MiddlewareFunc, error) <span class="cov8" title="1">{
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultSkipper
        }</span>
        <span class="cov8" title="1">now := time.Now
        if config.timeNow != nil </span><span class="cov8" title="1">{
                now = config.timeNow
        }</span>

        <span class="cov8" title="1">if config.LogValuesFunc == nil </span><span class="cov8" title="1">{
                return nil, errors.New("missing LogValuesFunc callback function for request logger middleware")
        }</span>

        <span class="cov8" title="1">logHeaders := len(config.LogHeaders) &gt; 0
        headers := append([]string(nil), config.LogHeaders...)
        for i, v := range headers </span><span class="cov8" title="1">{
                headers[i] = http.CanonicalHeaderKey(v)
        }</span>

        <span class="cov8" title="1">logQueryParams := len(config.LogQueryParams) &gt; 0
        logFormValues := len(config.LogFormValues) &gt; 0

        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()
                        start := now()

                        if config.BeforeNextFunc != nil </span><span class="cov8" title="1">{
                                config.BeforeNextFunc(c)
                        }</span>
                        <span class="cov8" title="1">err := next(c)
                        if err != nil &amp;&amp; config.HandleError </span><span class="cov8" title="1">{
                                c.Error(err)
                        }</span>

                        <span class="cov8" title="1">v := RequestLoggerValues{
                                StartTime: start,
                        }
                        if config.LogLatency </span><span class="cov8" title="1">{
                                v.Latency = now().Sub(start)
                        }</span>
                        <span class="cov8" title="1">if config.LogProtocol </span><span class="cov8" title="1">{
                                v.Protocol = req.Proto
                        }</span>
                        <span class="cov8" title="1">if config.LogRemoteIP </span><span class="cov8" title="1">{
                                v.RemoteIP = c.RealIP()
                        }</span>
                        <span class="cov8" title="1">if config.LogHost </span><span class="cov8" title="1">{
                                v.Host = req.Host
                        }</span>
                        <span class="cov8" title="1">if config.LogMethod </span><span class="cov8" title="1">{
                                v.Method = req.Method
                        }</span>
                        <span class="cov8" title="1">if config.LogURI </span><span class="cov8" title="1">{
                                v.URI = req.RequestURI
                        }</span>
                        <span class="cov8" title="1">if config.LogURIPath </span><span class="cov8" title="1">{
                                p := req.URL.Path
                                if p == "" </span><span class="cov0" title="0">{
                                        p = "/"
                                }</span>
                                <span class="cov8" title="1">v.URIPath = p</span>
                        }
                        <span class="cov8" title="1">if config.LogRoutePath </span><span class="cov8" title="1">{
                                v.RoutePath = c.Path()
                        }</span>
                        <span class="cov8" title="1">if config.LogRequestID </span><span class="cov8" title="1">{
                                id := req.Header.Get(echo.HeaderXRequestID)
                                if id == "" </span><span class="cov8" title="1">{
                                        id = res.Header().Get(echo.HeaderXRequestID)
                                }</span>
                                <span class="cov8" title="1">v.RequestID = id</span>
                        }
                        <span class="cov8" title="1">if config.LogReferer </span><span class="cov8" title="1">{
                                v.Referer = req.Referer()
                        }</span>
                        <span class="cov8" title="1">if config.LogUserAgent </span><span class="cov8" title="1">{
                                v.UserAgent = req.UserAgent()
                        }</span>
                        <span class="cov8" title="1">if config.LogStatus </span><span class="cov8" title="1">{
                                v.Status = res.Status
                                if err != nil &amp;&amp; !config.HandleError </span><span class="cov8" title="1">{
                                        //  this block should not be executed in case of HandleError=true as the global error handler will decide
                                        //  the status code. In that case status code could be different from what err contains.
                                        var httpErr *echo.HTTPError
                                        if errors.As(err, &amp;httpErr) </span><span class="cov8" title="1">{
                                                v.Status = httpErr.Code
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if config.LogError &amp;&amp; err != nil </span><span class="cov8" title="1">{
                                v.Error = err
                        }</span>
                        <span class="cov8" title="1">if config.LogContentLength </span><span class="cov8" title="1">{
                                v.ContentLength = req.Header.Get(echo.HeaderContentLength)
                        }</span>
                        <span class="cov8" title="1">if config.LogResponseSize </span><span class="cov8" title="1">{
                                v.ResponseSize = res.Size
                        }</span>
                        <span class="cov8" title="1">if logHeaders </span><span class="cov8" title="1">{
                                v.Headers = map[string][]string{}
                                for _, header := range headers </span><span class="cov8" title="1">{
                                        if values, ok := req.Header[header]; ok </span><span class="cov8" title="1">{
                                                v.Headers[header] = values
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if logQueryParams </span><span class="cov8" title="1">{
                                queryParams := c.QueryParams()
                                v.QueryParams = map[string][]string{}
                                for _, param := range config.LogQueryParams </span><span class="cov8" title="1">{
                                        if values, ok := queryParams[param]; ok </span><span class="cov8" title="1">{
                                                v.QueryParams[param] = values
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if logFormValues </span><span class="cov8" title="1">{
                                v.FormValues = map[string][]string{}
                                for _, formValue := range config.LogFormValues </span><span class="cov8" title="1">{
                                        if values, ok := req.Form[formValue]; ok </span><span class="cov8" title="1">{
                                                v.FormValues[formValue] = values
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if errOnLog := config.LogValuesFunc(c, v); errOnLog != nil </span><span class="cov8" title="1">{
                                return errOnLog
                        }</span>

                        // in case of HandleError=true we are returning the error that we already have handled with global error handler
                        // this is deliberate as this error could be useful for upstream middlewares and default global error handler
                        // will ignore that error when it bubbles up in middleware chain.
                        <span class="cov8" title="1">return err</span>
                }
        }, nil
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "regexp"

        "github.com/labstack/echo/v4"
)

// RewriteConfig defines the config for Rewrite middleware.
type RewriteConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Rules defines the URL path rewrite rules. The values captured in asterisk can be
        // retrieved by index e.g. $1, $2 and so on.
        // Example:
        // "/old":              "/new",
        // "/api/*":            "/$1",
        // "/js/*":             "/public/javascripts/$1",
        // "/users/*/orders/*": "/user/$1/order/$2",
        // Required.
        Rules map[string]string `yaml:"rules"`

        // RegexRules defines the URL path rewrite rules using regexp.Rexexp with captures
        // Every capture group in the values can be retrieved by index e.g. $1, $2 and so on.
        // Example:
        // "^/old/[0.9]+/":     "/new",
        // "^/api/.+?/(.*)":     "/v2/$1",
        RegexRules map[*regexp.Regexp]string `yaml:"-"`
}

// DefaultRewriteConfig is the default Rewrite middleware config.
var DefaultRewriteConfig = RewriteConfig{
        Skipper: DefaultSkipper,
}

// Rewrite returns a Rewrite middleware.
//
// Rewrite middleware rewrites the URL path based on the provided rules.
func Rewrite(rules map[string]string) echo.MiddlewareFunc <span class="cov8" title="1">{
        c := DefaultRewriteConfig
        c.Rules = rules
        return RewriteWithConfig(c)
}</span>

// RewriteWithConfig returns a Rewrite middleware with config.
// See: `Rewrite()`.
func RewriteWithConfig(config RewriteConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Rules == nil &amp;&amp; config.RegexRules == nil </span><span class="cov0" title="0">{
                panic("echo: rewrite middleware requires url path rewrite rules or regex rules")</span>
        }

        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultBodyDumpConfig.Skipper
        }</span>

        <span class="cov8" title="1">if config.RegexRules == nil </span><span class="cov8" title="1">{
                config.RegexRules = make(map[*regexp.Regexp]string)
        }</span>
        <span class="cov8" title="1">for k, v := range rewriteRulesRegex(config.Rules) </span><span class="cov8" title="1">{
                config.RegexRules[k] = v
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) (err error) </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">if err := rewriteURL(config.RegexRules, c.Request()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "fmt"

        "github.com/labstack/echo/v4"
)

// SecureConfig defines the config for Secure middleware.
type SecureConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // XSSProtection provides protection against cross-site scripting attack (XSS)
        // by setting the `X-XSS-Protection` header.
        // Optional. Default value "1; mode=block".
        XSSProtection string `yaml:"xss_protection"`

        // ContentTypeNosniff provides protection against overriding Content-Type
        // header by setting the `X-Content-Type-Options` header.
        // Optional. Default value "nosniff".
        ContentTypeNosniff string `yaml:"content_type_nosniff"`

        // XFrameOptions can be used to indicate whether or not a browser should
        // be allowed to render a page in a &lt;frame&gt;, &lt;iframe&gt; or &lt;object&gt; .
        // Sites can use this to avoid clickjacking attacks, by ensuring that their
        // content is not embedded into other sites.provides protection against
        // clickjacking.
        // Optional. Default value "SAMEORIGIN".
        // Possible values:
        // - "SAMEORIGIN" - The page can only be displayed in a frame on the same origin as the page itself.
        // - "DENY" - The page cannot be displayed in a frame, regardless of the site attempting to do so.
        // - "ALLOW-FROM uri" - The page can only be displayed in a frame on the specified origin.
        XFrameOptions string `yaml:"x_frame_options"`

        // HSTSMaxAge sets the `Strict-Transport-Security` header to indicate how
        // long (in seconds) browsers should remember that this site is only to
        // be accessed using HTTPS. This reduces your exposure to some SSL-stripping
        // man-in-the-middle (MITM) attacks.
        // Optional. Default value 0.
        HSTSMaxAge int `yaml:"hsts_max_age"`

        // HSTSExcludeSubdomains won't include subdomains tag in the `Strict Transport Security`
        // header, excluding all subdomains from security policy. It has no effect
        // unless HSTSMaxAge is set to a non-zero value.
        // Optional. Default value false.
        HSTSExcludeSubdomains bool `yaml:"hsts_exclude_subdomains"`

        // ContentSecurityPolicy sets the `Content-Security-Policy` header providing
        // security against cross-site scripting (XSS), clickjacking and other code
        // injection attacks resulting from execution of malicious content in the
        // trusted web page context.
        // Optional. Default value "".
        ContentSecurityPolicy string `yaml:"content_security_policy"`

        // CSPReportOnly would use the `Content-Security-Policy-Report-Only` header instead
        // of the `Content-Security-Policy` header. This allows iterative updates of the
        // content security policy by only reporting the violations that would
        // have occurred instead of blocking the resource.
        // Optional. Default value false.
        CSPReportOnly bool `yaml:"csp_report_only"`

        // HSTSPreloadEnabled will add the preload tag in the `Strict Transport Security`
        // header, which enables the domain to be included in the HSTS preload list
        // maintained by Chrome (and used by Firefox and Safari): https://hstspreload.org/
        // Optional.  Default value false.
        HSTSPreloadEnabled bool `yaml:"hsts_preload_enabled"`

        // ReferrerPolicy sets the `Referrer-Policy` header providing security against
        // leaking potentially sensitive request paths to third parties.
        // Optional. Default value "".
        ReferrerPolicy string `yaml:"referrer_policy"`
}

// DefaultSecureConfig is the default Secure middleware config.
var DefaultSecureConfig = SecureConfig{
        Skipper:            DefaultSkipper,
        XSSProtection:      "1; mode=block",
        ContentTypeNosniff: "nosniff",
        XFrameOptions:      "SAMEORIGIN",
        HSTSPreloadEnabled: false,
}

// Secure returns a Secure middleware.
// Secure middleware provides protection against cross-site scripting (XSS) attack,
// content type sniffing, clickjacking, insecure connection and other code injection
// attacks.
func Secure() echo.MiddlewareFunc <span class="cov8" title="1">{
        return SecureWithConfig(DefaultSecureConfig)
}</span>

// SecureWithConfig returns a Secure middleware with config.
// See: `Secure()`.
func SecureWithConfig(config SecureConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultSecureConfig.Skipper
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        res := c.Response()

                        if config.XSSProtection != "" </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderXXSSProtection, config.XSSProtection)
                        }</span>
                        <span class="cov8" title="1">if config.ContentTypeNosniff != "" </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderXContentTypeOptions, config.ContentTypeNosniff)
                        }</span>
                        <span class="cov8" title="1">if config.XFrameOptions != "" </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderXFrameOptions, config.XFrameOptions)
                        }</span>
                        <span class="cov8" title="1">if (c.IsTLS() || (req.Header.Get(echo.HeaderXForwardedProto) == "https")) &amp;&amp; config.HSTSMaxAge != 0 </span><span class="cov8" title="1">{
                                subdomains := ""
                                if !config.HSTSExcludeSubdomains </span><span class="cov8" title="1">{
                                        subdomains = "; includeSubdomains"
                                }</span>
                                <span class="cov8" title="1">if config.HSTSPreloadEnabled </span><span class="cov8" title="1">{
                                        subdomains = fmt.Sprintf("%s; preload", subdomains)
                                }</span>
                                <span class="cov8" title="1">res.Header().Set(echo.HeaderStrictTransportSecurity, fmt.Sprintf("max-age=%d%s", config.HSTSMaxAge, subdomains))</span>
                        }
                        <span class="cov8" title="1">if config.ContentSecurityPolicy != "" </span><span class="cov8" title="1">{
                                if config.CSPReportOnly </span><span class="cov8" title="1">{
                                        res.Header().Set(echo.HeaderContentSecurityPolicyReportOnly, config.ContentSecurityPolicy)
                                }</span> else<span class="cov8" title="1"> {
                                        res.Header().Set(echo.HeaderContentSecurityPolicy, config.ContentSecurityPolicy)
                                }</span>
                        }
                        <span class="cov8" title="1">if config.ReferrerPolicy != "" </span><span class="cov8" title="1">{
                                res.Header().Set(echo.HeaderReferrerPolicy, config.ReferrerPolicy)
                        }</span>
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "strings"

        "github.com/labstack/echo/v4"
)

// TrailingSlashConfig defines the config for TrailingSlash middleware.
type TrailingSlashConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Status code to be used when redirecting the request.
        // Optional, but when provided the request is redirected using this code.
        RedirectCode int `yaml:"redirect_code"`
}

// DefaultTrailingSlashConfig is the default TrailingSlash middleware config.
var DefaultTrailingSlashConfig = TrailingSlashConfig{
        Skipper: DefaultSkipper,
}

// AddTrailingSlash returns a root level (before router) middleware which adds a
// trailing slash to the request `URL#Path`.
//
// Usage `Echo#Pre(AddTrailingSlash())`
func AddTrailingSlash() echo.MiddlewareFunc <span class="cov8" title="1">{
        return AddTrailingSlashWithConfig(DefaultTrailingSlashConfig)
}</span>

// AddTrailingSlashWithConfig returns an AddTrailingSlash middleware with config.
// See `AddTrailingSlash()`.
func AddTrailingSlashWithConfig(config TrailingSlashConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultTrailingSlashConfig.Skipper
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        url := req.URL
                        path := url.Path
                        qs := c.QueryString()
                        if !strings.HasSuffix(path, "/") </span><span class="cov8" title="1">{
                                path += "/"
                                uri := path
                                if qs != "" </span><span class="cov8" title="1">{
                                        uri += "?" + qs
                                }</span>

                                // Redirect
                                <span class="cov8" title="1">if config.RedirectCode != 0 </span><span class="cov8" title="1">{
                                        return c.Redirect(config.RedirectCode, sanitizeURI(uri))
                                }</span>

                                // Forward
                                <span class="cov8" title="1">req.RequestURI = uri
                                url.Path = path</span>
                        }
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// RemoveTrailingSlash returns a root level (before router) middleware which removes
// a trailing slash from the request URI.
//
// Usage `Echo#Pre(RemoveTrailingSlash())`
func RemoveTrailingSlash() echo.MiddlewareFunc <span class="cov8" title="1">{
        return RemoveTrailingSlashWithConfig(TrailingSlashConfig{})
}</span>

// RemoveTrailingSlashWithConfig returns a RemoveTrailingSlash middleware with config.
// See `RemoveTrailingSlash()`.
func RemoveTrailingSlashWithConfig(config TrailingSlashConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultTrailingSlashConfig.Skipper
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">req := c.Request()
                        url := req.URL
                        path := url.Path
                        qs := c.QueryString()
                        l := len(path) - 1
                        if l &gt; 0 &amp;&amp; strings.HasSuffix(path, "/") </span><span class="cov8" title="1">{
                                path = path[:l]
                                uri := path
                                if qs != "" </span><span class="cov8" title="1">{
                                        uri += "?" + qs
                                }</span>

                                // Redirect
                                <span class="cov8" title="1">if config.RedirectCode != 0 </span><span class="cov8" title="1">{
                                        return c.Redirect(config.RedirectCode, sanitizeURI(uri))
                                }</span>

                                // Forward
                                <span class="cov8" title="1">req.RequestURI = uri
                                url.Path = path</span>
                        }
                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

func sanitizeURI(uri string) string <span class="cov8" title="1">{
        // double slash `\\`, `//` or even `\/` is absolute uri for browsers and by redirecting request to that uri
        // we are vulnerable to open redirect attack. so replace all slashes from the beginning with single slash
        if len(uri) &gt; 1 &amp;&amp; (uri[0] == '\\' || uri[0] == '/') &amp;&amp; (uri[1] == '\\' || uri[1] == '/') </span><span class="cov8" title="1">{
                uri = "/" + strings.TrimLeft(uri, `/\`)
        }</span>
        <span class="cov8" title="1">return uri</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "errors"
        "fmt"
        "html/template"
        "net/http"
        "net/url"
        "os"
        "path"
        "strings"

        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/bytes"
)

// StaticConfig defines the config for Static middleware.
type StaticConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // Root directory from where the static content is served.
        // Required.
        Root string `yaml:"root"`

        // Index file for serving a directory.
        // Optional. Default value "index.html".
        Index string `yaml:"index"`

        // Enable HTML5 mode by forwarding all not-found requests to root so that
        // SPA (single-page application) can handle the routing.
        // Optional. Default value false.
        HTML5 bool `yaml:"html5"`

        // Enable directory browsing.
        // Optional. Default value false.
        Browse bool `yaml:"browse"`

        // Enable ignoring of the base of the URL path.
        // Example: when assigning a static middleware to a non root path group,
        // the filesystem path is not doubled
        // Optional. Default value false.
        IgnoreBase bool `yaml:"ignoreBase"`

        // Filesystem provides access to the static content.
        // Optional. Defaults to http.Dir(config.Root)
        Filesystem http.FileSystem `yaml:"-"`
}

const html = `
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
  &lt;title&gt;{{ .Name }}&lt;/title&gt;
  &lt;style&gt;
    body {
                        font-family: Menlo, Consolas, monospace;
                        padding: 48px;
                }
                header {
                        padding: 4px 16px;
                        font-size: 24px;
                }
    ul {
                        list-style-type: none;
                        margin: 0;
            padding: 20px 0 0 0;
                        display: flex;
                        flex-wrap: wrap;
    }
    li {
                        width: 300px;
                        padding: 16px;
                }
                li a {
                        display: block;
                        overflow: hidden;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        text-decoration: none;
                        transition: opacity 0.25s;
                }
                li span {
                        color: #707070;
                        font-size: 12px;
                }
                li a:hover {
                        opacity: 0.50;
                }
                .dir {
                        color: #E91E63;
                }
                .file {
                        color: #673AB7;
                }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
        &lt;header&gt;
                {{ .Name }}
        &lt;/header&gt;
        &lt;ul&gt;
                {{ range .Files }}
                &lt;li&gt;
                {{ if .Dir }}
                        {{ $name := print .Name "/" }}
                        &lt;a class="dir" href="{{ $name }}"&gt;{{ $name }}&lt;/a&gt;
                        {{ else }}
                        &lt;a class="file" href="{{ .Name }}"&gt;{{ .Name }}&lt;/a&gt;
                        &lt;span&gt;{{ .Size }}&lt;/span&gt;
                {{ end }}
                &lt;/li&gt;
                {{ end }}
  &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
`

// DefaultStaticConfig is the default Static middleware config.
var DefaultStaticConfig = StaticConfig{
        Skipper: DefaultSkipper,
        Index:   "index.html",
}

// Static returns a Static middleware to serves static content from the provided
// root directory.
func Static(root string) echo.MiddlewareFunc <span class="cov0" title="0">{
        c := DefaultStaticConfig
        c.Root = root
        return StaticWithConfig(c)
}</span>

// StaticWithConfig returns a Static middleware with config.
// See `Static()`.
func StaticWithConfig(config StaticConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        // Defaults
        if config.Root == "" </span><span class="cov0" title="0">{
                config.Root = "." // For security we want to restrict to CWD.
        }</span>
        <span class="cov8" title="1">if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultStaticConfig.Skipper
        }</span>
        <span class="cov8" title="1">if config.Index == "" </span><span class="cov8" title="1">{
                config.Index = DefaultStaticConfig.Index
        }</span>
        <span class="cov8" title="1">if config.Filesystem == nil </span><span class="cov8" title="1">{
                config.Filesystem = http.Dir(config.Root)
                config.Root = "."
        }</span>

        // Index template
        <span class="cov8" title="1">t, tErr := template.New("index").Parse(html)
        if tErr != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("echo: %w", tErr))</span>
        }

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) (err error) </span><span class="cov8" title="1">{
                        if config.Skipper(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">p := c.Request().URL.Path
                        if strings.HasSuffix(c.Path(), "*") </span><span class="cov8" title="1">{ // When serving from a group, e.g. `/static*`.
                                p = c.Param("*")
                        }</span>
                        <span class="cov8" title="1">p, err = url.PathUnescape(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">name := path.Join(config.Root, path.Clean("/"+p)) // "/"+ for security

                        if config.IgnoreBase </span><span class="cov8" title="1">{
                                routePath := path.Base(strings.TrimRight(c.Path(), "/*"))
                                baseURLPath := path.Base(p)
                                if baseURLPath == routePath </span><span class="cov0" title="0">{
                                        i := strings.LastIndex(name, routePath)
                                        name = name[:i] + strings.Replace(name[i:], routePath, "", 1)
                                }</span>
                        }

                        <span class="cov8" title="1">file, err := config.Filesystem.Open(name)
                        if err != nil </span><span class="cov8" title="1">{
                                if !isIgnorableOpenFileError(err) </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                // file with that path did not exist, so we continue down in middleware/handler chain, hoping that we end up in
                                // handler that is meant to handle this request
                                <span class="cov8" title="1">if err = next(c); err == nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">var he *echo.HTTPError
                                if !(errors.As(err, &amp;he) &amp;&amp; config.HTML5 &amp;&amp; he.Code == http.StatusNotFound) </span><span class="cov8" title="1">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">file, err = config.Filesystem.Open(path.Join(config.Root, config.Index))
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">defer file.Close()

                        info, err := file.Stat()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                                index, err := config.Filesystem.Open(path.Join(name, config.Index))
                                if err != nil </span><span class="cov8" title="1">{
                                        if config.Browse </span><span class="cov8" title="1">{
                                                return listDir(t, name, file, c.Response())
                                        }</span>

                                        <span class="cov0" title="0">return next(c)</span>
                                }

                                <span class="cov8" title="1">defer index.Close()

                                info, err = index.Stat()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">return serveFile(c, index, info)</span>
                        }

                        <span class="cov8" title="1">return serveFile(c, file, info)</span>
                }
        }
}

func serveFile(c echo.Context, file http.File, info os.FileInfo) error <span class="cov8" title="1">{
        http.ServeContent(c.Response(), c.Request(), info.Name(), info.ModTime(), file)
        return nil
}</span>

func listDir(t *template.Template, name string, dir http.File, res *echo.Response) (err error) <span class="cov8" title="1">{
        files, err := dir.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create directory index
        <span class="cov8" title="1">res.Header().Set(echo.HeaderContentType, echo.MIMETextHTMLCharsetUTF8)
        data := struct {
                Name  string
                Files []interface{}
        }{
                Name: name,
        }
        for _, f := range files </span><span class="cov8" title="1">{
                data.Files = append(data.Files, struct {
                        Name string
                        Dir  bool
                        Size string
                }{f.Name(), f.IsDir(), bytes.Format(f.Size())})
        }</span>
        <span class="cov8" title="1">return t.Execute(res, data)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "os"
)

// We ignore these errors as there could be handler that matches request path.
//
// As of Go 1.20 filepath.Clean has different behaviour on OS related filesystems so we need to use path.Clean
// on Windows which has some caveats. The Open methods might return different errors than earlier versions and
// as of 1.20 path checks are more strict on the provided path and considers [UNC](https://en.wikipedia.org/wiki/Path_(computing)#UNC)
// paths with missing host etc parts as invalid. Previously it would result you `fs.ErrNotExist`.
//
// For 1.20@Windows we need to treat those errors the same as `fs.ErrNotExists` so we can continue handling
// errors in the middleware/handler chain. Otherwise we might end up with status 500 instead of finding a route
// or return 404 not found.
func isIgnorableOpenFileError(err error) bool <span class="cov8" title="1">{
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">errTxt := err.Error()
        return errTxt == "http: invalid or unsafe file path" || errTxt == "invalid path"</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "context"
        "github.com/labstack/echo/v4"
        "net/http"
        "sync"
        "time"
)

// ---------------------------------------------------------------------------------------------------------------
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING: Timeout middleware causes more problems than it solves.
// WARNING: This middleware should be first middleware as it messes with request Writer and could cause data race if
//                                         it is in other position
//
// Depending on out requirements you could be better of setting timeout to context and
// check its deadline from handler.
//
// For example: create middleware to set timeout to context
// func RequestTimeout(timeout time.Duration) echo.MiddlewareFunc {
//        return func(next echo.HandlerFunc) echo.HandlerFunc {
//                return func(c echo.Context) error {
//                        timeoutCtx, cancel := context.WithTimeout(c.Request().Context(), timeout)
//                        c.SetRequest(c.Request().WithContext(timeoutCtx))
//                        defer cancel()
//                        return next(c)
//                }
//        }
//}
//
// Create handler that checks for context deadline and runs actual task in separate coroutine
// Note: separate coroutine may not be even if you do not want to process continue executing and
// just want to stop long-running handler to stop and you are using "context aware" methods (ala db queries with ctx)
//         e.GET("/", func(c echo.Context) error {
//
//                doneCh := make(chan error)
//                go func(ctx context.Context) {
//                        doneCh &lt;- myPossiblyLongRunningBackgroundTaskWithCtx(ctx)
//                }(c.Request().Context())
//
//                select { // wait for task to finish or context to timeout/cancelled
//                case err := &lt;-doneCh:
//                        if err != nil {
//                                return err
//                        }
//                        return c.String(http.StatusOK, "OK")
//                case &lt;-c.Request().Context().Done():
//                        if c.Request().Context().Err() == context.DeadlineExceeded {
//                                return c.String(http.StatusServiceUnavailable, "timeout")
//                        }
//                        return c.Request().Context().Err()
//                }
//
//        })
//

// TimeoutConfig defines the config for Timeout middleware.
type TimeoutConfig struct {
        // Skipper defines a function to skip middleware.
        Skipper Skipper

        // ErrorMessage is written to response on timeout in addition to http.StatusServiceUnavailable (503) status code
        // It can be used to define a custom timeout error message
        ErrorMessage string

        // OnTimeoutRouteErrorHandler is an error handler that is executed for error that was returned from wrapped route after
        // request timeouted and we already had sent the error code (503) and message response to the client.
        // NB: do not write headers/body inside this handler. The response has already been sent to the client and response writer
        // will not accept anything no more. If you want to know what actual route middleware timeouted use `c.Path()`
        OnTimeoutRouteErrorHandler func(err error, c echo.Context)

        // Timeout configures a timeout for the middleware, defaults to 0 for no timeout
        // NOTE: when difference between timeout duration and handler execution time is almost the same (in range of 100microseconds)
        // the result of timeout does not seem to be reliable - could respond timeout, could respond handler output
        // difference over 500microseconds (0.5millisecond) response seems to be reliable
        Timeout time.Duration
}

// DefaultTimeoutConfig is the default Timeout middleware config.
var DefaultTimeoutConfig = TimeoutConfig{
        Skipper:      DefaultSkipper,
        Timeout:      0,
        ErrorMessage: "",
}

// Timeout returns a middleware which returns error (503 Service Unavailable error) to client immediately when handler
// call runs for longer than its time limit. NB: timeout does not stop handler execution.
func Timeout() echo.MiddlewareFunc <span class="cov8" title="1">{
        return TimeoutWithConfig(DefaultTimeoutConfig)
}</span>

// TimeoutWithConfig returns a Timeout middleware with config or panics on invalid configuration.
func TimeoutWithConfig(config TimeoutConfig) echo.MiddlewareFunc <span class="cov8" title="1">{
        mw, err := config.ToMiddleware()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return mw</span>
}

// ToMiddleware converts Config to middleware or returns an error for invalid configuration
func (config TimeoutConfig) ToMiddleware() (echo.MiddlewareFunc, error) <span class="cov8" title="1">{
        if config.Skipper == nil </span><span class="cov8" title="1">{
                config.Skipper = DefaultTimeoutConfig.Skipper
        }</span>

        <span class="cov8" title="1">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        if config.Skipper(c) || config.Timeout == 0 </span><span class="cov8" title="1">{
                                return next(c)
                        }</span>

                        <span class="cov8" title="1">errChan := make(chan error, 1)
                        handlerWrapper := echoHandlerFuncWrapper{
                                writer:     &amp;ignorableWriter{ResponseWriter: c.Response().Writer},
                                ctx:        c,
                                handler:    next,
                                errChan:    errChan,
                                errHandler: config.OnTimeoutRouteErrorHandler,
                        }
                        handler := http.TimeoutHandler(handlerWrapper, config.Timeout, config.ErrorMessage)
                        handler.ServeHTTP(handlerWrapper.writer, c.Request())

                        select </span>{
                        case err := &lt;-errChan:<span class="cov8" title="1">
                                return err</span>
                        default:<span class="cov8" title="1">
                                return nil</span>
                        }
                }
        }, nil
}

type echoHandlerFuncWrapper struct {
        writer     *ignorableWriter
        ctx        echo.Context
        handler    echo.HandlerFunc
        errHandler func(err error, c echo.Context)
        errChan    chan error
}

func (t echoHandlerFuncWrapper) ServeHTTP(rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // replace echo.Context Request with the one provided by TimeoutHandler to let later middlewares/handler on the chain
        // handle properly it's cancellation
        t.ctx.SetRequest(r)

        // replace writer with TimeoutHandler custom one. This will guarantee that
        // `writes by h to its ResponseWriter will return ErrHandlerTimeout.`
        originalWriter := t.ctx.Response().Writer
        t.ctx.Response().Writer = rw

        // in case of panic we restore original writer and call panic again
        // so it could be handled with global middleware Recover()
        defer func() </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span><span class="cov8" title="1">{
                        t.ctx.Response().Writer = originalWriter
                        panic(err)</span>
                }
        }()

        <span class="cov8" title="1">err := t.handler(t.ctx)
        if ctxErr := r.Context().Err(); ctxErr == context.DeadlineExceeded </span><span class="cov8" title="1">{
                if err != nil &amp;&amp; t.errHandler != nil </span><span class="cov8" title="1">{
                        t.errHandler(err, t.ctx)
                }</span>
                <span class="cov8" title="1">return</span> // on timeout we can not send handler error to client because `http.TimeoutHandler` has already sent headers
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // This is needed as `http.TimeoutHandler` will write status code by itself on error and after that our tries to write
                // status code will not work anymore as Echo.Response thinks it has been already "committed" and further writes
                // create errors in log about `superfluous response.WriteHeader call from`
                t.writer.Ignore(true)
                t.ctx.Response().Writer = originalWriter // make sure we restore writer before we signal original coroutine about the error
                // we pass error from handler to middlewares up in handler chain to act on it if needed.
                t.errChan &lt;- err
                return
        }</span>
        // we restore original writer only for cases we did not timeout. On timeout we have already sent response to client
        // and should not anymore send additional headers/data
        // so on timeout writer stays what http.TimeoutHandler uses and prevents writing headers/body
        <span class="cov8" title="1">t.ctx.Response().Writer = originalWriter</span>
}

// ignorableWriter is ResponseWriter implementations that allows us to mark writer to ignore further write calls. This
// is handy in cases when you do not have direct control of code being executed (3rd party middleware) but want to make
// sure that external code will not be able to write response to the client.
// Writer is coroutine safe for writes.
type ignorableWriter struct {
        http.ResponseWriter

        lock         sync.Mutex
        ignoreWrites bool
}

func (w *ignorableWriter) Ignore(ignore bool) <span class="cov8" title="1">{
        w.lock.Lock()
        w.ignoreWrites = ignore
        w.lock.Unlock()
}</span>

func (w *ignorableWriter) WriteHeader(code int) <span class="cov8" title="1">{
        w.lock.Lock()
        defer w.lock.Unlock()
        if w.ignoreWrites </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">w.ResponseWriter.WriteHeader(code)</span>
}

func (w *ignorableWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        w.lock.Lock()
        defer w.lock.Unlock()
        if w.ignoreWrites </span><span class="cov8" title="1">{
                return len(b), nil
        }</span>
        <span class="cov8" title="1">return w.ResponseWriter.Write(b)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package middleware

import (
        "bufio"
        "crypto/rand"
        "io"
        "strings"
        "sync"
)

func matchScheme(domain, pattern string) bool <span class="cov8" title="1">{
        didx := strings.Index(domain, ":")
        pidx := strings.Index(pattern, ":")
        return didx != -1 &amp;&amp; pidx != -1 &amp;&amp; domain[:didx] == pattern[:pidx]
}</span>

// matchSubdomain compares authority with wildcard
func matchSubdomain(domain, pattern string) bool <span class="cov8" title="1">{
        if !matchScheme(domain, pattern) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">didx := strings.Index(domain, "://")
        pidx := strings.Index(pattern, "://")
        if didx == -1 || pidx == -1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">domAuth := domain[didx+3:]
        // to avoid long loop by invalid long domain
        if len(domAuth) &gt; 253 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">patAuth := pattern[pidx+3:]

        domComp := strings.Split(domAuth, ".")
        patComp := strings.Split(patAuth, ".")
        for i := len(domComp)/2 - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                opp := len(domComp) - 1 - i
                domComp[i], domComp[opp] = domComp[opp], domComp[i]
        }</span>
        <span class="cov8" title="1">for i := len(patComp)/2 - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                opp := len(patComp) - 1 - i
                patComp[i], patComp[opp] = patComp[opp], patComp[i]
        }</span>

        <span class="cov8" title="1">for i, v := range domComp </span><span class="cov8" title="1">{
                if len(patComp) &lt;= i </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">p := patComp[i]
                if p == "*" </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if p != v </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// https://tip.golang.org/doc/go1.19#:~:text=Read%20no%20longer%20buffers%20random%20data%20obtained%20from%20the%20operating%20system%20between%20calls
var randomReaderPool = sync.Pool{New: func() interface{} <span class="cov8" title="1">{
        return bufio.NewReader(rand.Reader)
}</span>}

const randomStringCharset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
const randomStringCharsetLen = 52 // len(randomStringCharset)
const randomStringMaxByte = 255 - (256 % randomStringCharsetLen)

func randomString(length uint8) string <span class="cov8" title="1">{
        reader := randomReaderPool.Get().(*bufio.Reader)
        defer randomReaderPool.Put(reader)

        b := make([]byte, length)
        r := make([]byte, length+(length/4)) // perf: avoid read from rand.Reader many times
        var i uint8 = 0

        // security note:
        // we can't just simply do b[i]=randomStringCharset[rb%len(randomStringCharset)],
        // len(len(randomStringCharset)) is 52, and rb is [0, 255], 256 = 52 * 4 + 48.
        // make the first 48 characters more possibly to be generated then others.
        // So we have to skip bytes when rb &gt; randomStringMaxByte

        for </span><span class="cov8" title="1">{
                _, err := io.ReadFull(reader, r)
                if err != nil </span><span class="cov0" title="0">{
                        panic("unexpected error happened when reading from bufio.NewReader(crypto/rand.Reader)")</span>
                }
                <span class="cov8" title="1">for _, rb := range r </span><span class="cov8" title="1">{
                        if rb &gt; randomStringMaxByte </span><span class="cov8" title="1">{
                                // Skip this number to avoid bias.
                                continue</span>
                        }
                        <span class="cov8" title="1">b[i] = randomStringCharset[rb%randomStringCharsetLen]
                        i++
                        if i == length </span><span class="cov8" title="1">{
                                return string(b)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package echo

import "io"

// Renderer is the interface that wraps the Render function.
type Renderer interface {
        Render(io.Writer, string, interface{}, Context) error
}

// TemplateRenderer is helper to ease creating renderers for `html/template` and `text/template` packages.
// Example usage:
//
//                e.Renderer = &amp;echo.TemplateRenderer{
//                        Template: template.Must(template.ParseGlob("templates/*.html")),
//                }
//
//          e.Renderer = &amp;echo.TemplateRenderer{
//                        Template: template.Must(template.New("hello").Parse("Hello, {{.}}!")),
//                }
type TemplateRenderer struct {
        Template interface {
                ExecuteTemplate(wr io.Writer, name string, data any) error
        }
}

// Render renders the template with given data.
func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c Context) error <span class="cov8" title="1">{
        return t.Template.ExecuteTemplate(w, name, data)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "bufio"
        "errors"
        "net"
        "net/http"
)

// Response wraps an http.ResponseWriter and implements its interface to be used
// by an HTTP handler to construct an HTTP response.
// See: https://golang.org/pkg/net/http/#ResponseWriter
type Response struct {
        Writer      http.ResponseWriter
        echo        *Echo
        beforeFuncs []func()
        afterFuncs  []func()
        Status      int
        Size        int64
        Committed   bool
}

// NewResponse creates a new instance of Response.
func NewResponse(w http.ResponseWriter, e *Echo) (r *Response) <span class="cov8" title="1">{
        return &amp;Response{Writer: w, echo: e}
}</span>

// Header returns the header map for the writer that will be sent by
// WriteHeader. Changing the header after a call to WriteHeader (or Write) has
// no effect unless the modified headers were declared as trailers by setting
// the "Trailer" header before the call to WriteHeader (see example)
// To suppress implicit response headers, set their value to nil.
// Example: https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
func (r *Response) Header() http.Header <span class="cov8" title="1">{
        return r.Writer.Header()
}</span>

// Before registers a function which is called just before the response is written.
func (r *Response) Before(fn func()) <span class="cov8" title="1">{
        r.beforeFuncs = append(r.beforeFuncs, fn)
}</span>

// After registers a function which is called just after the response is written.
// If the `Content-Length` is unknown, none of the after function is executed.
func (r *Response) After(fn func()) <span class="cov8" title="1">{
        r.afterFuncs = append(r.afterFuncs, fn)
}</span>

// WriteHeader sends an HTTP response header with status code. If WriteHeader is
// not called explicitly, the first call to Write will trigger an implicit
// WriteHeader(http.StatusOK). Thus explicit calls to WriteHeader are mainly
// used to send error codes.
func (r *Response) WriteHeader(code int) <span class="cov8" title="1">{
        if r.Committed </span><span class="cov0" title="0">{
                r.echo.Logger.Warn("response already committed")
                return
        }</span>
        <span class="cov8" title="1">r.Status = code
        for _, fn := range r.beforeFuncs </span><span class="cov8" title="1">{
                fn()
        }</span>
        <span class="cov8" title="1">r.Writer.WriteHeader(r.Status)
        r.Committed = true</span>
}

// Write writes the data to the connection as part of an HTTP reply.
func (r *Response) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        if !r.Committed </span><span class="cov8" title="1">{
                if r.Status == 0 </span><span class="cov8" title="1">{
                        r.Status = http.StatusOK
                }</span>
                <span class="cov8" title="1">r.WriteHeader(r.Status)</span>
        }
        <span class="cov8" title="1">n, err = r.Writer.Write(b)
        r.Size += int64(n)
        for _, fn := range r.afterFuncs </span><span class="cov8" title="1">{
                fn()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Flush implements the http.Flusher interface to allow an HTTP handler to flush
// buffered data to the client.
// See [http.Flusher](https://golang.org/pkg/net/http/#Flusher)
func (r *Response) Flush() <span class="cov8" title="1">{
        err := http.NewResponseController(r.Writer).Flush()
        if err != nil &amp;&amp; errors.Is(err, http.ErrNotSupported) </span><span class="cov8" title="1">{
                panic(errors.New("response writer flushing is not supported"))</span>
        }
}

// Hijack implements the http.Hijacker interface to allow an HTTP handler to
// take over the connection.
// See [http.Hijacker](https://golang.org/pkg/net/http/#Hijacker)
func (r *Response) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        return http.NewResponseController(r.Writer).Hijack()
}</span>

// Unwrap returns the original http.ResponseWriter.
// ResponseController can be used to access the original http.ResponseWriter.
// See [https://go.dev/blog/go1.20]
func (r *Response) Unwrap() http.ResponseWriter <span class="cov8" title="1">{
        return r.Writer
}</span>

func (r *Response) reset(w http.ResponseWriter) <span class="cov8" title="1">{
        r.beforeFuncs = nil
        r.afterFuncs = nil
        r.Writer = w
        r.Size = 0
        r.Status = http.StatusOK
        r.Committed = false
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Â© 2015 LabStack LLC and Echo contributors

package echo

import (
        "bytes"
        "fmt"
        "net/http"
)

// Router is the registry of all registered routes for an `Echo` instance for
// request matching and URL path parameter parsing.
type Router struct {
        tree   *node
        routes map[string]*Route
        echo   *Echo
}

type node struct {
        methods    *routeMethods
        parent     *node
        paramChild *node
        anyChild   *node
        // notFoundHandler is handler registered with RouteNotFound method and is executed for 404 cases
        notFoundHandler *routeMethod
        prefix          string
        originalPath    string
        staticChildren  children
        paramsCount     int
        label           byte
        kind            kind
        // isLeaf indicates that node does not have child routes
        isLeaf bool
        // isHandler indicates that node has at least one handler registered to it
        isHandler bool
}

type kind uint8
type children []*node

type routeMethod struct {
        handler HandlerFunc
        ppath   string
        pnames  []string
}

type routeMethods struct {
        connect     *routeMethod
        delete      *routeMethod
        get         *routeMethod
        head        *routeMethod
        options     *routeMethod
        patch       *routeMethod
        post        *routeMethod
        propfind    *routeMethod
        put         *routeMethod
        trace       *routeMethod
        report      *routeMethod
        anyOther    map[string]*routeMethod
        allowHeader string
}

const (
        staticKind kind = iota
        paramKind
        anyKind

        paramLabel = byte(':')
        anyLabel   = byte('*')
)

func (m *routeMethods) isHandler() bool <span class="cov8" title="1">{
        return m.connect != nil ||
                m.delete != nil ||
                m.get != nil ||
                m.head != nil ||
                m.options != nil ||
                m.patch != nil ||
                m.post != nil ||
                m.propfind != nil ||
                m.put != nil ||
                m.trace != nil ||
                m.report != nil ||
                len(m.anyOther) != 0
        // RouteNotFound/404 is not considered as a handler
}</span>

func (m *routeMethods) updateAllowHeader() <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        buf.WriteString(http.MethodOptions)

        if m.connect != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodConnect)
        }</span>
        <span class="cov8" title="1">if m.delete != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodDelete)
        }</span>
        <span class="cov8" title="1">if m.get != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodGet)
        }</span>
        <span class="cov8" title="1">if m.head != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodHead)
        }</span>
        <span class="cov8" title="1">if m.patch != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodPatch)
        }</span>
        <span class="cov8" title="1">if m.post != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodPost)
        }</span>
        <span class="cov8" title="1">if m.propfind != nil </span><span class="cov8" title="1">{
                buf.WriteString(", PROPFIND")
        }</span>
        <span class="cov8" title="1">if m.put != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodPut)
        }</span>
        <span class="cov8" title="1">if m.trace != nil </span><span class="cov8" title="1">{
                buf.WriteString(", ")
                buf.WriteString(http.MethodTrace)
        }</span>
        <span class="cov8" title="1">if m.report != nil </span><span class="cov8" title="1">{
                buf.WriteString(", REPORT")
        }</span>
        <span class="cov8" title="1">for method := range m.anyOther </span><span class="cov8" title="1">{ // for simplicity, we use map and therefore order is not deterministic here
                buf.WriteString(", ")
                buf.WriteString(method)
        }</span>
        <span class="cov8" title="1">m.allowHeader = buf.String()</span>
}

// NewRouter returns a new Router instance.
func NewRouter(e *Echo) *Router <span class="cov8" title="1">{
        return &amp;Router{
                tree: &amp;node{
                        methods: new(routeMethods),
                },
                routes: map[string]*Route{},
                echo:   e,
        }
}</span>

// Routes returns the registered routes.
func (r *Router) Routes() []*Route <span class="cov8" title="1">{
        routes := make([]*Route, 0, len(r.routes))
        for _, v := range r.routes </span><span class="cov8" title="1">{
                routes = append(routes, v)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// Reverse generates a URL from route name and provided parameters.
func (r *Router) Reverse(name string, params ...interface{}) string <span class="cov8" title="1">{
        uri := new(bytes.Buffer)
        ln := len(params)
        n := 0
        for _, route := range r.routes </span><span class="cov8" title="1">{
                if route.Name == name </span><span class="cov8" title="1">{
                        for i, l := 0, len(route.Path); i &lt; l; i++ </span><span class="cov8" title="1">{
                                hasBackslash := route.Path[i] == '\\'
                                if hasBackslash &amp;&amp; i+1 &lt; l &amp;&amp; route.Path[i+1] == ':' </span><span class="cov8" title="1">{
                                        i++ // backslash before colon escapes that colon. in that case skip backslash
                                }</span>
                                <span class="cov8" title="1">if n &lt; ln &amp;&amp; (route.Path[i] == '*' || (!hasBackslash &amp;&amp; route.Path[i] == ':')) </span><span class="cov8" title="1">{
                                        // in case of `*` wildcard or `:` (unescaped colon) param we replace everything till next slash or end of path
                                        for ; i &lt; l &amp;&amp; route.Path[i] != '/'; i++ </span>{<span class="cov8" title="1">
                                        }</span>
                                        <span class="cov8" title="1">uri.WriteString(fmt.Sprintf("%v", params[n]))
                                        n++</span>
                                }
                                <span class="cov8" title="1">if i &lt; l </span><span class="cov8" title="1">{
                                        uri.WriteByte(route.Path[i])
                                }</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return uri.String()</span>
}

func normalizePathSlash(path string) string <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                path = "/"
        }</span> else<span class="cov8" title="1"> if path[0] != '/' </span><span class="cov8" title="1">{
                path = "/" + path
        }</span>
        <span class="cov8" title="1">return path</span>
}

func (r *Router) add(method, path, name string, h HandlerFunc) *Route <span class="cov8" title="1">{
        path = normalizePathSlash(path)
        r.insert(method, path, h)

        route := &amp;Route{
                Method: method,
                Path:   path,
                Name:   name,
        }
        r.routes[method+path] = route
        return route
}</span>

// Add registers a new route for method and path with matching handler.
func (r *Router) Add(method, path string, h HandlerFunc) <span class="cov8" title="1">{
        r.insert(method, normalizePathSlash(path), h)
}</span>

func (r *Router) insert(method, path string, h HandlerFunc) <span class="cov8" title="1">{
        path = normalizePathSlash(path)
        pnames := []string{} // Param names
        ppath := path        // Pristine path

        if h == nil &amp;&amp; r.echo.Logger != nil </span><span class="cov0" title="0">{
                // FIXME: in future we should return error
                r.echo.Logger.Errorf("Adding route without handler function: %v:%v", method, path)
        }</span>

        <span class="cov8" title="1">for i, lcpIndex := 0, len(path); i &lt; lcpIndex; i++ </span><span class="cov8" title="1">{
                if path[i] == ':' </span><span class="cov8" title="1">{
                        if i &gt; 0 &amp;&amp; path[i-1] == '\\' </span><span class="cov8" title="1">{
                                path = path[:i-1] + path[i:]
                                i--
                                lcpIndex--
                                continue</span>
                        }
                        <span class="cov8" title="1">j := i + 1

                        r.insertNode(method, path[:i], staticKind, routeMethod{})
                        for ; i &lt; lcpIndex &amp;&amp; path[i] != '/'; i++ </span>{<span class="cov8" title="1">
                        }</span>

                        <span class="cov8" title="1">pnames = append(pnames, path[j:i])
                        path = path[:j] + path[i:]
                        i, lcpIndex = j, len(path)

                        if i == lcpIndex </span><span class="cov8" title="1">{
                                // path node is last fragment of route path. ie. `/users/:id`
                                r.insertNode(method, path[:i], paramKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})
                        }</span> else<span class="cov8" title="1"> {
                                r.insertNode(method, path[:i], paramKind, routeMethod{})
                        }</span>
                } else<span class="cov8" title="1"> if path[i] == '*' </span><span class="cov8" title="1">{
                        r.insertNode(method, path[:i], staticKind, routeMethod{})
                        pnames = append(pnames, "*")
                        r.insertNode(method, path[:i+1], anyKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})
                }</span>
        }

        <span class="cov8" title="1">r.insertNode(method, path, staticKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})</span>
}

func (r *Router) insertNode(method, path string, t kind, rm routeMethod) <span class="cov8" title="1">{
        // Adjust max param
        paramLen := len(rm.pnames)
        if *r.echo.maxParam &lt; paramLen </span><span class="cov8" title="1">{
                *r.echo.maxParam = paramLen
        }</span>

        <span class="cov8" title="1">currentNode := r.tree // Current node as root
        if currentNode == nil </span><span class="cov0" title="0">{
                panic("echo: invalid method")</span>
        }
        <span class="cov8" title="1">search := path

        for </span><span class="cov8" title="1">{
                searchLen := len(search)
                prefixLen := len(currentNode.prefix)
                lcpLen := 0

                // LCP - Longest Common Prefix (https://en.wikipedia.org/wiki/LCP_array)
                max := prefixLen
                if searchLen &lt; max </span><span class="cov8" title="1">{
                        max = searchLen
                }</span>
                <span class="cov8" title="1">for ; lcpLen &lt; max &amp;&amp; search[lcpLen] == currentNode.prefix[lcpLen]; lcpLen++ </span>{<span class="cov8" title="1">
                }</span>

                <span class="cov8" title="1">if lcpLen == 0 </span><span class="cov8" title="1">{
                        // At root node
                        currentNode.label = search[0]
                        currentNode.prefix = search
                        if rm.handler != nil </span><span class="cov8" title="1">{
                                currentNode.kind = t
                                currentNode.addMethod(method, &amp;rm)
                                currentNode.paramsCount = len(rm.pnames)
                                currentNode.originalPath = rm.ppath
                        }</span>
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.staticChildren == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> if lcpLen &lt; prefixLen </span><span class="cov8" title="1">{
                        // Split node into two before we insert new node.
                        // This happens when we are inserting path that is submatch of any existing inserted paths.
                        // For example, we have node `/test` and now are about to insert `/te/*`. In that case
                        // 1. overlapping part is `/te` that is used as parent node
                        // 2. `st` is part from existing node that is not matching - it gets its own node (child to `/te`)
                        // 3. `/*` is the new part we are about to insert (child to `/te`)
                        n := newNode(
                                currentNode.kind,
                                currentNode.prefix[lcpLen:],
                                currentNode,
                                currentNode.staticChildren,
                                currentNode.originalPath,
                                currentNode.methods,
                                currentNode.paramsCount,
                                currentNode.paramChild,
                                currentNode.anyChild,
                                currentNode.notFoundHandler,
                        )
                        // Update parent path for all children to new node
                        for _, child := range currentNode.staticChildren </span><span class="cov8" title="1">{
                                child.parent = n
                        }</span>
                        <span class="cov8" title="1">if currentNode.paramChild != nil </span><span class="cov8" title="1">{
                                currentNode.paramChild.parent = n
                        }</span>
                        <span class="cov8" title="1">if currentNode.anyChild != nil </span><span class="cov8" title="1">{
                                currentNode.anyChild.parent = n
                        }</span>

                        // Reset parent node
                        <span class="cov8" title="1">currentNode.kind = staticKind
                        currentNode.label = currentNode.prefix[0]
                        currentNode.prefix = currentNode.prefix[:lcpLen]
                        currentNode.staticChildren = nil
                        currentNode.originalPath = ""
                        currentNode.methods = new(routeMethods)
                        currentNode.paramsCount = 0
                        currentNode.paramChild = nil
                        currentNode.anyChild = nil
                        currentNode.isLeaf = false
                        currentNode.isHandler = false
                        currentNode.notFoundHandler = nil

                        // Only Static children could reach here
                        currentNode.addStaticChild(n)

                        if lcpLen == searchLen </span><span class="cov8" title="1">{
                                // At parent node
                                currentNode.kind = t
                                if rm.handler != nil </span><span class="cov8" title="1">{
                                        currentNode.addMethod(method, &amp;rm)
                                        currentNode.paramsCount = len(rm.pnames)
                                        currentNode.originalPath = rm.ppath
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Create child node
                                n = newNode(t, search[lcpLen:], currentNode, nil, "", new(routeMethods), 0, nil, nil, nil)
                                if rm.handler != nil </span><span class="cov8" title="1">{
                                        n.addMethod(method, &amp;rm)
                                        n.paramsCount = len(rm.pnames)
                                        n.originalPath = rm.ppath
                                }</span>
                                // Only Static children could reach here
                                <span class="cov8" title="1">currentNode.addStaticChild(n)</span>
                        }
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.staticChildren == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> if lcpLen &lt; searchLen </span><span class="cov8" title="1">{
                        search = search[lcpLen:]
                        c := currentNode.findChildWithLabel(search[0])
                        if c != nil </span><span class="cov8" title="1">{
                                // Go deeper
                                currentNode = c
                                continue</span>
                        }
                        // Create child node
                        <span class="cov8" title="1">n := newNode(t, search, currentNode, nil, rm.ppath, new(routeMethods), 0, nil, nil, nil)
                        if rm.handler != nil </span><span class="cov8" title="1">{
                                n.addMethod(method, &amp;rm)
                                n.paramsCount = len(rm.pnames)
                        }</span>

                        <span class="cov8" title="1">switch t </span>{
                        case staticKind:<span class="cov8" title="1">
                                currentNode.addStaticChild(n)</span>
                        case paramKind:<span class="cov8" title="1">
                                currentNode.paramChild = n</span>
                        case anyKind:<span class="cov8" title="1">
                                currentNode.anyChild = n</span>
                        }
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.staticChildren == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> {
                        // Node already exists
                        if rm.handler != nil </span><span class="cov8" title="1">{
                                currentNode.addMethod(method, &amp;rm)
                                currentNode.paramsCount = len(rm.pnames)
                                currentNode.originalPath = rm.ppath
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
}

func newNode(
        t kind,
        pre string,
        p *node,
        sc children,
        originalPath string,
        methods *routeMethods,
        paramsCount int,
        paramChildren,
        anyChildren *node,
        notFoundHandler *routeMethod,
) *node <span class="cov8" title="1">{
        return &amp;node{
                kind:            t,
                label:           pre[0],
                prefix:          pre,
                parent:          p,
                staticChildren:  sc,
                originalPath:    originalPath,
                methods:         methods,
                paramsCount:     paramsCount,
                paramChild:      paramChildren,
                anyChild:        anyChildren,
                isLeaf:          sc == nil &amp;&amp; paramChildren == nil &amp;&amp; anyChildren == nil,
                isHandler:       methods.isHandler(),
                notFoundHandler: notFoundHandler,
        }
}</span>

func (n *node) addStaticChild(c *node) <span class="cov8" title="1">{
        n.staticChildren = append(n.staticChildren, c)
}</span>

func (n *node) findStaticChild(l byte) *node <span class="cov8" title="1">{
        for _, c := range n.staticChildren </span><span class="cov8" title="1">{
                if c.label == l </span><span class="cov8" title="1">{
                        return c
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (n *node) findChildWithLabel(l byte) *node <span class="cov8" title="1">{
        if c := n.findStaticChild(l); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">if l == paramLabel </span><span class="cov8" title="1">{
                return n.paramChild
        }</span>
        <span class="cov8" title="1">if l == anyLabel </span><span class="cov8" title="1">{
                return n.anyChild
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (n *node) addMethod(method string, h *routeMethod) <span class="cov8" title="1">{
        switch method </span>{
        case http.MethodConnect:<span class="cov8" title="1">
                n.methods.connect = h</span>
        case http.MethodDelete:<span class="cov8" title="1">
                n.methods.delete = h</span>
        case http.MethodGet:<span class="cov8" title="1">
                n.methods.get = h</span>
        case http.MethodHead:<span class="cov8" title="1">
                n.methods.head = h</span>
        case http.MethodOptions:<span class="cov8" title="1">
                n.methods.options = h</span>
        case http.MethodPatch:<span class="cov8" title="1">
                n.methods.patch = h</span>
        case http.MethodPost:<span class="cov8" title="1">
                n.methods.post = h</span>
        case PROPFIND:<span class="cov8" title="1">
                n.methods.propfind = h</span>
        case http.MethodPut:<span class="cov8" title="1">
                n.methods.put = h</span>
        case http.MethodTrace:<span class="cov8" title="1">
                n.methods.trace = h</span>
        case REPORT:<span class="cov8" title="1">
                n.methods.report = h</span>
        case RouteNotFound:<span class="cov8" title="1">
                n.notFoundHandler = h
                return</span> // RouteNotFound/404 is not considered as a handler so no further logic needs to be executed
        default:<span class="cov8" title="1">
                if n.methods.anyOther == nil </span><span class="cov8" title="1">{
                        n.methods.anyOther = make(map[string]*routeMethod)
                }</span>
                <span class="cov8" title="1">if h.handler == nil </span><span class="cov0" title="0">{
                        delete(n.methods.anyOther, method)
                }</span> else<span class="cov8" title="1"> {
                        n.methods.anyOther[method] = h
                }</span>
        }

        <span class="cov8" title="1">n.methods.updateAllowHeader()
        n.isHandler = true</span>
}

func (n *node) findMethod(method string) *routeMethod <span class="cov8" title="1">{
        switch method </span>{
        case http.MethodConnect:<span class="cov8" title="1">
                return n.methods.connect</span>
        case http.MethodDelete:<span class="cov8" title="1">
                return n.methods.delete</span>
        case http.MethodGet:<span class="cov8" title="1">
                return n.methods.get</span>
        case http.MethodHead:<span class="cov8" title="1">
                return n.methods.head</span>
        case http.MethodOptions:<span class="cov8" title="1">
                return n.methods.options</span>
        case http.MethodPatch:<span class="cov8" title="1">
                return n.methods.patch</span>
        case http.MethodPost:<span class="cov8" title="1">
                return n.methods.post</span>
        case PROPFIND:<span class="cov8" title="1">
                return n.methods.propfind</span>
        case http.MethodPut:<span class="cov8" title="1">
                return n.methods.put</span>
        case http.MethodTrace:<span class="cov8" title="1">
                return n.methods.trace</span>
        case REPORT:<span class="cov8" title="1">
                return n.methods.report</span>
        default:<span class="cov8" title="1"> // RouteNotFound/404 is not considered as a handler
                return n.methods.anyOther[method]</span>
        }
}

func optionsMethodHandler(allowMethods string) func(c Context) error <span class="cov8" title="1">{
        return func(c Context) error </span><span class="cov8" title="1">{
                // Note: we are not handling most of the CORS headers here. CORS is handled by CORS middleware
                // 'OPTIONS' method RFC: https://httpwg.org/specs/rfc7231.html#OPTIONS
                // 'Allow' header RFC: https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1
                c.Response().Header().Add(HeaderAllow, allowMethods)
                return c.NoContent(http.StatusNoContent)
        }</span>
}

// Find lookup a handler registered for method and path. It also parses URL for path
// parameters and load them into context.
//
// For performance:
//
// - Get context from `Echo#AcquireContext()`
// - Reset it `Context#Reset()`
// - Return it `Echo#ReleaseContext()`.
func (r *Router) Find(method, path string, c Context) <span class="cov8" title="1">{
        ctx := c.(*context)
        currentNode := r.tree // Current node as root

        var (
                previousBestMatchNode *node
                matchedRouteMethod    *routeMethod
                // search stores the remaining path to check for match. By each iteration we move from start of path to end of the path
                // and search value gets shorter and shorter.
                search      = path
                searchIndex = 0
                paramIndex  int           // Param counter
                paramValues = ctx.pvalues // Use the internal slice so the interface can keep the illusion of a dynamic slice
        )

        // Backtracking is needed when a dead end (leaf node) is reached in the router tree.
        // To backtrack the current node will be changed to the parent node and the next kind for the
        // router logic will be returned based on fromKind or kind of the dead end node (static &gt; param &gt; any).
        // For example if there is no static node match we should check parent next sibling by kind (param).
        // Backtracking itself does not check if there is a next sibling, this is done by the router logic.
        backtrackToNextNodeKind := func(fromKind kind) (nextNodeKind kind, valid bool) </span><span class="cov8" title="1">{
                previous := currentNode
                currentNode = previous.parent
                valid = currentNode != nil

                // Next node type by priority
                if previous.kind == anyKind </span><span class="cov8" title="1">{
                        nextNodeKind = staticKind
                }</span> else<span class="cov8" title="1"> {
                        nextNodeKind = previous.kind + 1
                }</span>

                <span class="cov8" title="1">if fromKind == staticKind </span><span class="cov8" title="1">{
                        // when backtracking is done from static kind block we did not change search so nothing to restore
                        return
                }</span>

                // restore search to value it was before we move to current node we are backtracking from.
                <span class="cov8" title="1">if previous.kind == staticKind </span><span class="cov8" title="1">{
                        searchIndex -= len(previous.prefix)
                }</span> else<span class="cov8" title="1"> {
                        paramIndex--
                        // for param/any node.prefix value is always `:` so we can not deduce searchIndex from that and must use pValue
                        // for that index as it would also contain part of path we cut off before moving into node we are backtracking from
                        searchIndex -= len(paramValues[paramIndex])
                        paramValues[paramIndex] = ""
                }</span>
                <span class="cov8" title="1">search = path[searchIndex:]
                return</span>
        }

        // Router tree is implemented by longest common prefix array (LCP array) https://en.wikipedia.org/wiki/LCP_array
        // Tree search is implemented as for loop where one loop iteration is divided into 3 separate blocks
        // Each of these blocks checks specific kind of node (static/param/any). Order of blocks reflex their priority in routing.
        // Search order/priority is: static &gt; param &gt; any.
        //
        // Note: backtracking in tree is implemented by replacing/switching currentNode to previous node
        // and hoping to (goto statement) next block by priority to check if it is the match.
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                prefixLen := 0 // Prefix length
                lcpLen := 0    // LCP (longest common prefix) length

                if currentNode.kind == staticKind </span><span class="cov8" title="1">{
                        searchLen := len(search)
                        prefixLen = len(currentNode.prefix)

                        // LCP - Longest Common Prefix (https://en.wikipedia.org/wiki/LCP_array)
                        max := prefixLen
                        if searchLen &lt; max </span><span class="cov8" title="1">{
                                max = searchLen
                        }</span>
                        <span class="cov8" title="1">for ; lcpLen &lt; max &amp;&amp; search[lcpLen] == currentNode.prefix[lcpLen]; lcpLen++ </span>{<span class="cov8" title="1">
                        }</span>
                }

                <span class="cov8" title="1">if lcpLen != prefixLen </span><span class="cov8" title="1">{
                        // No matching prefix, let's backtrack to the first possible alternative node of the decision path
                        nk, ok := backtrackToNextNodeKind(staticKind)
                        if !ok </span><span class="cov8" title="1">{
                                return // No other possibilities on the decision path, handler will be whatever context is reset to.
                        }</span> else<span class="cov8" title="1"> if nk == paramKind </span><span class="cov8" title="1">{
                                goto Param</span>
                                // NOTE: this case (backtracking from static node to previous any node) can not happen by current any matching logic. Any node is end of search currently
                                //} else if nk == anyKind {
                                //        goto Any
                        } else<span class="cov0" title="0"> {
                                // Not found (this should never be possible for static node we are looking currently)
                                break</span>
                        }
                }

                // The full prefix has matched, remove the prefix from the remaining search
                <span class="cov8" title="1">search = search[lcpLen:]
                searchIndex = searchIndex + lcpLen

                // Finish routing if is no request path remaining to search
                if search == "" </span><span class="cov8" title="1">{
                        // in case of node that is handler we have exact method type match or something for 405 to use
                        if currentNode.isHandler </span><span class="cov8" title="1">{
                                // check if current node has handler registered for http method we are looking for. we store currentNode as
                                // best matching in case we do no find no more routes matching this path+method
                                if previousBestMatchNode == nil </span><span class="cov8" title="1">{
                                        previousBestMatchNode = currentNode
                                }</span>
                                <span class="cov8" title="1">if h := currentNode.findMethod(method); h != nil </span><span class="cov8" title="1">{
                                        matchedRouteMethod = h
                                        break</span>
                                }
                        } else<span class="cov8" title="1"> if currentNode.notFoundHandler != nil </span><span class="cov8" title="1">{
                                matchedRouteMethod = currentNode.notFoundHandler
                                break</span>
                        }
                }

                // Static node
                <span class="cov8" title="1">if search != "" </span><span class="cov8" title="1">{
                        if child := currentNode.findStaticChild(search[0]); child != nil </span><span class="cov8" title="1">{
                                currentNode = child
                                continue</span>
                        }
                }

        Param:
                // Param node
                <span class="cov8" title="1">if child := currentNode.paramChild; search != "" &amp;&amp; child != nil </span><span class="cov8" title="1">{
                        currentNode = child
                        i := 0
                        l := len(search)
                        if currentNode.isLeaf </span><span class="cov8" title="1">{
                                // when param node does not have any children (path param is last piece of route path) then param node should
                                // act similarly to any node - consider all remaining search as match
                                i = l
                        }</span> else<span class="cov8" title="1"> {
                                for ; i &lt; l &amp;&amp; search[i] != '/'; i++ </span>{<span class="cov8" title="1">
                                }</span>
                        }

                        <span class="cov8" title="1">paramValues[paramIndex] = search[:i]
                        paramIndex++
                        search = search[i:]
                        searchIndex = searchIndex + i
                        continue</span>
                }

        Any:
                // Any node
                <span class="cov8" title="1">if child := currentNode.anyChild; child != nil </span><span class="cov8" title="1">{
                        // If any node is found, use remaining path for paramValues
                        currentNode = child
                        paramValues[currentNode.paramsCount-1] = search

                        // update indexes/search in case we need to backtrack when no handler match is found
                        paramIndex++
                        searchIndex += +len(search)
                        search = ""

                        if h := currentNode.findMethod(method); h != nil </span><span class="cov8" title="1">{
                                matchedRouteMethod = h
                                break</span>
                        }
                        // we store currentNode as best matching in case we do not find more routes matching this path+method. Needed for 405
                        <span class="cov8" title="1">if previousBestMatchNode == nil </span><span class="cov8" title="1">{
                                previousBestMatchNode = currentNode
                        }</span>
                        <span class="cov8" title="1">if currentNode.notFoundHandler != nil </span><span class="cov8" title="1">{
                                matchedRouteMethod = currentNode.notFoundHandler
                                break</span>
                        }
                }

                // Let's backtrack to the first possible alternative node of the decision path
                <span class="cov8" title="1">nk, ok := backtrackToNextNodeKind(anyKind)
                if !ok </span><span class="cov8" title="1">{
                        break</span> // No other possibilities on the decision path
                } else<span class="cov8" title="1"> if nk == paramKind </span><span class="cov8" title="1">{
                        goto Param</span>
                } else<span class="cov8" title="1"> if nk == anyKind </span><span class="cov8" title="1">{
                        goto Any</span>
                } else<span class="cov8" title="1"> {
                        // Not found
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentNode == nil &amp;&amp; previousBestMatchNode == nil </span><span class="cov8" title="1">{
                return // nothing matched at all
        }</span>

        // matchedHandler could be method+path handler that we matched or notFoundHandler from node with matching path
        // user provided not found (404) handler has priority over generic method not found (405) handler or global 404 handler
        <span class="cov8" title="1">var rPath string
        var rPNames []string
        if matchedRouteMethod != nil </span><span class="cov8" title="1">{
                rPath = matchedRouteMethod.ppath
                rPNames = matchedRouteMethod.pnames
                ctx.handler = matchedRouteMethod.handler
        }</span> else<span class="cov8" title="1"> {
                // use previous match as basis. although we have no matching handler we have path match.
                // so we can send http.StatusMethodNotAllowed (405) instead of http.StatusNotFound (404)
                currentNode = previousBestMatchNode

                rPath = currentNode.originalPath
                rPNames = nil // no params here
                ctx.handler = NotFoundHandler
                if currentNode.notFoundHandler != nil </span><span class="cov8" title="1">{
                        rPath = currentNode.notFoundHandler.ppath
                        rPNames = currentNode.notFoundHandler.pnames
                        ctx.handler = currentNode.notFoundHandler.handler
                }</span> else<span class="cov8" title="1"> if currentNode.isHandler </span><span class="cov8" title="1">{
                        ctx.Set(ContextKeyHeaderAllow, currentNode.methods.allowHeader)
                        ctx.handler = MethodNotAllowedHandler
                        if method == http.MethodOptions </span><span class="cov8" title="1">{
                                ctx.handler = optionsMethodHandler(currentNode.methods.allowHeader)
                        }</span>
                }
        }
        <span class="cov8" title="1">ctx.path = rPath
        ctx.pnames = rPNames</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
